From 2704d29c9b74bb78bb19054453481e15bc1efbeb Mon Sep 17 00:00:00 2001
From: Rufus Hamade <rufus.hamade@imgtec.com>
Date: Mon, 8 Aug 2016 16:27:00 +0100
Subject: [PATCH] pvr: Introduce PowerVR DRI driver.

Change-Id: I0c0b1973ce94c80277f207411fb10bc99aa6b594
---
 configure.ac                                       |    8 +
 src/mesa/drivers/dri/Makefile.am                   |    6 +
 src/mesa/drivers/dri/pvr/Makefile.am               |   24 +
 src/mesa/drivers/dri/pvr/Makefile.sources          |   13 +
 src/mesa/drivers/dri/pvr/g_set_mesa_ogl_dispatch.h | 1130 +++++++++++++++
 .../drivers/dri/pvr/g_set_mesa_ogles1_dispatch.h   |  364 +++++
 .../drivers/dri/pvr/g_set_mesa_ogles2_dispatch.h   |  792 ++++++++++
 src/mesa/drivers/dri/pvr/imgpixfmts.h              |   68 +
 src/mesa/drivers/dri/pvr/imgyuv.h                  |   58 +
 src/mesa/drivers/dri/pvr/mesa_context.c            |  230 +++
 src/mesa/drivers/dri/pvr/pvr_dri_support.h         |  349 +++++
 src/mesa/drivers/dri/pvr/pvr_mesa_version.h        |   39 +
 src/mesa/drivers/dri/pvr/pvr_object_cache.c        |  311 ++++
 src/mesa/drivers/dri/pvr/pvr_object_cache.h        |  137 ++
 src/mesa/drivers/dri/pvr/pvrdrawable.c             |  743 ++++++++++
 src/mesa/drivers/dri/pvr/pvrdri.c                  | 1514 ++++++++++++++++++++
 src/mesa/drivers/dri/pvr/pvrdri.h                  |  280 ++++
 src/mesa/drivers/dri/pvr/pvrext.c                  |  332 +++++
 src/mesa/drivers/dri/pvr/pvrimage.c                | 1084 ++++++++++++++
 src/mesa/drivers/dri/pvr/pvrimage.h                |   96 ++
 src/mesa/drivers/dri/pvr/pvrmesa.h                 |   43 +
 src/mesa/drivers/dri/pvr/pvrqueue.h                |   74 +
 src/mesa/drivers/dri/pvr/pvrsyncobj.c              |  206 +++
 src/mesa/drivers/dri/pvr/pvrsyncobj.h              |   48 +
 src/mesa/drivers/dri/pvr/pvrutil.c                 |  512 +++++++
 25 files changed, 8461 insertions(+)
 create mode 100644 src/mesa/drivers/dri/pvr/Makefile.am
 create mode 100644 src/mesa/drivers/dri/pvr/Makefile.sources
 create mode 100644 src/mesa/drivers/dri/pvr/g_set_mesa_ogl_dispatch.h
 create mode 100644 src/mesa/drivers/dri/pvr/g_set_mesa_ogles1_dispatch.h
 create mode 100644 src/mesa/drivers/dri/pvr/g_set_mesa_ogles2_dispatch.h
 create mode 100644 src/mesa/drivers/dri/pvr/imgpixfmts.h
 create mode 100644 src/mesa/drivers/dri/pvr/imgyuv.h
 create mode 100644 src/mesa/drivers/dri/pvr/mesa_context.c
 create mode 100644 src/mesa/drivers/dri/pvr/pvr_dri_support.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvr_mesa_version.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvr_object_cache.c
 create mode 100644 src/mesa/drivers/dri/pvr/pvr_object_cache.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvrdrawable.c
 create mode 100644 src/mesa/drivers/dri/pvr/pvrdri.c
 create mode 100644 src/mesa/drivers/dri/pvr/pvrdri.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvrext.c
 create mode 100644 src/mesa/drivers/dri/pvr/pvrimage.c
 create mode 100644 src/mesa/drivers/dri/pvr/pvrimage.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvrmesa.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvrqueue.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvrsyncobj.c
 create mode 100644 src/mesa/drivers/dri/pvr/pvrsyncobj.h
 create mode 100644 src/mesa/drivers/dri/pvr/pvrutil.c

diff --git a/configure.ac b/configure.ac
index c492e15..ec1e90f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -72,6 +72,7 @@ LIBDRM_REQUIRED=2.4.66
 LIBDRM_RADEON_REQUIRED=2.4.56
 LIBDRM_AMDGPU_REQUIRED=2.4.63
 LIBDRM_INTEL_REQUIRED=2.4.61
+LIBDRM_PVR_REQUIRED=2.4.60
 LIBDRM_NVVIEUX_REQUIRED=2.4.66
 LIBDRM_NOUVEAU_REQUIRED=2.4.66
 LIBDRM_FREEDRENO_REQUIRED=2.4.67
@@ -1605,6 +1606,11 @@ if test -n "$with_dri_drivers"; then
             HAVE_R200_DRI=yes;
             PKG_CHECK_MODULES([RADEON], [libdrm_radeon >= $LIBDRM_RADEON_REQUIRED])
             ;;
+        xpvr)
+            HAVE_PVR_DRI=yes;
+            PKG_CHECK_MODULES([PVR], [libdrm >= $LIBDRM_PVR_REQUIRED])
+            DRI_LIB_DEPS="$DRI_LIB_DEPS -lpvr_dri_support"
+            ;;
         xswrast)
             HAVE_SWRAST_DRI=yes;
             ;;
@@ -2537,6 +2543,7 @@ AM_CONDITIONAL(HAVE_I965_DRI, test x$HAVE_I965_DRI = xyes)
 AM_CONDITIONAL(HAVE_NOUVEAU_DRI, test x$HAVE_NOUVEAU_DRI = xyes)
 AM_CONDITIONAL(HAVE_R200_DRI, test x$HAVE_R200_DRI = xyes)
 AM_CONDITIONAL(HAVE_RADEON_DRI, test x$HAVE_RADEON_DRI = xyes)
+AM_CONDITIONAL(HAVE_PVR_DRI, test x$HAVE_PVR_DRI = xyes)
 AM_CONDITIONAL(HAVE_SWRAST_DRI, test x$HAVE_SWRAST_DRI = xyes)
 
 AM_CONDITIONAL(HAVE_INTEL_VULKAN, test "x$HAVE_INTEL_VULKAN" = xyes)
@@ -2723,6 +2730,7 @@ AC_CONFIG_FILES([Makefile
 		src/mesa/drivers/dri/nouveau/Makefile
 		src/mesa/drivers/dri/r200/Makefile
 		src/mesa/drivers/dri/radeon/Makefile
+		src/mesa/drivers/dri/pvr/Makefile
 		src/mesa/drivers/dri/swrast/Makefile
 		src/mesa/drivers/osmesa/Makefile
 		src/mesa/drivers/osmesa/osmesa.pc
diff --git a/src/mesa/drivers/dri/Makefile.am b/src/mesa/drivers/dri/Makefile.am
index 1c6dd08..2e5dd6b 100644
--- a/src/mesa/drivers/dri/Makefile.am
+++ b/src/mesa/drivers/dri/Makefile.am
@@ -43,6 +43,12 @@ MEGADRIVERS_DEPS += radeon/libradeon_dri.la
 MEGADRIVERS += radeon_dri.so
 endif
 
+if HAVE_PVR_DRI
+SUBDIRS += pvr
+MEGADRIVERS_DEPS += pvr/libpvr_dri.la
+MEGADRIVERS += pvr_dri.so
+endif
+
 if HAVE_SWRAST_DRI
 SUBDIRS += swrast
 MEGADRIVERS_DEPS += swrast/libswrast_dri.la
diff --git a/src/mesa/drivers/dri/pvr/Makefile.am b/src/mesa/drivers/dri/pvr/Makefile.am
new file mode 100644
index 0000000..c3004da
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/Makefile.am
@@ -0,0 +1,24 @@
+
+include Makefile.sources
+
+AM_CFLAGS = \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/src \
+	-I$(top_srcdir)/src/mapi \
+	-I$(top_srcdir)/src/mapi/glapi \
+	-I$(top_srcdir)/src/mesa \
+	-I$(top_srcdir)/src/mesa/main \
+	-I$(top_srcdir)/src/mesa/drivers/dri/common \
+	$(DEFINES) \
+	$(VISIBILITY_CFLAGS) \
+	$(PVR_CFLAGS)
+
+AM_CFLAGS += -DPVR_OGLES1_LIB=\"libGLESv1_CM.so\"
+AM_CFLAGS += -DPVR_OGLES2_LIB=\"libGLESv2.so\"
+
+AM_CXXFLAGS = $(AM_CFLAGS)
+
+noinst_LTLIBRARIES = libpvr_dri.la
+libpvr_dri_la_SOURCES = $(pvr_FILES)
+libpvr_dri_la_LIBADD = $(INTEL_LIBS)
+
diff --git a/src/mesa/drivers/dri/pvr/Makefile.sources b/src/mesa/drivers/dri/pvr/Makefile.sources
new file mode 100644
index 0000000..2458b38
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/Makefile.sources
@@ -0,0 +1,13 @@
+pvr_INCLUDES = \
+	$(MESA_TOP)/src \
+	$(MESA_TOP)/src/mesa/drivers/dri/pvr
+
+pvr_FILES = \
+ mesa_context.c \
+ pvrdrawable.c \
+ pvrdri.c \
+ pvrext.c \
+ pvrimage.c \
+ pvrsyncobj.c \
+ pvrutil.c \
+ pvr_object_cache.c
diff --git a/src/mesa/drivers/dri/pvr/g_set_mesa_ogl_dispatch.h b/src/mesa/drivers/dri/pvr/g_set_mesa_ogl_dispatch.h
new file mode 100644
index 0000000..885b8e9
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/g_set_mesa_ogl_dispatch.h
@@ -0,0 +1,1130 @@
+#ifndef __g_pvrogl_set_mesa_dispatch_h_
+#define __g_pvrogl_set_mesa_dispatch_h_
+
+typedef _glapi_proc (*pvroglGetProcAddress)(PVRDRIScreenImpl *psScreenImpl, const char *psProcName);
+
+static void
+pvrogl_add_mesa_dispatch(struct _glapi_table *psTab, const char *psFunc, PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle, pvroglGetProcAddress pfGetProcAddress)
+{
+    int iOffset;
+    const char *asFunc[] = {NULL, NULL};
+    _glapi_proc pfFunc;
+    const char *error;
+
+    (void) dlerror();
+    pfFunc = dlsym(pvLibHandle, psFunc);
+    error = dlerror();
+    if (error != NULL)
+    {
+        pfFunc = pfGetProcAddress(psScreenImpl, psFunc);
+        if (pfFunc == NULL)
+        {
+#if 0
+            /*
+             * Not all extensions are supported, so there may be quite
+             * a lot of lookup failures.
+             */
+            _mesa_warning(NULL, "Couldn't get address of %s", psFunc);
+#endif
+            return;
+        }
+    }
+
+    asFunc[0] = psFunc;
+    iOffset = _glapi_add_dispatch(asFunc, "");
+    if (iOffset == -1)
+    {
+        _mesa_warning(NULL, "Couldn't add %s to the Mesa dispatch table", psFunc);
+    }
+    else
+    {
+        SET_by_offset(psTab, iOffset, pfFunc);
+    }
+}
+
+static void
+pvrogl_set_mesa_dispatch(struct _glapi_table *psTab, PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle, pvroglGetProcAddress pfGetProcAddress)
+{
+    pvrogl_add_mesa_dispatch(psTab, "glCullFace", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFrontFace", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glHint", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLineWidth", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPointSize", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPolygonMode", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glScissor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexParameterf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexImage1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClear", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearColor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearStencil", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearDepth", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glStencilMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColorMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDepthMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDisable", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEnable", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFinish", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFlush", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLogicOp", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glStencilFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glStencilOp", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDepthFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelStoref", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelStorei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glReadBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glReadPixels", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBooleanv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetDoublev", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetError", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetFloatv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetIntegerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetString", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexImage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexLevelParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexLevelParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsEnabled", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDepthRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glViewport", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNewList", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEndList", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCallList", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCallLists", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteLists", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenLists", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glListBase", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBegin", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBitmap", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3b", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3bv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3ub", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3ubv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3us", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor3usv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4b", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4bv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4ub", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4ubv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4us", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColor4usv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEdgeFlag", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEdgeFlagv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEnd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexdv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexs", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexsv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3b", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3bv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormal3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos2sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRasterPos4sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRectd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRectdv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRectf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRectfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRecti", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRectiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRects", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRectsv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord1sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord2sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoord4sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex2sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertex4sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClipPlane", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColorMaterial", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLightf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLightfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLighti", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLightiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLightModelf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLightModelfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLightModeli", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLightModeliv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLineStipple", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMaterialf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMaterialfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMateriali", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMaterialiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPolygonStipple", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glShadeModel", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexEnvf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexEnvfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexEnvi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexEnviv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexGend", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexGendv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexGenf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexGenfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexGeni", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexGeniv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFeedbackBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSelectBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRenderMode", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInitNames", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLoadName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPassThrough", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPopName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPushName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearAccum", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glAccum", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPopAttrib", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPushAttrib", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMap1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMap1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMap2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMap2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMapGrid1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMapGrid1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMapGrid2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMapGrid2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord1dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalCoord2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalMesh1", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalPoint1", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalMesh2", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEvalPoint2", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glAlphaFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelZoom", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelTransferf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelTransferi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelMapfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelMapuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPixelMapusv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyPixels", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawPixels", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetClipPlane", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetLightfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetLightiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetMapdv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetMapfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetMapiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetMaterialfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetMaterialiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetPixelMapfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetPixelMapuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetPixelMapusv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetPolygonStipple", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexEnvfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexEnviv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexGendv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexGenfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexGeniv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsList", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFrustum", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLoadIdentity", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLoadMatrixf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLoadMatrixd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMatrixMode", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultMatrixf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultMatrixd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glOrtho", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPopMatrix", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPushMatrix", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRotated", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRotatef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glScaled", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glScalef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTranslated", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTranslatef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElements", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetPointerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPolygonOffset", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyTexImage1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyTexSubImage1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexSubImage1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteTextures", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenTextures", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glArrayElement", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColorPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDisableClientState", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEdgeFlagPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEnableClientState", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInterleavedArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glNormalPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexCoordPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glAreTexturesResident", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPrioritizeTextures", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexub", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIndexubv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPopClientAttrib", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPushClientAttrib", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendColor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendEquation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawRangeElements", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexSubImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyTexSubImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glActiveTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSampleCoverage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompressedTexImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompressedTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompressedTexImage1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompressedTexSubImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompressedTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompressedTexSubImage1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetCompressedTexImage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClientActiveTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLoadTransposeMatrixf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLoadTransposeMatrixd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultTransposeMatrixf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultTransposeMatrixd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendFuncSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiDrawArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiDrawElements", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPointParameterf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPointParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPointParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPointParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogCoordf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogCoordfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogCoordd", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogCoorddv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFogCoordPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3b", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3bv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3ub", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3ubv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3us", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3usv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColorPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos2sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWindowPos3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenQueries", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteQueries", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsQuery", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBeginQuery", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEndQuery", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryObjectiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryObjectuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBufferData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBufferSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBufferSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMapBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUnmapBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBufferParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBufferPointerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendEquationSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glStencilOpSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glStencilFuncSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glStencilMaskSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glAttachShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindAttribLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompileShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCreateProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCreateShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDetachShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDisableVertexAttribArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEnableVertexAttribArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveAttrib", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveUniform", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetAttachedShaders", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetAttribLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramInfoLog", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetShaderiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetShaderInfoLog", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetShaderSource", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribdv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribPointerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLinkProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glShaderSource", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUseProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glValidateProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4Nbv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4Niv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4Nsv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4Nub", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4Nubv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4Nuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4Nusv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4bv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4s", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4ubv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4usv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix2x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix3x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix2x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix4x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix3x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix4x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColorMaski", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBooleani_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetIntegeri_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEnablei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDisablei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsEnabledi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBeginTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEndTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindBufferRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindBufferBase", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTransformFeedbackVaryings", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTransformFeedbackVarying", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClampColor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBeginConditionalRender", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEndConditionalRender", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribIPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI1i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI1ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI2ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI1iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI1uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI2uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4bv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4sv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4ubv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribI4usv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindFragDataLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetFragDataLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetTexParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearBufferiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearBufferuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearBufferfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearBufferfi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetStringi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawArraysInstanced", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElementsInstanced", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPrimitiveRestartIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetInteger64i_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBufferParameteri64v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribDivisor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glActiveTextureARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClientActiveTextureARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord1svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord2svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord3svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiTexCoord4svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib1svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib2svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib3svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4NbvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4NivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4NsvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4NubARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4NubvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4NuivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4NusvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4bvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4sARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4svARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4ubvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4uivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttrib4usvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribPointerARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEnableVertexAttribArrayARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDisableVertexAttribArrayARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramStringARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindProgramARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteProgramsARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenProgramsARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramEnvParameter4dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramEnvParameter4dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramEnvParameter4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramEnvParameter4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramLocalParameter4dARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramLocalParameter4dvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramLocalParameter4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramLocalParameter4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramEnvParameterdvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramEnvParameterfvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramLocalParameterdvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramLocalParameterfvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramStringARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribdvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribfvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribPointervARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsProgramARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindBufferARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteBuffersARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenBuffersARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsBufferARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBufferDataARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBufferSubDataARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBufferSubDataARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMapBufferARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUnmapBufferARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBufferParameterivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBufferPointervARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenQueriesARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteQueriesARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsQueryARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBeginQueryARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEndQueryARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryObjectivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryObjectuivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteObjectARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetHandleARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDetachObjectARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCreateShaderObjectARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glShaderSourceARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCompileShaderARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCreateProgramObjectARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glAttachObjectARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLinkProgramARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUseProgramObjectARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glValidateProgramARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4iARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4ivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix2fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix3fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetObjectParameterfvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetObjectParameterivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetInfoLogARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetAttachedObjectsARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformLocationARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveUniformARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformfvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformivARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetShaderSourceARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindAttribLocationARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveAttribARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetAttribLocationARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawBuffersARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClampColorARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawArraysInstancedARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElementsInstancedARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsRenderbuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindRenderbuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteRenderbuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenRenderbuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRenderbufferStorage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetRenderbufferParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteFramebuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenFramebuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCheckFramebufferStatus", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTexture1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTexture2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTexture3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferRenderbuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetFramebufferAttachmentParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenerateMipmap", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlitFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTextureLayer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramParameteriARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTextureARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTextureLayerARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTextureFaceARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribDivisorARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMapBufferRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFlushMappedBufferRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexBufferARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindVertexArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteVertexArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenVertexArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsVertexArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformIndices", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveUniformsiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveUniformName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformBlockIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveUniformBlockiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveUniformBlockName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformBlockBinding", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyBufferSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElementsBaseVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawRangeElementsBaseVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiDrawElementsBaseVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProvokingVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFenceSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClientWaitSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glWaitSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetInteger64v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetSynciv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexImage2DMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexImage3DMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetMultisamplefv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSampleMaski", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendEquationiARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendEquationSeparateiARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendFunciARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendFuncSeparateiARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMinSampleShadingARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindFragDataLocationIndexed", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetFragDataIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenSamplers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteSamplers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsSampler", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindSampler", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSamplerParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSamplerParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSamplerParameterf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSamplerParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSamplerParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSamplerParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetSamplerParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetSamplerParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetSamplerParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetSamplerParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glQueryCounter", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryObjecti64v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryObjectui64v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP1ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP1uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP2ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP2uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribP4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawArraysIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElementsIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform1dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniform4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix2x3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix2x4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix3x2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix3x4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix4x2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformMatrix4x3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformdv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetSubroutineUniformLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetSubroutineIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveSubroutineUniformiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveSubroutineUniformName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveSubroutineName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUniformSubroutinesuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetUniformSubroutineuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramStageiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPatchParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPatchParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteTransformFeedbacks", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenTransformFeedbacks", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glPauseTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glResumeTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawTransformFeedbackStream", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBeginQueryIndexed", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEndQueryIndexed", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetQueryIndexediv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glReleaseShaderCompiler", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glShaderBinary", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetShaderPrecisionFormat", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDepthRangef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glClearDepthf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramBinary", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramBinary", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUseProgramStages", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glActiveShaderProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCreateShaderProgramv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindProgramPipeline", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteProgramPipelines", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenProgramPipelines", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsProgramPipeline", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramPipelineiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform1uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform2uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniform4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glValidateProgramPipeline", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramPipelineInfoLog", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL1d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL2d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL3d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL4d", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL1dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL2dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL3dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribL4dv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribLPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetVertexAttribLdv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glViewportArrayv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glViewportIndexedf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glViewportIndexedfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glScissorArrayv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glScissorIndexed", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glScissorIndexedv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDepthRangeArrayv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDepthRangeIndexed", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetFloati_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetDoublei_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawArraysInstancedBaseInstance", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseInstance", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseVertexBaseInstance", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetInternalformativ", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetActiveAtomicCounterBufferiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindImageTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMemoryBarrier", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexStorage1D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexStorage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexStorage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDispatchCompute", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDispatchComputeIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCopyImageSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTextureView", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindVertexBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribFormat", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribIFormat", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribLFormat", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexAttribBinding", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glVertexBindingDivisor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInvalidateTexSubImage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInvalidateTexImage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInvalidateBufferSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInvalidateBufferData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInvalidateFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glInvalidateSubFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiDrawArraysIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glMultiDrawElementsIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramInterfaceiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramResourceIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramResourceName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramResourceiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramResourceLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetProgramResourceLocationIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glShaderStorageBlockBinding", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexStorage2DMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glTexStorage3DMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glLockArraysEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glUnlockArraysEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3bEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3bvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3dEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3dvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3fEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3iEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3ivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3sEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3svEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3ubEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3ubvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3uiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3uivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3usEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColor3usvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glSecondaryColorPointerEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glActiveStencilFaceEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlendEquationSeparateEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsRenderbufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindRenderbufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteRenderbuffersEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenRenderbuffersEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRenderbufferStorageEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetRenderbufferParameterivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsFramebufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBindFramebufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDeleteFramebuffersEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenFramebuffersEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glCheckFramebufferStatusEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTexture1DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTexture2DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferTexture3DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glFramebufferRenderbufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetFramebufferAttachmentParameterivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGenerateMipmapEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glBlitFramebufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramEnvParameters4fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glProgramLocalParameters4fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glColorMaskIndexedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetBooleanIndexedvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glGetIntegerIndexedvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glEnableIndexedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glDisableIndexedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogl_add_mesa_dispatch(psTab, "glIsEnabledIndexedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+}
+
+#endif /* __g_pvrogl_set_mesa_dispatch_h_ */
diff --git a/src/mesa/drivers/dri/pvr/g_set_mesa_ogles1_dispatch.h b/src/mesa/drivers/dri/pvr/g_set_mesa_ogles1_dispatch.h
new file mode 100644
index 0000000..844e417
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/g_set_mesa_ogles1_dispatch.h
@@ -0,0 +1,364 @@
+#ifndef __g_pvrogles1_set_mesa_dispatch_h_
+#define __g_pvrogles1_set_mesa_dispatch_h_
+
+typedef _glapi_proc (*pvrogles1GetProcAddress)(PVRDRIScreenImpl *psScreenImpl, const char *psProcName);
+
+static void
+pvrogles1_add_mesa_dispatch(struct _glapi_table *psTab, const char *psFunc, PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle, pvrogles1GetProcAddress pfGetProcAddress)
+{
+    int iOffset;
+    const char *asFunc[] = {NULL, NULL};
+    _glapi_proc pfFunc;
+    const char *error;
+
+    (void) dlerror();
+    pfFunc = dlsym(pvLibHandle, psFunc);
+    error = dlerror();
+    if (error != NULL)
+    {
+        pfFunc = pfGetProcAddress(psScreenImpl, psFunc);
+        if (pfFunc == NULL)
+        {
+#if 0
+            /*
+             * Not all extensions are supported, so there may be quite
+             * a lot of lookup failures.
+             */
+            _mesa_warning(NULL, "Couldn't get address of %s", psFunc);
+#endif
+            return;
+        }
+    }
+
+    asFunc[0] = psFunc;
+    iOffset = _glapi_add_dispatch(asFunc, "");
+    if (iOffset == -1)
+    {
+        _mesa_warning(NULL, "Couldn't add %s to the Mesa dispatch table", psFunc);
+    }
+    else
+    {
+        SET_by_offset(psTab, iOffset, pfFunc);
+    }
+}
+
+static void
+pvrogles1_set_mesa_dispatch(struct _glapi_table *psTab, PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle, pvrogles1GetProcAddress pfGetProcAddress)
+{
+    pvrogles1_add_mesa_dispatch(psTab, "glAlphaFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearColor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearDepthf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClipPlanef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glColor4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDepthRangef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFogf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFogfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFrustumf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetClipPlanef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetFloatv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetLightfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetMaterialfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexEnvfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightModelf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightModelfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLineWidth", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLoadMatrixf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMaterialf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMaterialfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultMatrixf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultiTexCoord4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glNormal3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glOrthof", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointParameterf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointSize", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPolygonOffset", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glRotatef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glScalef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnvf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnvfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameterf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTranslatef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glActiveTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glAlphaFuncx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBindBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBindTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBlendFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBufferData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBufferSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClear", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearColorx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearDepthx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearStencil", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClientActiveTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClipPlanex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glColor4ub", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glColor4x", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glColorMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glColorPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCompressedTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCompressedTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCopyTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCopyTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCullFace", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteTextures", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDepthFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDepthMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDepthRangex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDisable", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDisableClientState", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawElements", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glEnable", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glEnableClientState", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFinish", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFlush", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFogx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFogxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFrontFace", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFrustumx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetBooleanv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetBufferParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetClipPlanex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenTextures", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetError", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetFixedv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetIntegerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetLightxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetMaterialxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetPointerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetString", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexEnviv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexEnvxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexParameterxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glHint", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsEnabled", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightModelx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightModelxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLineWidthx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLoadIdentity", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLoadMatrixx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLogicOp", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMaterialx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMaterialxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMatrixMode", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultMatrixx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultiTexCoord4x", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glNormal3x", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glNormalPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glOrthox", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPixelStorei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointParameterx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointParameterxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointSizex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPolygonOffsetx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPopMatrix", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPushMatrix", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glReadPixels", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glRotatex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glSampleCoverage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glSampleCoveragex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glScalex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glScissor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glShadeModel", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glStencilFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glStencilMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glStencilOp", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexCoordPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnvi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnvx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnviv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnvxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameterx", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameterxv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTranslatex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glVertexPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glViewport", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointSizePointerOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBlendEquationSeparateOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBlendFuncSeparateOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBlendEquationOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexsOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexiOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexsvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexfOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDrawTexfvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glEGLImageTargetTexture2DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glEGLImageTargetRenderbufferStorageOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glAlphaFuncxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearColorxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearDepthxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClipPlanexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glColor4xOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDepthRangexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFogxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFogxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFrustumxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetClipPlanexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetFixedvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetLightxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetMaterialxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexEnvxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexParameterxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightModelxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightModelxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLightxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLineWidthxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLoadMatrixxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMaterialxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMaterialxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultMatrixxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultiTexCoord4xOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glNormal3xOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glOrthoxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointParameterxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointParameterxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPointSizexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glPolygonOffsetxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glRotatexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glSampleCoveragexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glScalexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnvxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexEnvxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameterxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexParameterxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTranslatexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsRenderbufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBindRenderbufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteRenderbuffersOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenRenderbuffersOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glRenderbufferStorageOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetRenderbufferParameterivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsFramebufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBindFramebufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteFramebuffersOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenFramebuffersOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCheckFramebufferStatusOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFramebufferRenderbufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFramebufferTexture2DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetFramebufferAttachmentParameterivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenerateMipmapOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMapBufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glUnmapBufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetBufferPointervOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCurrentPaletteMatrixOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glLoadPaletteFromModelViewMatrixOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMatrixIndexPointerOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glWeightPointerOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glQueryMatrixxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDepthRangefOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFrustumfOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glOrthofOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClipPlanefOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetClipPlanefOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClearDepthfOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexGenfOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexGenfvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexGeniOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexGenivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexGenxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexGenxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexGenfvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexGenivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetTexGenxvOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBindVertexArrayOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteVertexArraysOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenVertexArraysOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsVertexArrayOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glCopyTextureLevelsAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glResolveMultisampleFramebufferAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFenceSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClientWaitSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glWaitSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetInteger64vAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetSyncivAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDiscardFramebufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "*glMapBufferRangeEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFlushMappedBufferRangeEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFramebufferTexture2DMultisampleEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultiDrawArraysEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultiDrawElementsEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetGraphicsResetStatusEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glReadnPixelsEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetnUniformfvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetnUniformivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexStorage1DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexStorage2DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTexStorage3DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTextureStorage1DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTextureStorage2DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTextureStorage3DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClipPlanefIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glClipPlanexIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFramebufferTexture2DMultisampleIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteFencesNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenFencesNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glIsFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glTestFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetFenceivNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glFinishFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glSetFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetDriverControlsQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGetDriverControlStringQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glEnableDriverControlQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDisableDriverControlQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetTexturesQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetBuffersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetRenderbuffersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetFramebuffersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetTexLevelParameterivQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtTexObjectStateOverrideiQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetTexSubImageQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetBufferPointervQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetShadersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetProgramsQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtIsProgramBinaryQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glExtGetProgramBinarySourceQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glStartTilingQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glEndTilingQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultiDrawArraysEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glMultiDrawElementsEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glVertexAttrib4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramEnvParameter4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramEnvParameter4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramLocalParameter4fARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramLocalParameter4fvARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glVertexAttrib4xIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramLocalParameter4xIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramLocalParameter4xvIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramEnvParameter4xIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramEnvParameter4xvIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glVertexAttribPointerARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glEnableVertexAttribArrayARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDisableVertexAttribArrayARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glProgramStringARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glBindProgramARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glDeleteProgramsARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles1_add_mesa_dispatch(psTab, "glGenProgramsARB", psScreenImpl, pvLibHandle, pfGetProcAddress);
+}
+
+#endif /* __g_pvrogles1_set_mesa_dispatch_h_ */
diff --git a/src/mesa/drivers/dri/pvr/g_set_mesa_ogles2_dispatch.h b/src/mesa/drivers/dri/pvr/g_set_mesa_ogles2_dispatch.h
new file mode 100644
index 0000000..d15cc3d
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/g_set_mesa_ogles2_dispatch.h
@@ -0,0 +1,792 @@
+#ifndef __g_pvrogles2_set_mesa_dispatch_h_
+#define __g_pvrogles2_set_mesa_dispatch_h_
+
+typedef _glapi_proc (*pvrogles2GetProcAddress)(PVRDRIScreenImpl *psScreenImpl, const char *psProcName);
+
+static void
+pvrogles2_add_mesa_dispatch(struct _glapi_table *psTab, const char *psFunc, PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle, pvrogles2GetProcAddress pfGetProcAddress)
+{
+    int iOffset;
+    const char *asFunc[] = {NULL, NULL};
+    _glapi_proc pfFunc;
+    const char *error;
+
+    (void) dlerror();
+    pfFunc = dlsym(pvLibHandle, psFunc);
+    error = dlerror();
+    if (error != NULL)
+    {
+        pfFunc = pfGetProcAddress(psScreenImpl, psFunc);
+        if (pfFunc == NULL)
+        {
+#if 0
+            /*
+             * Not all extensions are supported, so there may be quite
+             * a lot of lookup failures.
+             */
+            _mesa_warning(NULL, "Couldn't get address of %s", psFunc);
+#endif
+            return;
+        }
+    }
+
+    asFunc[0] = psFunc;
+    iOffset = _glapi_add_dispatch(asFunc, "");
+    if (iOffset == -1)
+    {
+        _mesa_warning(NULL, "Couldn't add %s to the Mesa dispatch table", psFunc);
+    }
+    else
+    {
+        SET_by_offset(psTab, iOffset, pfFunc);
+    }
+}
+
+static void
+pvrogles2_set_mesa_dispatch(struct _glapi_table *psTab, PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle, pvrogles2GetProcAddress pfGetProcAddress)
+{
+    pvrogles2_add_mesa_dispatch(psTab, "glActiveTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glAttachShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindAttribLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindRenderbuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendColor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquationSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFuncSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBufferData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBufferSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCheckFramebufferStatus", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClear", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearColor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearDepthf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearStencil", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glColorMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCompileShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCompressedTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCompressedTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCreateProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCreateShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCullFace", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteFramebuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteRenderbuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteTextures", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDepthFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDepthMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDepthRangef", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDetachShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisable", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisableVertexAttribArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElements", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnable", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnableVertexAttribArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFinish", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFlush", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferRenderbuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTexture2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFrontFace", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenerateMipmap", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenFramebuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenRenderbuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenTextures", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetActiveAttrib", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetActiveUniform", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetAttachedShaders", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetAttribLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetBooleanv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetBufferParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetError", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFloatv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFramebufferAttachmentParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetIntegerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramInfoLog", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetRenderbufferParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetShaderiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetShaderInfoLog", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetShaderPrecisionFormat", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetShaderSource", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetString", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetUniformfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetUniformiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetUniformLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetVertexAttribfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetVertexAttribiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetVertexAttribPointerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glHint", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsEnabled", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsRenderbuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsShader", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glLineWidth", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glLinkProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPixelStorei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPolygonOffset", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReadPixels", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReleaseShaderCompiler", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRenderbufferStorage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSampleCoverage", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glScissor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glShaderBinary", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glShaderSource", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilFunc", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilFuncSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilMask", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilMaskSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilOp", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilOpSeparate", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexSubImage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform1i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform1iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUseProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glValidateProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttrib4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glViewport", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReadBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawRangeElements", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexSubImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyTexSubImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCompressedTexImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCompressedTexSubImage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenQueries", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteQueries", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsQuery", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBeginQuery", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEndQuery", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetQueryiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetQueryObjectuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUnmapBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetBufferPointerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawBuffers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix2x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix3x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix2x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix4x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix3x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix4x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlitFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTextureLayer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMapBufferRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFlushMappedBufferRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindVertexArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteVertexArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenVertexArrays", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsVertexArray", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetIntegeri_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBeginTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEndTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindBufferRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindBufferBase", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTransformFeedbackVaryings", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTransformFeedbackVarying", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribIPointer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetVertexAttribIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetVertexAttribIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribI4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribI4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribI4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribI4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetUniformuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFragDataLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform1ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform2ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform1uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform2uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniform4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearBufferiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearBufferuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearBufferfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearBufferfi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetStringi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyBufferSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetUniformIndices", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetActiveUniformsiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetUniformBlockIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetActiveUniformBlockiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetActiveUniformBlockName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformBlockBinding", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawArraysInstanced", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstanced", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFenceSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClientWaitSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glWaitSync", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetInteger64v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSynciv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetInteger64i_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetBufferParameteri64v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenSamplers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteSamplers", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsSampler", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindSampler", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterf", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribDivisor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteTransformFeedbacks", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenTransformFeedbacks", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPauseTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glResumeTransformFeedback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramBinary", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramBinary", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glInvalidateFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glInvalidateSubFramebuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage2D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage3D", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetInternalformativ", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDispatchCompute", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDispatchComputeIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawArraysIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsIndirect", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFramebufferParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramInterfaceiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramResourceIndex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramResourceName", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramResourceiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramResourceLocation", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUseProgramStages", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glActiveShaderProgram", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCreateShaderProgramv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindProgramPipeline", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteProgramPipelines", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenProgramPipelines", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsProgramPipeline", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramPipelineiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4i", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4ui", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4f", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4iv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4uiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x2fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x4fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x3fv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glValidateProgramPipeline", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramPipelineInfoLog", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindImageTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetBooleani_v", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMemoryBarrier", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMemoryBarrierByRegion", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage2DMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetMultisamplefv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSampleMaski", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexLevelParameteriv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexLevelParameterfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindVertexBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribFormat", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribIFormat", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribBinding", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexBindingDivisor", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendBarrier", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyImageSubData", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDebugMessageControl", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDebugMessageInsert", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDebugMessageCallback", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetDebugMessageLog", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPushDebugGroup", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPopDebugGroup", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glObjectLabel", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetObjectLabel", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glObjectPtrLabel", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetObjectPtrLabel", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPointerv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnablei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisablei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquationi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquationSeparatei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFunci", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFuncSeparatei", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glColorMaski", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsEnabledi", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsBaseVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawRangeElementsBaseVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseVertex", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTexture", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPrimitiveBoundingBox", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetGraphicsResetStatus", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReadnPixels", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformfv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMinSampleShading", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPatchParameteri", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameterIiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameterIuiv", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexBuffer", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexBufferRange", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage3DMultisample", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendBarrierKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDebugMessageControlKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDebugMessageInsertKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDebugMessageCallbackKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetDebugMessageLogKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPushDebugGroupKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPopDebugGroupKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glObjectLabelKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetObjectLabelKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glObjectPtrLabelKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetObjectPtrLabelKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPointervKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetGraphicsResetStatusKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReadnPixelsKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformfvKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformivKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformuivKHR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEGLImageTargetTexture2DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEGLImageTargetRenderbufferStorageOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyImageSubDataOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnableiOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisableiOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquationiOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquationSeparateiOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFunciOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFuncSeparateiOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glColorMaskiOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsEnablediOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsBaseVertexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawRangeElementsBaseVertexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseVertexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMultiDrawElementsBaseVertexOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTextureOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramBinaryOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramBinaryOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMapBufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUnmapBufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetBufferPointervOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPrimitiveBoundingBoxOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMinSampleShadingOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPatchParameteriOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexImage3DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexSubImage3DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyTexSubImage3DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCompressedTexImage3DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCompressedTexSubImage3DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTexture3DOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterIivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterIuivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameterIivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameterIuivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterIivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterIuivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameterIivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameterIuivOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexBufferOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexBufferRangeOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage3DMultisampleOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTextureViewOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindVertexArrayOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteVertexArraysOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenVertexArraysOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsVertexArrayOES", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfMonitorGroupsAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfMonitorCountersAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfMonitorGroupStringAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfMonitorCounterStringAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfMonitorCounterInfoAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenPerfMonitorsAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeletePerfMonitorsAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSelectPerfMonitorCountersAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBeginPerfMonitorAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEndPerfMonitorAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfMonitorCounterDataAMD", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlitFramebufferANGLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleANGLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawArraysInstancedANGLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedANGLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribDivisorANGLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTranslatedShaderSourceANGLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyTextureLevelsAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glResolveMultisampleFramebufferAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFenceSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClientWaitSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glWaitSyncAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetInteger64vAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSyncivAPPLE", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawArraysInstancedBaseInstanceEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseInstanceEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseVertexBaseInstanceEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindFragDataLocationIndexedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindFragDataLocationEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramResourceLocationIndexEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFragDataIndexEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBufferStorageEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyImageSubDataEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glLabelObjectEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetObjectLabelEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glInsertEventMarkerEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPushGroupMarkerEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPopGroupMarkerEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDiscardFramebufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenQueriesEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteQueriesEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsQueryEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBeginQueryEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEndQueryEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glQueryCounterEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetQueryivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetQueryObjectivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetQueryObjectuivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetQueryObjecti64vEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetQueryObjectui64vEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawBuffersEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnableiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisableiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquationiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendEquationSeparateiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFunciEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendFuncSeparateiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glColorMaskiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsEnablediEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsBaseVertexEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawRangeElementsBaseVertexEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedBaseVertexEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMultiDrawElementsBaseVertexEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawArraysInstancedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTextureEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribDivisorEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMapBufferRangeEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFlushMappedBufferRangeEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMultiDrawArraysEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMultiDrawElementsEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMultiDrawArraysIndirectEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMultiDrawElementsIndirectEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTexture2DMultisampleEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReadBufferIndexedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawBuffersIndexedEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetIntegeri_vEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPolygonOffsetClampEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPrimitiveBoundingBoxEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRasterSamplesEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetGraphicsResetStatusEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReadnPixelsEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformfvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetnUniformivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glActiveShaderProgramEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBindProgramPipelineEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCreateShaderProgramvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteProgramPipelinesEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenProgramPipelinesEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramPipelineInfoLogEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramPipelineivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsProgramPipelineEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramParameteriEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1fEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1iEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1ivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2fEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2iEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2ivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3fEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3iEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3ivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4fEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4iEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4ivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix2fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix3fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix4fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUseProgramStagesEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glValidateProgramPipelineEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1uiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2uiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3uiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4uiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform1uivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform2uivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform3uivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniform4uivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x3fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x2fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix2x4fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x2fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix3x4fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformMatrix4x3fvEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferPixelLocalStorageSizeEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFramebufferPixelLocalStorageSizeEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glClearPixelLocalStorageuiEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexPageCommitmentEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPatchParameteriEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterIivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexParameterIuivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameterIivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTexParameterIuivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterIivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSamplerParameterIuivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameterIivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetSamplerParameterIuivEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexBufferEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexBufferRangeEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage1DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage2DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTexStorage3DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTextureStorage1DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTextureStorage2DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTextureStorage3DEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTextureViewEXT", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTexture2DDownsampleIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTextureLayerDownsampleIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTexture2DMultisampleIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glApplyFramebufferAttachmentCMAAINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBeginPerfQueryINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCreatePerfQueryINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeletePerfQueryINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEndPerfQueryINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFirstPerfQueryIdINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetNextPerfQueryIdINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfCounterInfoINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfQueryDataINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfQueryIdByNameINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPerfQueryInfoINTEL", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTextureHandleNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetTextureSamplerHandleNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMakeTextureHandleResidentNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMakeTextureHandleNonResidentNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetImageHandleNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMakeImageHandleResidentNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMakeImageHandleNonResidentNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformHandleui64NV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformHandleui64vNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformHandleui64NV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramUniformHandleui64vNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsTextureHandleResidentNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsImageHandleResidentNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendParameteriNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlendBarrierNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBeginConditionalRenderNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEndConditionalRenderNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSubpixelPrecisionBiasNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyBufferSubDataNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverageMaskNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverageOperationNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawBuffersNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawArraysInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDrawElementsInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeleteFencesNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenFencesNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTestFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFenceivNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFinishFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glSetFenceNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFragmentCoverageColorNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glBlitFramebufferNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverageModulationTableNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetCoverageModulationTableNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverageModulationNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glRenderbufferStorageMultisampleNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glVertexAttribDivisorNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetInternalformatSampleivNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix2x3fvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix3x2fvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix2x4fvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix4x2fvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix3x4fvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glUniformMatrix4x3fvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGenPathsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDeletePathsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathCommandsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathCoordsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathSubCommandsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathSubCoordsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathStringNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathGlyphsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathGlyphRangeNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glWeightPathsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCopyPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glInterpolatePathsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glTransformPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathParameterivNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathParameteriNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathParameterfvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathParameterfNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathDashArrayNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathStencilFuncNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathStencilDepthOffsetNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilFillPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilStrokePathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilFillPathInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilStrokePathInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathCoverDepthFuncNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverFillPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverStrokePathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverFillPathInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glCoverStrokePathInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathParameterivNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathParameterfvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathCommandsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathCoordsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathDashArrayNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathMetricsNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathMetricRangeNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathSpacingNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsPointInFillPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsPointInStrokePathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetPathLengthNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPointAlongPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMatrixLoad3x2fNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMatrixLoad3x3fNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMatrixLoadTranspose3x3fNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMatrixMult3x2fNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMatrixMult3x3fNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glMatrixMultTranspose3x3fNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilThenCoverFillPathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilThenCoverStrokePathNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilThenCoverFillPathInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStencilThenCoverStrokePathInstancedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathGlyphIndexRangeNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathGlyphIndexArrayNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPathMemoryGlyphIndexArrayNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glProgramPathFragmentInputGenNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetProgramResourcefvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glPolygonModeNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glReadBufferNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferSampleLocationsfvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glNamedFramebufferSampleLocationsfvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glResolveDepthValuesNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glViewportArrayvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glViewportIndexedfNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glViewportIndexedfvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glScissorArrayvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glScissorIndexedNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glScissorIndexedvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDepthRangeArrayfvNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDepthRangeIndexedfNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFloati_vNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnableiNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisableiNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsEnablediNV", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glViewportArrayvIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glViewportIndexedfIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glViewportIndexedfvIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glScissorArrayvIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glScissorIndexedIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glScissorIndexedvIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDepthRangeArrayfvIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDepthRangeIndexedfIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetFloati_vIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnableiIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisableiIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glIsEnablediIMG", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTextureMultiviewOVR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glFramebufferTextureMultisampleMultiviewOVR", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glAlphaFuncQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetDriverControlsQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glGetDriverControlStringQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEnableDriverControlQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glDisableDriverControlQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetTexturesQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetBuffersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetRenderbuffersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetFramebuffersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetTexLevelParameterivQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtTexObjectStateOverrideiQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetTexSubImageQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetBufferPointervQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetShadersQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetProgramsQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtIsProgramBinaryQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glExtGetProgramBinarySourceQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glStartTilingQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+    pvrogles2_add_mesa_dispatch(psTab, "glEndTilingQCOM", psScreenImpl, pvLibHandle, pfGetProcAddress);
+}
+
+#endif /* __g_pvrogles2_set_mesa_dispatch_h_ */
diff --git a/src/mesa/drivers/dri/pvr/imgpixfmts.h b/src/mesa/drivers/dri/pvr/imgpixfmts.h
new file mode 100644
index 0000000..ff5625e
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/imgpixfmts.h
@@ -0,0 +1,68 @@
+/*************************************************************************/ /*!
+@File           imgpixfmts_km.h
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+/*****************************************************************************
+ **
+ ** WARNING: This file is autogenerated - DO NOT EDIT.
+ **
+ *****************************************************************************/
+
+#if !defined(_IMGPIXFMTS_KM_H_)
+#define _IMGPIXFMTS_KM_H_
+
+#include "imgyuv.h"
+
+
+typedef enum _IMG_PIXFMT_
+{
+	IMG_PIXFMT_UNKNOWN = 0,
+	IMG_PIXFMT_R8G8B8A8_UNORM = 31,
+	IMG_PIXFMT_R8G8B8X8_UNORM = 36,
+	IMG_PIXFMT_R8G8_UNORM = 61,
+	IMG_PIXFMT_R8_UNORM = 75,
+	IMG_PIXFMT_B5G6R5_UNORM = 84,
+	IMG_PIXFMT_B5G5R5A1_UNORM = 85,
+	IMG_PIXFMT_B5G5R5X1_UNORM = 86,
+	IMG_PIXFMT_B8G8R8A8_UNORM = 87,
+	IMG_PIXFMT_B8G8R8X8_UNORM = 88,
+	IMG_PIXFMT_B4G4R4A4_UNORM = 143,
+	IMG_PIXFMT_UYVY = 169,
+	IMG_PIXFMT_VYUY = 170,
+	IMG_PIXFMT_YUYV = 171,
+	IMG_PIXFMT_YVYU = 172,
+	IMG_PIXFMT_YVU420_2PLANE = 173,
+	IMG_PIXFMT_YUV420_2PLANE = 174,
+	IMG_PIXFMT_YVU420_2PLANE_MACRO_BLOCK = 175,
+	IMG_PIXFMT_YUV420_3PLANE = 176,
+	IMG_PIXFMT_YVU420_3PLANE = 177,
+	IMG_PIXFMT_V8U8Y8A8 = 182,
+	IMG_PIXFMT_YVU8_420_2PLANE_PACK8_P = 243,
+	IMG_PIXFMT_YUV8_420_2PLANE_PACK8_P = 247,
+	IMG_PIXFMT_UYVY10_422_1PLANE_PACK10_CUST1 = 250,
+	IMG_PIXFMT_R5G6B5_UNORM = 252,
+}	IMG_PIXFMT;
+
+#endif /* _IMGPIXFMTS_KM_H_ */
diff --git a/src/mesa/drivers/dri/pvr/imgyuv.h b/src/mesa/drivers/dri/pvr/imgyuv.h
new file mode 100644
index 0000000..a91ee10
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/imgyuv.h
@@ -0,0 +1,58 @@
+/*************************************************************************/ /*!
+@File
+@Title          YUV defines
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(_IMGYUV_H_)
+#define _IMGYUV_H_
+
+typedef enum
+{
+	IMG_COLORSPACE_UNDEFINED = 0,
+	IMG_COLORSPACE_BT601_CONFORMANT_RANGE = 1,
+	IMG_COLORSPACE_BT601_FULL_RANGE = 2,
+	IMG_COLORSPACE_BT709_CONFORMANT_RANGE = 3,
+	IMG_COLORSPACE_BT709_FULL_RANGE = 4,
+	IMG_COLORSPACE_BT2020_CONFORMANT_RANGE = 5,
+	IMG_COLORSPACE_BT2020_FULL_RANGE = 6,
+	IMG_COLORSPACE_BT601_CONFORMANT_RANGE_INVERSE = 7,
+	IMG_COLORSPACE_BT601_FULL_RANGE_INVERSE = 8,
+	IMG_COLORSPACE_BT709_CONFORMANT_RANGE_INVERSE = 9,
+	IMG_COLORSPACE_BT709_FULL_RANGE_INVERSE = 10,
+	IMG_COLORSPACE_BT2020_CONFORMANT_RANGE_INVERSE = 11,
+	IMG_COLORSPACE_BT2020_FULL_RANGE_INVERSE = 12
+} IMG_YUV_COLORSPACE;
+
+typedef enum
+{
+	IMG_CHROMA_INTERP_UNDEFINED = 0,
+	IMG_CHROMA_INTERP_ZERO = 1,
+	IMG_CHROMA_INTERP_QUARTER = 2,
+	IMG_CHROMA_INTERP_HALF = 3,
+	IMG_CHROMA_INTERP_THREEQUARTERS = 4
+} IMG_YUV_CHROMA_INTERP;
+
+
+#endif /* _IMGYUV_H_ */
diff --git a/src/mesa/drivers/dri/pvr/mesa_context.c b/src/mesa/drivers/dri/pvr/mesa_context.c
new file mode 100644
index 0000000..8f84d56
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/mesa_context.c
@@ -0,0 +1,230 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/**
+ * \file context.c
+ * Mesa context/visual/framebuffer management functions.
+ * \author Brian Paul
+ */
+
+/*
+ * Mesa 3-D graphics library
+ * Version:  7.1
+ *
+ * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*
+ * This file is based on Mesa-7.2/src/mesa/main/context.c.
+ */
+
+/* NOTE:
+ * Since our DRI driver is actually a complete OpenGL library, our dispatch
+ * table handling is non-standard; we take complete control of the table.
+ * The autogenerated pvrogl_set_mesa_dispatch function, in
+ * g_set_mesa_dispatch.h, used to set dispatch table entries using the
+ * various SET_ macros defined by Mesa. Unfortunately, those macros don't
+ * have the desired effect if IN_DRI_DRIVER is defined (which it is
+ * here). To make the macros work as desired, this file used to undefine
+ * IN_DRI_DRIVER, which was rather ugly, and a potential source of bugs.
+ * The SET_ macros are no longer used (the _glapi_add_dispatch function is
+ * used instead) so IN_DRI_DRIVER no longer needs to be undefined.
+ */
+
+#include <stdlib.h>
+#include <dlfcn.h>
+
+#include "main/version.h"
+
+#include "imports.h"
+#include "dri_util.h"
+#include "glapi.h"
+#include "dispatch.h"
+#include "pvrmesa.h"
+
+#include "pvr_dri_support.h"
+
+#include "compiler/glsl/glsl_parser_extras.h"
+
+#include "g_set_mesa_ogl_dispatch.h"
+#include "g_set_mesa_ogles1_dispatch.h"
+#include "g_set_mesa_ogles2_dispatch.h"
+
+/**
+ * This is the default function we plug into all dispatch table slots
+ * This helps prevents a segfault when someone calls a GL function without
+ * first checking if the extension is supported.
+ */
+static int
+generic_nop(void)
+{
+   _mesa_warning(NULL, "User called no-op dispatch function (an unsupported extension function?)");
+   return 0;
+}
+
+/**
+ * Allocate and initialize a new dispatch table.
+ */
+static _glapi_proc *
+pvrdri_alloc_dispatch_table(void)
+{
+   GLint numEntries = _glapi_get_dispatch_table_size();
+   _glapi_proc *table =
+      (_glapi_proc*) malloc(numEntries * sizeof(_glapi_proc));
+   if (table) {
+      GLint i;
+      for (i = 0; i < numEntries; i++) {
+         table[i] = (_glapi_proc) generic_nop;
+      }
+   }
+   return table;
+}
+
+/**
+ * Free a dispatch table.
+ */
+void
+pvrdri_free_dispatch_tables(PVRDRIScreen *psPVRScreen)
+{
+	if (psPVRScreen->psPVROGLDispatch != NULL)
+	{
+		free(psPVRScreen->psPVROGLDispatch);
+		psPVRScreen->psPVROGLDispatch = NULL;
+	}
+
+	if (psPVRScreen->psOGLES1Dispatch != NULL)
+	{
+		free(psPVRScreen->psOGLES1Dispatch);
+		psPVRScreen->psOGLES1Dispatch = NULL;
+	}
+
+	if (psPVRScreen->psOGLES2Dispatch != NULL)
+	{
+		free(psPVRScreen->psOGLES2Dispatch);
+		psPVRScreen->psOGLES2Dispatch = NULL;
+	}
+
+}
+
+static _glapi_proc
+pvrdri_get_proc_address_ogl(PVRDRIScreenImpl *psScreenImpl, const char *psProcName)
+{
+	return (_glapi_proc)PVRDRIEGLGetProcAddressOGL(psScreenImpl, psProcName);
+}
+
+static _glapi_proc
+pvrdri_get_proc_address_ogles1(PVRDRIScreenImpl *psScreenImpl, const char *psProcName)
+{
+	return (_glapi_proc)PVRDRIEGLGetProcAddressOGLES1(psScreenImpl, psProcName);
+}
+
+static _glapi_proc
+pvrdri_get_proc_address_ogles2(PVRDRIScreenImpl *psScreenImpl, const char *psProcName)
+{
+	return (_glapi_proc)PVRDRIEGLGetProcAddressOGLES2(psScreenImpl, psProcName);
+}
+
+GLboolean
+pvrdri_create_dispatch_table(PVRDRIScreen *psPVRScreen, pvrdri_api_type eAPI)
+{
+	PVRDRIScreenImpl *psScreenImpl = psPVRScreen->psImpl;
+	_glapi_proc **ppsTable;
+	void *pvLibHandle;
+
+	switch (eAPI)
+	{
+		case PVRDRI_API_GL:
+			ppsTable = &psPVRScreen->psPVROGLDispatch;
+			pvLibHandle = psPVRScreen->pvLibHandleOGL;
+			break;
+		case PVRDRI_API_GLES1:
+			ppsTable = &psPVRScreen->psOGLES1Dispatch;
+			pvLibHandle = psPVRScreen->pvLibHandleOGLES1;
+			break;
+		case PVRDRI_API_GLES2:
+			ppsTable = &psPVRScreen->psOGLES2Dispatch;
+			pvLibHandle = psPVRScreen->pvLibHandleOGLES2;
+			break;
+		default:
+			return GL_FALSE;
+	}
+
+	if (!pvLibHandle)
+	{
+		return GL_FALSE;
+	}
+
+	if (*ppsTable != NULL)
+	{
+		return GL_TRUE;
+	}
+
+	*ppsTable = pvrdri_alloc_dispatch_table();
+	if (*ppsTable == NULL)
+	{
+		return GL_FALSE;
+	}
+
+	switch (eAPI)
+	{
+		case PVRDRI_API_GL:
+			pvrogl_set_mesa_dispatch((struct _glapi_table *)*ppsTable, psScreenImpl, pvLibHandle, pvrdri_get_proc_address_ogl);
+			break;
+		case PVRDRI_API_GLES1:
+			pvrogles1_set_mesa_dispatch((struct _glapi_table *)*ppsTable, psScreenImpl, pvLibHandle, pvrdri_get_proc_address_ogles1);
+			break;
+		case PVRDRI_API_GLES2:
+			pvrogles2_set_mesa_dispatch((struct _glapi_table *)*ppsTable, psScreenImpl, pvLibHandle, pvrdri_get_proc_address_ogles2);
+			break;
+		default:
+			break;
+	}
+
+	return GL_TRUE;
+}
+
+void
+pvrdri_set_null_dispatch_table(void)
+{
+	_glapi_set_dispatch(NULL);
+}
+
+void
+pvrdri_set_dispatch_table(PVRDRIContext *psPVRContext)
+{
+	_glapi_proc *psTable = NULL;
+
+	switch (psPVRContext->eAPI)
+	{
+		case PVRDRI_API_GL:
+			psTable = psPVRContext->psPVRScreen->psPVROGLDispatch;
+			break;
+		case PVRDRI_API_GLES1:
+			psTable = psPVRContext->psPVRScreen->psOGLES1Dispatch;
+			break;
+		case PVRDRI_API_GLES2:
+			psTable = psPVRContext->psPVRScreen->psOGLES2Dispatch;
+			break;
+		default:
+			break;
+	}
+
+	_glapi_set_dispatch((struct _glapi_table *)psTable);
+}
diff --git a/src/mesa/drivers/dri/pvr/pvr_dri_support.h b/src/mesa/drivers/dri/pvr/pvr_dri_support.h
new file mode 100644
index 0000000..fb26b12
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvr_dri_support.h
@@ -0,0 +1,349 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          PVR DRI interface definition
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVRDRIIFCE_H__)
+#define __PVRDRIIFCE_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "imgpixfmts.h"
+
+#if !defined(ARRAY_SIZE)
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+#endif
+
+typedef enum
+{
+	PVRDRI_DEVICE_TYPE_INVALID = 0,
+	PVRDRI_DEVICE_TYPE_UNKNOWN,
+	PVRDRI_DEVICE_TYPE_DISPLAY,
+	PVRDRI_DEVICE_TYPE_RENDER,
+} PVRDRIDeviceType;
+
+typedef enum
+{
+	PVRDRI_API_GL,
+	PVRDRI_API_GLES1,
+	PVRDRI_API_GLES2
+} pvrdri_api_type;
+
+typedef enum
+{
+	PVRDRI_IMAGE = 1,
+	PVRDRI_IMAGE_FROM_NAMES,
+	PVRDRI_IMAGE_FROM_EGLIMAGE,
+	PVRDRI_IMAGE_FROM_DMABUFS,
+} PVRDRIImageType;
+
+typedef enum
+{
+	PVRDRI_IMAGE_ERROR_SUCCESS,
+	PVRDRI_IMAGE_ERROR_BAD_PARAMETER,
+	PVRDRI_IMAGE_ERROR_BAD_MATCH,
+	PVRDRI_IMAGE_ERROR_BAD_ALLOC,
+	PVRDRI_IMAGE_ERROR_BAD_ACCESS,
+} PVRDRIImageError;
+
+/* The buffer flags should match the __DRI_IMAGE_USE_* flags */
+#define PVDRI_BUFFER_USE_SHARE		0x0001
+#define PVDRI_BUFFER_USE_SCANOUT	0x0002
+#define PVDRI_BUFFER_USE_CURSOR		0x0004
+#define PVDRI_BUFFER_USE_LINEAR		0x0008
+
+typedef struct 
+{
+	IMG_PIXFMT          ePixFormat;
+	uint32_t            uiWidth;
+	uint32_t            uiHeight;
+	uint32_t            uiStrideInBytes;
+} PVRDRIBufferAttribs;
+
+typedef struct
+{
+	int sampleBuffers;
+	int samples;
+
+	int redBits;
+	int greenBits;
+	int blueBits;
+	int alphaBits;
+
+	int rgbBits;
+	int depthBits;
+	int stencilBits;
+
+	bool doubleBufferMode;
+
+	int bindToTextureRgb;
+	int bindToTextureRgba;
+} PVRDRIConfigInfo;
+
+typedef struct EGLImageRec _EGLImage;
+typedef struct __DRIimageRec __DRIimage;
+
+/* PVRDRI interface opaque types */
+typedef struct PVRDRIScreenImplRec PVRDRIScreenImpl;
+typedef struct PVRDRIContextImplRec PVRDRIContextImpl;
+typedef struct PVRDRIDrawableImplRec PVRDRIDrawableImpl;
+typedef struct PVRDRIBufferImplRec PVRDRIBufferImpl;
+typedef struct PVRSRV_CLIENT_SYNC_PRIM PVRSRV_CLIENT_SYNC_PRIM;
+
+typedef struct PVRDRIDrawable_TAG PVRDRIDrawable;
+
+typedef struct _SyncCommand_ SyncCommand;
+
+PVRDRIDeviceType PVRDRIGetDeviceTypeFromFd(int iFd);
+
+bool PVRScreenGlobalInit(void);
+void PVRScreenGlobalDeinit(void);
+
+uint32_t PVRScreenCountInc(void);
+uint32_t PVRScreenCountDec(void);
+
+uint32_t PVRDRIPixFmtGetDepth(IMG_PIXFMT eFmt);
+uint32_t PVRDRIPixFmtGetBPP(IMG_PIXFMT eFmt);
+uint32_t PVRDRIPixFmtGetBlockSize(IMG_PIXFMT eFmt);
+
+/* ScreenImpl functions */
+PVRDRIScreenImpl *PVRDRICreateScreenImpl(int iFd);
+void PVRDRIDestroyScreenImpl(PVRDRIScreenImpl *psScreenImpl);
+bool PVRDRIScreenImplInitRenderContext(PVRDRIScreenImpl *psScreenImpl, uint32_t uiPriority);
+
+/* EGL function table functions */
+bool PVRDRIEGLGetPVROGLFunctionTable(PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle);
+bool PVRDRIEGLGetOGLES2FunctionTable(PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle);
+bool PVRDRIEGLGetOGLES1FunctionTable(PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle);
+bool PVRDRIEGLGetOCLFunctionTable(PVRDRIScreenImpl *psScreenImpl, void *pvLibHandle);
+
+typedef void (*pvrdri_glapi_proc)(void);
+pvrdri_glapi_proc PVRDRIEGLGetProcAddressOGL(PVRDRIScreenImpl *psScreenImpl, const char *psProcName);
+pvrdri_glapi_proc PVRDRIEGLGetProcAddressOGLES1(PVRDRIScreenImpl *psScreenImpl, const char *psProcName);
+pvrdri_glapi_proc PVRDRIEGLGetProcAddressOGLES2(PVRDRIScreenImpl *psScreenImpl, const char *psProcName);
+
+bool PVRDRIEGLFlushBuffers(pvrdri_api_type eAPI,
+                           PVRDRIScreenImpl *psScreenImpl,
+                           PVRDRIContextImpl *psContextImpl,
+                           PVRDRIDrawableImpl *psDrawableImpl,
+                           bool bFlushAllSurfaces,
+                           bool bSwapBuffers,
+                           bool bWaitForHW);
+bool PVRDRIEGLFreeResources(PVRDRIScreenImpl *psPVRScreenImpl);
+void PVRDRIEGLMarkRendersurfaceInvalid(pvrdri_api_type eAPI,
+                                       PVRDRIScreenImpl *psScreenImpl,
+                                       PVRDRIContextImpl *psContextImpl);
+void PVRDRIEGLSetOGLFrontBufferCallback(pvrdri_api_type eAPI,
+                                        PVRDRIScreenImpl *psScreenImpl,
+                                        PVRDRIDrawableImpl *psDrawableImpl,
+                                        void (*pfnCallback)(PVRDRIDrawable *));
+
+
+bool
+PVRDRICreateGC(pvrdri_api_type eAPI,
+               PVRDRIScreenImpl *psScreenImpl,
+               PVRDRIContextImpl *psContextImpl,
+               PVRDRIContextImpl *psSharedContextImpl);
+bool
+PVRDRIDestroyGC(pvrdri_api_type eAPI,
+                PVRDRIScreenImpl *psScreenImpl,
+                PVRDRIContextImpl *psContextImpl);
+bool
+PVRDRIMakeCurrentGC(pvrdri_api_type eAPI,
+                    PVRDRIScreenImpl *psScreenImpl,
+                    PVRDRIContextImpl *psContextImpl,
+                    PVRDRIDrawableImpl *psWriteImpl,
+                    PVRDRIDrawableImpl *psReadImpl);
+void
+PVRDRIMakeUnCurrentGC(pvrdri_api_type eAPI,
+                      PVRDRIScreenImpl *psScreenImpl);
+
+PVRDRIImageError
+PVRDRIGetImageSource(pvrdri_api_type eAPI,
+                     PVRDRIScreenImpl *psScreenImpl,
+                     PVRDRIContextImpl *psContextImpl,
+                     uint32_t  uiTarget,
+                     uintptr_t uiBuffer,
+                     uint32_t  uiLevel,
+                     _EGLImage *psEGLImage);
+
+PVRDRIImageError
+PVRDRIGetImageSourceOCL(PVRDRIScreenImpl *psScreenImpl,
+                        uint32_t uiTarget,
+                        void *pBuffer,
+                        _EGLImage *psEGLImage);
+
+bool
+PVRDRI2BindTexImage(pvrdri_api_type eAPI,
+                    PVRDRIScreenImpl *psScreenImpl,
+                    PVRDRIContextImpl *psContextImpl,
+                    PVRDRIDrawableImpl *psDrawableImpl);
+
+void
+PVRDRI2ReleaseTexImage(pvrdri_api_type eAPI,
+                       PVRDRIScreenImpl *psScreenImpl,
+                       PVRDRIContextImpl *psContextImpl,
+                       PVRDRIDrawableImpl *psDrawableImpl);
+
+/* ContextImpl functions */
+PVRDRIContextImpl *PVRDRICreateContextImpl(unsigned uMajorVersion,
+                                           unsigned uMinorVersion,
+                                           bool     bIsRobustContext,
+                                           bool     bNotifyReset);
+void PVRDRIDestroyContextImpl(PVRDRIContextImpl *psContextImpl);
+void PVRDRIContextImplSetVersion(PVRDRIContextImpl *psContextImpl,
+                                 unsigned uMajorVersion,
+                                 unsigned uMinorVersion);
+/* DrawableImpl functions */
+PVRDRIDrawableImpl *PVRDRICreateDrawableImpl(PVRDRIDrawable *psPVRDrawable);
+void PVRDRIDestroyDrawableImpl(PVRDRIDrawableImpl *psScreenImpl);
+bool PVREGLDrawableCreate(PVRDRIScreenImpl *psScreenImpl,
+                          PVRDRIDrawableImpl *psDrawableImpl);
+bool PVREGLDrawableRecreate(PVRDRIScreenImpl *psScreenImpl,
+                            PVRDRIDrawableImpl *psDrawableImpl);
+bool PVREGLDrawableDestroy(PVRDRIScreenImpl *psScreenImpl,
+                           PVRDRIDrawableImpl *psDrawableImpl);
+void PVREGLDrawableDestroyConfig(PVRDRIDrawableImpl *psDrawableImpl);
+
+/* Buffer functions */
+PVRDRIBufferImpl *PVRDRIBufferCreate(PVRDRIScreenImpl *psScreenImpl,
+				     int iWidth,
+				     int iHeight,
+				     unsigned int uiBpp,
+				     unsigned int uiUseFlags,
+				     unsigned int *puiStride);
+
+PVRDRIBufferImpl *PVRDRIBufferCreateFromName(PVRDRIScreenImpl *psScreenImpl,
+					     int iName,
+					     int iWidth,
+					     int iHeight,
+					     unsigned int uiStride,
+					     unsigned int uiOffset);
+
+PVRDRIBufferImpl *PVRDRIBufferCreateFromFd(PVRDRIScreenImpl *psScreenImpl,
+					   int iFd,
+					   int iWidth,
+					   int iHeight,
+					   unsigned int uiStride,
+					   unsigned int uiOffset);
+
+void PVRDRIBufferDestroy(PVRDRIBufferImpl *psBuffer);
+
+int PVRDRIBufferGetFd(PVRDRIBufferImpl *psBuffer);
+
+int PVRDRIBufferGetHandle(PVRDRIBufferImpl *psBuffer);
+
+int PVRDRIBufferGetName(PVRDRIBufferImpl *psBuffer);
+
+
+/* Image functions */
+_EGLImage *PVRDRIEGLImageCreate(void);
+_EGLImage *PVRDRIEGLImageCreateFromBuffers(int iWidth,
+					   int iHeight,
+					   int iStride,
+					   IMG_PIXFMT ePixelFormat,
+					   IMG_YUV_COLORSPACE eColourSpace,
+					   IMG_YUV_CHROMA_INTERP eChromaUInterp,
+					   IMG_YUV_CHROMA_INTERP eChromaVInterp,
+					   PVRDRIBufferImpl **apsBuffers,
+					   int iNumBuffers);
+_EGLImage *PVRDRIEGLImageDup(_EGLImage *psIn);
+
+void PVRDRIEGLImageSetCallbackData(_EGLImage *psEGLImage, __DRIimage *image);
+
+void PVRDRIEGLImageDestroyExternal(PVRDRIScreenImpl *psScreenImpl,
+                                   _EGLImage *psEGLImage);
+void PVRDRIEGLImageFree(_EGLImage *psEGLImage);
+
+void PVRDRIEGLImageGetAttribs(_EGLImage *psEGLImage, PVRDRIBufferAttribs *psAttribs);
+
+/* Sync functions */
+bool PVRDRISyncPrimAlloc(PVRDRIScreenImpl *psScreenImpl,
+                         PVRSRV_CLIENT_SYNC_PRIM **psEGLSyncSyncPrim);
+
+void PVRDRISyncPrimDelete(PVRDRIScreenImpl *psScreenImpl,
+                          PVRSRV_CLIENT_SYNC_PRIM *psEGLSyncSyncPrim,
+                          SyncCommand *psSyncCommand);
+
+bool PVRDRIInsertClientFence(pvrdri_api_type eAPI,
+                             PVRDRIContextImpl *psContextImpl,
+                             PVRDRIScreenImpl *psScreenImpl,
+                             PVRSRV_CLIENT_SYNC_PRIM *psEGLSyncSyncPrim,
+                             SyncCommand **ppsSyncCommand);
+
+bool PVRDRIInsertServerFence(pvrdri_api_type eAPI,
+                             PVRDRIContextImpl *psContextImpl,
+                             PVRDRIScreenImpl *psScreenImpl,
+                             SyncCommand *psSyncCommand);
+
+bool PVRDRIIsFenceSyncComplete(PVRSRV_CLIENT_SYNC_PRIM *psEGLSyncSyncPrim);
+
+bool PVRDRIEventObjectWait(PVRDRIScreenImpl *psScreenImpl,
+                           PVRSRV_CLIENT_SYNC_PRIM *psEGLSyncSyncPrim,
+                           bool with_timeout,
+                           uint64_t timeout_ns);
+
+/* EGL/OGL interface functions */
+void
+InitialiseEGLModeInfo(PVRDRIContextImpl *psContextImpl,
+                      const uint32_t uFlags,
+                      const uint32_t uiPriority);
+void
+SetEGLModeInfoFromGLMode(PVRDRIContextImpl *psContextImpl,
+                         PVRDRIConfigInfo *psConfigInfo);
+bool
+PVRDRIEGLDrawableConfigFromGLMode(PVRDRIDrawableImpl *psPVRDrawable,
+                                  PVRDRIConfigInfo *psConfigInfo,
+                                  int supportedAPIs,
+                                  IMG_PIXFMT ePixFmt);
+
+/* Callbacks into non-impl layer */
+typedef struct
+{
+	bool                 (*DrawableCreate)(PVRDRIDrawable *psPVRDrawable);
+	bool                 (*DrawableRecreate)(PVRDRIDrawable *psPVRDrawable);
+	PVRDRIBufferImpl    *(*DrawableGetDstBuffer)(PVRDRIDrawable *psPVRDrawable);
+	PVRDRIBufferImpl    *(*DrawableGetAccumBuffer)(PVRDRIDrawable *psPVRDrawable);
+	bool                 (*DrawableGetParameters)(PVRDRIDrawable *psPVRDrawable,
+	                                              PVRDRIBufferImpl **psDstBuffer,
+	                                              PVRDRIBufferImpl **psAccumBuffer,
+	                                              PVRDRIBufferAttribs *psAttribs,
+	                                              bool *pbDoubleBuffered);
+
+	PVRDRIImageType      (*ImageGetSharedType)(__DRIimage *image);
+	PVRDRIBufferImpl    *(*ImageGetSharedBuffer)(__DRIimage *image);
+	_EGLImage           *(*ImageGetSharedEGLImage)(__DRIimage *image);
+	_EGLImage           *(*ImageGetEGLImage)(__DRIimage *image);
+	__DRIimage          *(*ScreenGetDRIImage)(void *hEGLImage);
+	void                 (*RefImage)(__DRIimage *image);
+	void                 (*UnrefImage)(__DRIimage *image);
+} PVRDRICallbacks;
+
+void PVRDRIRegisterCallbacks(PVRDRICallbacks *callbacks);
+
+#endif /* defined(__PVRDRIIFCE_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvr_mesa_version.h b/src/mesa/drivers/dri/pvr/pvr_mesa_version.h
new file mode 100644
index 0000000..4da617e
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvr_mesa_version.h
@@ -0,0 +1,39 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File           pvr_mesa_version.h
+@Title          Replacement Mesa version macros
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVR_MESA_VERSION_H__)
+#define __PVR_MESA_VERSION_H__
+
+#include <main/version.h>
+
+#if !defined(MESA_VERSION)
+#define	MESA_VERSION(x, y, z) (((((x) * 256) + (y)) * 256) + (z))
+#endif
+
+#endif /* defined(__PVR_MESA_VERSION_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvr_object_cache.c b/src/mesa/drivers/dri/pvr/pvr_object_cache.c
new file mode 100644
index 0000000..0ce43e3
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvr_object_cache.c
@@ -0,0 +1,311 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File           pvr_object_cache.c
+@Title          Cache for objects.
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include <stdlib.h>
+#include <search.h>
+
+#include "pvrqueue.h"
+#include "pvr_object_cache.h"
+
+#define	FOR_QELEM_QOBJ(psCache, psQElem, psObj)				\
+	for ((psQElem) = (psCache)->sQHead.pvForw;			\
+	     (psQElem) != &(psCache)->sQHead &&				\
+		     ((psObj) = PVRQ_CONTAINER_OF((psQElem),		\
+						  struct PVRCachedObject, sQElem))->bValid; \
+	     (psQElem) = (psQElem)->pvForw)
+
+struct PVRCachedObject
+{
+	PVRQElem sQElem;
+
+	void *pvObjectData;
+
+	bool bValid;
+	unsigned uAge;
+};
+
+struct _PVRObjectCache
+{
+	/* LRU queue of objects in cache */
+	PVRQHead sQHead;
+
+	unsigned uNumObj;
+	unsigned uMaxAge;
+
+	void *pvCreateData;
+
+	PVRObjectCacheInsertCB pfnInsertCB;
+	PVRObjectCachePurgeCB pfnPurgeCB;
+	PVRObjectCacheCompareCB pfnCompareCB;
+};
+
+static inline void
+PVRQueueRemove(struct PVRCachedObject *psObj)
+{
+	remque(&psObj->sQElem);
+}
+
+static inline void
+PVRQueueAddFront(struct _PVRObjectCache *psCache, struct PVRCachedObject *psObj)
+{
+	insque(&psObj->sQElem, &psCache->sQHead);
+}
+
+static inline void
+PVRQueueAddBack(struct _PVRObjectCache *psCache, struct PVRCachedObject *psObj)
+{
+	insque(&psObj->sQElem, psCache->sQHead.pvBack);
+}
+
+static inline bool
+PVRObjectInsert(struct _PVRObjectCache *psCache,
+		struct PVRCachedObject *psObj,
+		void *pvInsertData)
+{
+	psObj->pvObjectData = psCache->pfnInsertCB(psCache->pvCreateData,
+						  pvInsertData);
+
+	return (psObj->pvObjectData != NULL);
+}
+
+static inline void
+PVRObjectPurge(struct _PVRObjectCache *psCache,
+	       struct PVRCachedObject *psObj,
+	       bool bRetired)
+{
+	if (psCache->pfnPurgeCB != NULL)
+	{
+		psCache->pfnPurgeCB(psCache->pvCreateData,
+				    psObj->pvObjectData,
+				    bRetired);
+	}
+}
+
+static inline bool
+PVRObjectInCache(struct _PVRObjectCache *psCache,
+		 struct PVRCachedObject *psObj,
+		 void *pvInsertData)
+{
+	if (psCache->pfnCompareCB != NULL)
+	{
+		return psCache->pfnCompareCB(psCache->pvCreateData,
+					     psObj->pvObjectData,
+					     pvInsertData);
+	}
+
+	return false;
+}
+
+IMG_INTERNAL void
+PVRObjectCachePurge(PVRObjectCache hObjectCache)
+{
+	struct _PVRObjectCache *psCache = (struct _PVRObjectCache *)hObjectCache;
+	PVRQElem *psQElem;
+	struct PVRCachedObject *psObj;
+
+	FOR_QELEM_QOBJ(psCache, psQElem, psObj)
+	{
+		PVRObjectPurge(psCache, psObj, false);
+
+		psObj->bValid = false;
+	}
+}
+
+
+IMG_INTERNAL bool
+PVRObjectCacheInsert(PVRObjectCache hObjectCache,
+		     void *pvInsertData)
+{
+	struct _PVRObjectCache *psCache = (struct _PVRObjectCache *)hObjectCache;
+	struct PVRCachedObject *psObj;
+	bool bInserted = false;
+	PVRQElem *psQElem;
+
+	/* Is the object already in the cache ? */
+	FOR_QELEM_QOBJ(psCache, psQElem, psObj)
+	{
+		/* Cache hit? */
+		if (PVRObjectInCache(psCache, psObj, pvInsertData))
+		{
+			/* The old object purge will bump the age to 1 */
+			psObj->uAge = 0;
+			bInserted = true;
+
+			/* Move the object to the front of the queue */
+			PVRQueueRemove(psObj);
+			PVRQueueAddFront(psCache, psObj);
+
+			break;
+		}
+	}
+
+	/* Purge old objects */
+	FOR_QELEM_QOBJ(psCache, psQElem, psObj)
+	{
+		/* Age the object */
+		psObj->uAge++;
+
+		/* Has the object been in the cache too long? */
+		if (psCache->uMaxAge != 0 && psObj->uAge > psCache->uMaxAge)
+		{
+			PVRObjectPurge(psCache, psObj, true);
+
+			psObj->bValid = false;
+
+			/* Move the object to the back of the queue */
+			PVRQueueRemove(psObj);
+			PVRQueueAddBack(psCache, psObj);
+		}
+	}
+
+	/*
+	 * If the object wasn't added to the cache above, add it using the
+	 * last entry in the queue.
+	 */
+	if (!bInserted)
+	{
+		PVRQElem *psQElem = psCache->sQHead.pvBack;
+		struct PVRCachedObject *psObj = PVRQ_CONTAINER_OF(psQElem,
+								  struct PVRCachedObject,
+								  sQElem);
+
+		if (psObj->bValid)
+		{
+			PVRObjectPurge(psCache, psObj, true);
+
+			psObj->bValid = false;
+		}
+
+		psObj->uAge = 1;
+
+		if (PVRObjectInsert(psCache, psObj, pvInsertData))
+		{
+			psObj->bValid = true;
+
+			/* Move the object to the front of the queue */
+			PVRQueueRemove(psObj);
+			PVRQueueAddFront(psCache, psObj);
+
+			bInserted = true;
+		}
+	}
+
+	return bInserted;
+}
+
+IMG_INTERNAL void *
+PVRObjectCacheGetObject(PVRObjectCache hObjectCache, unsigned uObj)
+{
+	struct _PVRObjectCache *psCache = (struct _PVRObjectCache *)hObjectCache;
+	unsigned uCount = uObj;
+	PVRQElem *psQElem;
+	struct PVRCachedObject *psObj;
+
+	FOR_QELEM_QOBJ(psCache, psQElem, psObj)
+	{
+		if ((uCount--) == 0)
+		{
+			return psObj->pvObjectData;
+		}
+	}
+
+	return NULL;
+}
+
+IMG_INTERNAL void
+PVRObjectCacheDestroy(PVRObjectCache hObjectCache)
+{
+	struct _PVRObjectCache *psCache = (struct _PVRObjectCache *)hObjectCache;
+
+	PVRObjectCachePurge(psCache);
+
+	while (psCache->sQHead.pvForw != &psCache->sQHead)
+	{
+		struct PVRCachedObject *psObj = PVRQ_CONTAINER_OF(psCache->sQHead.pvForw,
+								  struct PVRCachedObject,
+								  sQElem);
+
+		PVRQueueRemove(psObj);
+		free(psObj);
+	}
+
+	free(psCache);
+}
+
+IMG_INTERNAL PVRObjectCache
+PVRObjectCacheCreate(unsigned uNumObj,
+		     unsigned uMaxAge,
+		     void *pvCreateData,
+		     PVRObjectCacheInsertCB pfnInsertCB,
+		     PVRObjectCachePurgeCB pfnPurgeCB,
+		     PVRObjectCacheCompareCB pfnCompareCB)
+{
+	struct _PVRObjectCache *psCache;
+	unsigned i;
+
+	if (uNumObj == 0 || pfnInsertCB == NULL)
+	{
+		return NULL;
+	}
+
+	psCache = calloc(1, sizeof(*psCache));
+	if (psCache == NULL)
+	{
+		return NULL;
+	}
+
+	psCache->uNumObj = uNumObj;
+	psCache->uMaxAge = uMaxAge;
+	psCache->pvCreateData = pvCreateData;
+	psCache->pfnInsertCB = pfnInsertCB;
+	psCache->pfnPurgeCB = pfnPurgeCB;
+	psCache->pfnCompareCB = pfnCompareCB;
+
+	INITIALISE_PVRQ_HEAD(&psCache->sQHead);
+
+	for (i = 0; i < uNumObj; i++)
+	{
+		struct PVRCachedObject *psObj;
+
+		psObj = calloc(1, sizeof(*psObj));
+		if (psObj == NULL)
+		{
+			goto ExitError;
+		}
+
+		PVRQueueAddBack(psCache, psObj);
+	}
+
+	return psCache;
+
+ExitError:
+	PVRObjectCacheDestroy(psCache);
+
+	return NULL;
+}
diff --git a/src/mesa/drivers/dri/pvr/pvr_object_cache.h b/src/mesa/drivers/dri/pvr/pvr_object_cache.h
new file mode 100644
index 0000000..6aaa361
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvr_object_cache.h
@@ -0,0 +1,137 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File           pvr_object_cache.h
+@Title          Cache for objects.
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVR_OBJECT_CACHE_H__)
+#define __PVR_OBJECT_CACHE_H__
+
+#include "stdbool.h"
+#ifndef IMG_INTERNAL
+#define IMG_INTERNAL	__attribute__((visibility("hidden")))
+#endif
+
+typedef struct _PVRObjectCache *PVRObjectCache;
+
+/* Cache insert callback. Returns object data on success or NULL otherwise. */
+typedef void *(*PVRObjectCacheInsertCB)(void *pvCreateData,
+					void *pvInsertData);
+
+/*
+ * Cache purge callback. The object data is the data returned by the insert
+ * callback. The bRetired flag indicates an object has been retired due to
+ * age, or lack of space in the cache, rather than an explicit purge.
+ */
+typedef void (*PVRObjectCachePurgeCB)(void *pvCreateData,
+				      void *pvObjectData,
+				      bool bRetired);
+/*
+ * Cache compare callback. The object data is the data returned by the insert
+ * callback.
+ */
+typedef bool (*PVRObjectCacheCompareCB)(void *pvCreateData,
+                                        void *pvObjectData,
+                                        void *pvInsertData);
+
+
+/**************************************************************************/ /*!
+@Function       PVRObjectCacheCreate
+@Description    Creates an object cache.
+@Input          uNumObj             The maximum number of objects that can be
+                                    stored in the cache.
+@Input          uMaxAge             The maximum age of an object before it gets
+                                    purged from the cache. If 0 then age related
+                                    purging is disabled.
+@Input          pvCreateData        Optional data to be passed to the provided
+                                    callback functions.
+@Input          pfnInsertCB         Callback used when data is inserted into
+                                    the cache.
+@Input          pfnPurgeCB          Optional callback used when an object is
+                                    purged from the cache.
+@Input          pfnCompareCB        Optional callback used when inserting a new
+                                    object into the cache to determine whether
+                                    or not the object already exists within the
+                                    cache.
+@Return         PVRObjectCache      Returns a handle to the newly created object
+                                    cache on success or NULL otherwise.
+*/ /***************************************************************************/
+IMG_INTERNAL PVRObjectCache PVRObjectCacheCreate(unsigned uNumObj,
+						 unsigned uMaxAge,
+						 void *pvCreateData,
+						 PVRObjectCacheInsertCB pfnInsertCB,
+						 PVRObjectCachePurgeCB pfnPurgeCB,
+						 PVRObjectCacheCompareCB pfnCompareCB);
+
+/**************************************************************************/ /*!
+@Function       PVRObjectCacheInsert
+@Description    Insert an object into the cache, giving it a starting age of
+                one. If the object was already contained within the cache then
+                the insert callback will not be called and the existing cache
+                object will have its age reset to one. All other objects in the
+                cache will have their age increased by one. This may result in
+                an object being purged from the cache if its age exceeds the
+                maximum age specified when creating the cache or the cache is
+                already full.
+@Input          hObjectCache        Handle to an object cache.
+@Input          pvInsertData        Data passed to the insert callback.
+@Return         IMG_BOOL            Returns IMG_TRUE on success or IMG_FALSE
+                                    otherwise.
+*/ /***************************************************************************/
+IMG_INTERNAL bool PVRObjectCacheInsert(PVRObjectCache hObjectCache,
+                                       void *pvInsertData);
+
+/**************************************************************************/ /*!
+@Function       PVRObjectCacheGetObject
+@Description    Returns object data from the cache based on the given object
+                number, whereby the youngest object corresponds to zero.
+@Input          hObjectCache        Handle to an object cache.
+@Input          uObj                Number of the object to return.
+@Return         void *              Returns object data (as returned by the
+                                    insert callback) on success or NULL
+                                    otherwise.
+*/ /***************************************************************************/
+IMG_INTERNAL void *PVRObjectCacheGetObject(PVRObjectCache hObjectCache,
+					   unsigned uObj);
+
+/**************************************************************************/ /*!
+@Function       PVRObjectCachePurge
+@Description    Purges the given cache of all objects.
+@Input          hObjectCache        Handle to an object cache.
+@Return         void
+*/ /***************************************************************************/
+IMG_INTERNAL void PVRObjectCachePurge(PVRObjectCache hObjectCache);
+
+/**************************************************************************/ /*!
+@Function       PVRObjectCacheDestroy
+@Description    Destroy the given object cache, purging all remaining objects
+                in the cache.
+@Input          hObjectCache        Handle to an object cache.
+@Return         void
+*/ /***************************************************************************/
+IMG_INTERNAL void PVRObjectCacheDestroy(PVRObjectCache hObjectCache);
+
+#endif /* defined(__PVR_OBJECT_CACHE_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvrdrawable.c b/src/mesa/drivers/dri/pvr/pvrdrawable.c
new file mode 100644
index 0000000..1806aea
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrdrawable.c
@@ -0,0 +1,743 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          PVR DRI Surface/Drawable code
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include <assert.h>
+
+#include "dri_util.h"
+
+#include "pvrdri.h"
+#include "pvrimage.h"
+
+static PVRDRIBufferImpl *PVRGetBackingBuffer(PVRDRIBuffer *psPVRBuffer)
+{
+	if (psPVRBuffer)
+	{
+		switch (psPVRBuffer->eBackingType)
+		{
+			case PVRDRI_BUFFER_BACKING_DRI2:
+				return psPVRBuffer->uBacking.sDRI2.psBuffer;
+			case PVRDRI_BUFFER_BACKING_IMAGE:
+				return PVRDRIImageGetSharedBuffer(psPVRBuffer->uBacking.sImage.psImage);
+			default:
+				assert(0);
+				return NULL;
+		}
+	}
+
+	return NULL;
+}
+
+static inline void PVRDRIMarkAllRenderSurfacesAsInvalid(PVRDRIDrawable *psPVRDrawable)
+{
+	PVRQElem *psQElem = psPVRDrawable->sPVRContextHead.pvForw;
+
+	while (psQElem != &psPVRDrawable->sPVRContextHead)
+	{
+		PVRDRIContext *psPVRContext = PVRQ_CONTAINER_OF(psQElem, PVRDRIContext, sQElem);
+		PVRDRIEGLMarkRendersurfaceInvalid(psPVRContext->eAPI,
+		                                  psPVRContext->psPVRScreen->psImpl,
+		                                  psPVRContext->psImpl);
+		psQElem = psPVRContext->sQElem.pvForw;
+	}
+
+	/* No need to flush surfaces evicted from the cache */
+	INITIALISE_PVRQ_HEAD(&psPVRDrawable->sCacheFlushHead);
+}
+
+/*************************************************************************/ /*!
+ PVR drawable local functions (image driver loader)
+*/ /**************************************************************************/
+
+/*************************************************************************/ /*!
+ Function Name		: PVRImageDrawableGetNativeInfo
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Update native drawable information.
+*/ /**************************************************************************/
+static bool PVRImageDrawableGetNativeInfo(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	__DRIscreen *psDRIScreen = psPVRDrawable->psPVRScreen->psDRIScreen;
+	struct __DRIimageList sImages;
+	uint32_t uiBufferMask;
+	const PVRDRIImageFormat *psFormat;
+
+	assert(psDRIScreen->image.loader != NULL);
+	assert(psDRIScreen->image.loader->getBuffers);
+
+	psFormat = PVRDRIIMGPixelFormatToImageFormat(psPVRDrawable->ePixelFormat);
+	if (!psFormat)
+	{
+		errorMessage("%s: Unsupported format (format = %u)\n",
+			     __func__, psPVRDrawable->ePixelFormat);
+		return false;
+	}
+
+	uiBufferMask = psPVRDrawable->bDoubleBuffered ?
+					__DRI_IMAGE_BUFFER_BACK :
+					__DRI_IMAGE_BUFFER_FRONT;
+
+	if (!psDRIScreen->image.loader->getBuffers(psDRIDrawable,
+						   psFormat->iDRIFormat,
+						   NULL,
+						   psDRIDrawable->loaderPrivate,
+						   uiBufferMask,
+						   &sImages))
+	{
+		errorMessage("%s: Image get buffers call failed\n", __func__);
+		return false;
+	}
+
+	psPVRDrawable->uDRI.sImage.psDRI =
+		(sImages.image_mask & __DRI_IMAGE_BUFFER_BACK) ?
+			sImages.back : sImages.front;
+
+	return true;
+}
+
+/*************************************************************************/ /*!
+ Function Name		: PVRImageDrawableCreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Create drawable
+*/ /**************************************************************************/
+static bool PVRImageDrawableCreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	uint32_t uBytesPerPixel;
+	PVRDRIBufferAttribs sBufferAttribs;
+
+	if (!PVRImageDrawableGetNativeInfo(psPVRDrawable))
+	{
+		return false;
+	}
+
+	PVRDRIEGLImageGetAttribs(
+		PVRDRIImageGetEGLImage(psPVRDrawable->uDRI.sImage.psDRI),
+					&sBufferAttribs);
+	uBytesPerPixel = PVRDRIPixFmtGetBlockSize(sBufferAttribs.ePixFormat);
+
+	psDRIDrawable->w = sBufferAttribs.uiWidth;
+	psDRIDrawable->h = sBufferAttribs.uiHeight;
+	psPVRDrawable->uStride = sBufferAttribs.uiStrideInBytes;
+	psPVRDrawable->uBytesPerPixel = uBytesPerPixel;
+
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache,
+					psPVRDrawable->uDRI.sImage.psDRI))
+	{
+		errorMessage("%s: Couldn't insert buffer into cache\n", __func__);
+		return false;
+	}
+
+	if (!PVREGLDrawableCreate(psPVRDrawable->psPVRScreen->psImpl,
+				  psPVRDrawable->psImpl))
+	{
+		errorMessage("%s: Couldn't create EGL drawable\n", __func__);
+		return false;
+	}
+
+	return true;
+}
+
+/*************************************************************************/ /*!
+ Function Name		: PVRImageDrawableRecreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Recreate drawable, if necessary.
+*/ /**************************************************************************/
+static bool PVRImageDrawableRecreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	PVRDRIBuffer *psPVRBuffer;
+	uint32_t uBytesPerPixel;
+	PVRDRIBufferAttribs sBufferAttribs;
+	bool bRecreate;
+
+	psPVRBuffer = (psPVRDrawable->bDoubleBuffered) ? NULL :
+			PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+
+	PVRDRIEGLImageGetAttribs(
+		PVRDRIImageGetEGLImage(psPVRDrawable->uDRI.sImage.psDRI),
+					&sBufferAttribs);
+	uBytesPerPixel = PVRDRIPixFmtGetBlockSize(sBufferAttribs.ePixFormat);
+
+	bRecreate = (psPVRBuffer &&
+			psPVRBuffer->uBacking.sImage.psImage !=
+				psPVRDrawable->uDRI.sImage.psDRI) ||
+			(psDRIDrawable->w != sBufferAttribs.uiWidth) ||
+			(psDRIDrawable->h != sBufferAttribs.uiHeight) ||
+			(psPVRDrawable->uStride !=
+				sBufferAttribs.uiStrideInBytes) ||
+			(psPVRDrawable->uBytesPerPixel != uBytesPerPixel);
+
+	if (bRecreate)
+	{
+		PVRDRIMarkAllRenderSurfacesAsInvalid(psPVRDrawable);
+
+		psDRIDrawable->w = sBufferAttribs.uiWidth;
+		psDRIDrawable->h = sBufferAttribs.uiHeight;
+		psPVRDrawable->uStride = sBufferAttribs.uiStrideInBytes;
+		psPVRDrawable->uBytesPerPixel = uBytesPerPixel;
+	}
+
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache,
+					psPVRDrawable->uDRI.sImage.psDRI))
+	{
+		errorMessage("%s: Couldn't insert buffer into cache\n", __func__);
+		return false;
+	}
+
+	if (bRecreate)
+	{
+		if (!PVREGLDrawableRecreate(psPVRDrawable->psPVRScreen->psImpl,
+		                            psPVRDrawable->psImpl))
+		{
+			errorMessage("%s: Couldn't recreate EGL drawable\n", __func__);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static void *PVRImageObjectCacheInsert(void *pvCreateData, void *pvInsertData)
+{
+	__DRIimage *psImage = pvInsertData;
+	PVRDRIBuffer *psPVRBuffer;
+	(void)pvCreateData;
+
+	assert(PVRDRIImageGetSharedBuffer(psImage) != NULL);
+
+	psPVRBuffer = calloc(1, sizeof(*psPVRBuffer));
+	if (psPVRBuffer == NULL)
+	{
+		errorMessage("%s: Failed to create PVR DRI buffer", __func__);
+		return NULL;
+	}
+
+	psPVRBuffer->eBackingType = PVRDRI_BUFFER_BACKING_IMAGE;
+	psPVRBuffer->uBacking.sImage.psImage = psImage;
+
+	/* As a precaution, take a reference on the image so it doesn't disappear unexpectedly */
+	PVRDRIRefImage(psImage);
+
+	return psPVRBuffer;
+}
+
+static void PVRImageObjectCachePurge(void *pvCreateData,
+                                     void *pvObjectData,
+                                     bool bRetired)
+{
+	PVRDRIDrawable *psPVRDrawable = pvCreateData;
+	PVRDRIBuffer *psPVRBuffer = pvObjectData;
+
+	if (bRetired)
+	{
+		/*
+		 * Delay flush until later, as it may not be safe
+		 * to do the flush within GetDrawableInfo.
+		 */
+		PVRQQueue(&psPVRDrawable->sCacheFlushHead, &psPVRBuffer->sCacheFlushElem);
+	}
+	else
+	{
+		PVRDRIUnrefImage(psPVRBuffer->uBacking.sImage.psImage);
+		free(psPVRBuffer);
+	}
+}
+
+static bool PVRImageObjectCacheCompare(void *pvCreateData,
+                                       void *pvObjectData,
+                                       void *pvInsertData)
+{
+	__DRIimage *psImage = pvInsertData;
+	PVRDRIBuffer *psPVRBuffer = pvObjectData;
+	(void)pvCreateData;
+
+	return psPVRBuffer->uBacking.sImage.psImage == psImage;
+}
+
+
+/*************************************************************************/ /*!
+ PVR drawable local functions (DRI2 loader)
+*/ /**************************************************************************/
+
+/***********************************************************************************
+ Function Name		: PVRDRI2DrawableGetNativeInfo
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Update native drawable information.
+************************************************************************************/
+static bool PVRDRI2DrawableGetNativeInfo(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	__DRIscreen *psDRIScreen = psPVRDrawable->psPVRScreen->psDRIScreen;
+	unsigned int auiAttachmentReq[2];
+	__DRIbuffer *psDRIBuffers;
+	int iBufCount;
+	int i;
+	int w, h;
+
+	assert(psDRIScreen->dri2.loader);
+	assert(psDRIScreen->dri2.loader->getBuffersWithFormat);
+
+	if (psPVRDrawable->bDoubleBuffered)
+	{
+		auiAttachmentReq[0] = __DRI_BUFFER_BACK_LEFT;
+	}
+	else
+	{
+		auiAttachmentReq[0] = __DRI_BUFFER_FRONT_LEFT;
+	}
+
+	auiAttachmentReq[1] = PVRDRIPixFmtGetDepth(psPVRDrawable->ePixelFormat);
+
+	/* Do not free psDRIBuffers when finished with it */
+	psDRIBuffers = psDRIScreen->dri2.loader->getBuffersWithFormat(psDRIDrawable,
+								      &w,
+								      &h,
+								      &auiAttachmentReq[0],
+								      1,
+								      &iBufCount,
+								      psDRIDrawable->loaderPrivate);
+	if (psDRIBuffers == NULL)
+	{
+		errorMessage("%s: DRI2 get buffers call failed\n", __func__);
+		return false;
+	}
+
+	for (i = 0; i < iBufCount; i++)
+	{
+		if (psDRIBuffers[i].attachment == auiAttachmentReq[0] ||
+		    (psDRIBuffers[i].attachment == __DRI_BUFFER_FAKE_FRONT_LEFT &&
+		     auiAttachmentReq[0] == __DRI_BUFFER_FRONT_LEFT))
+		{
+			break;
+		}
+	}
+
+	if (i == iBufCount)
+	{
+		errorMessage("%s: Couldn't get DRI buffer information\n", __func__);
+		return false;
+	}
+
+	psPVRDrawable->uDRI.sBuffer.sDRI = psDRIBuffers[i];
+	psPVRDrawable->uDRI.sBuffer.w = w;
+	psPVRDrawable->uDRI.sBuffer.h = h;
+
+	return true;
+}
+
+/***********************************************************************************
+ Function Name		: PVRDRI2DrawableCreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Create drawable.
+************************************************************************************/
+static bool PVRDRI2DrawableCreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+
+	if (!PVRDRI2DrawableGetNativeInfo(psPVRDrawable))
+	{
+		return false;
+	}
+
+	psDRIDrawable->w = psPVRDrawable->uDRI.sBuffer.w;
+	psDRIDrawable->h = psPVRDrawable->uDRI.sBuffer.h;
+	psPVRDrawable->uStride = psPVRDrawable->uDRI.sBuffer.sDRI.pitch;
+	psPVRDrawable->uBytesPerPixel = psPVRDrawable->uDRI.sBuffer.sDRI.cpp;
+
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache, &psPVRDrawable->uDRI.sBuffer.sDRI))
+	{
+		errorMessage("%s: Couldn't insert buffer into cache\n", __func__);
+		return false;
+	}
+
+	if (!PVREGLDrawableCreate(psPVRDrawable->psPVRScreen->psImpl,
+				  psPVRDrawable->psImpl))
+	{
+		errorMessage("%s: Couldn't create EGL drawable\n", __func__);
+		return false;
+	}
+
+	return true;
+}
+
+/***********************************************************************************
+ Function Name		: PVRDRI2DrawableRecreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Recreate a drawable, if necessary.
+************************************************************************************/
+static bool PVRDRI2DrawableRecreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	PVRDRIBuffer *psPVRBuffer;
+	bool bRecreate;
+
+	/*
+	 * If we're single buffered, check the name of the first buffer
+	 * in the cache (there should only be one) against the new name of
+	 * the new DRI buffer. Otherwise don't, as the name will change as
+	 * part of swap buffers.
+	 */
+	psPVRBuffer = (psPVRDrawable->bDoubleBuffered) ? NULL :
+			PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+
+
+	bRecreate = (psPVRBuffer &&
+			psPVRBuffer->uBacking.sDRI2.uiName !=
+				psPVRDrawable->uDRI.sBuffer.sDRI.name) ||
+		(psDRIDrawable->w != psPVRDrawable->uDRI.sBuffer.w) ||
+		(psDRIDrawable->h != psPVRDrawable->uDRI.sBuffer.h) ||
+		(psPVRDrawable->uStride !=
+			psPVRDrawable->uDRI.sBuffer.sDRI.pitch) ||
+		(psPVRDrawable->uBytesPerPixel !=
+			psPVRDrawable->uDRI.sBuffer.sDRI.cpp);
+
+	if (bRecreate)
+	{
+		PVRDRIMarkAllRenderSurfacesAsInvalid(psPVRDrawable);
+		PVRObjectCachePurge(psPVRDrawable->hBufferCache);
+
+		psDRIDrawable->w = psPVRDrawable->uDRI.sBuffer.w;
+		psDRIDrawable->h = psPVRDrawable->uDRI.sBuffer.h;
+		psPVRDrawable->uStride =
+			psPVRDrawable->uDRI.sBuffer.sDRI.pitch;
+		psPVRDrawable->uBytesPerPixel =
+			psPVRDrawable->uDRI.sBuffer.sDRI.cpp;
+	}
+
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache,
+					&psPVRDrawable->uDRI.sBuffer.sDRI))
+	{
+		errorMessage("%s: Couldn't insert buffer into cache\n",
+								__func__);
+		return false;
+	}
+
+	if (bRecreate)
+	{
+		if (!PVREGLDrawableRecreate(psPVRDrawable->psPVRScreen->psImpl,
+		                            psPVRDrawable->psImpl))
+		{
+			errorMessage("%s: Couldn't recreate EGL drawable\n",
+								__func__);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static void *PVRDRI2ObjectCacheInsert(void *pvCreateData, void *pvInsertData)
+{
+	PVRDRIDrawable *psPVRDrawable = pvCreateData;
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	PVRDRIScreen *psPVRScreen = psPVRDrawable->psPVRScreen;
+	PVRDRIBuffer *psPVRBuffer;
+	__DRIbuffer *psDRIBuffer = pvInsertData;
+
+	if (PVRDRIPixFmtGetBlockSize(psPVRDrawable->ePixelFormat) != psDRIBuffer->cpp)
+	{
+		errorMessage("%s: DRI buffer format doesn't match drawable format\n", __func__);
+		return NULL;
+	}
+
+	psPVRBuffer = calloc(1, sizeof(*psPVRBuffer));
+	if (psPVRBuffer == NULL)
+	{
+		errorMessage("%s: Failed to create PVR DRI buffer", __func__);
+		return NULL;
+	}
+
+	psPVRBuffer->eBackingType = PVRDRI_BUFFER_BACKING_DRI2;
+	psPVRBuffer->uBacking.sDRI2.uiName = psDRIBuffer->name;
+	psPVRBuffer->uBacking.sDRI2.psBuffer =
+		PVRDRIBufferCreateFromName(psPVRScreen->psImpl,
+					   psDRIBuffer->name,
+					   psDRIDrawable->w,
+					   psDRIDrawable->h,
+					   psDRIBuffer->pitch,
+					   0);
+	if (!psPVRBuffer->uBacking.sDRI2.psBuffer)
+	{
+		free(psPVRBuffer);																					
+		return NULL;
+	}
+
+	return psPVRBuffer;
+}
+
+static void PVRDRI2ObjectCachePurge(void *pvCreateData,
+                                    void *pvObjectData,
+                                    bool bRetired)
+{
+	PVRDRIDrawable *psPVRDrawable = pvCreateData;
+	PVRDRIBuffer *psPVRBuffer = pvObjectData;
+
+	if (bRetired)
+	{
+		/*
+		 * Delay flush until later, as it may not be safe
+		 * to do the flush within GetDrawableInfo.
+		 */
+		PVRQQueue(&psPVRDrawable->sCacheFlushHead, &psPVRBuffer->sCacheFlushElem);
+	}
+	else
+	{
+		PVRDRIBufferDestroy(psPVRBuffer->uBacking.sDRI2.psBuffer);
+		free(psPVRBuffer);
+	}
+}
+
+static bool PVRDRI2ObjectCacheCompare(void *pvCreateData,
+                                      void *pvObjectData,
+                                      void *pvInsertData)
+{
+	__DRIbuffer *psDRIBuffer = pvInsertData;
+	PVRDRIBuffer *psPVRBuffer = pvObjectData;
+	(void)pvCreateData;
+
+	return psDRIBuffer->name == psPVRBuffer->uBacking.sDRI2.uiName;
+}
+
+
+/*************************************************************************/ /*!
+ PVR drawable local functions
+*/ /**************************************************************************/
+
+/***********************************************************************************
+ Function Name		: PVRDRIDrawableUpdateNativeInfo
+ Inputs			: psPVRDrawable
+ Description		: Update native drawable information.
+************************************************************************************/
+bool PVRDRIDrawableUpdateNativeInfo(PVRDRIDrawable *psPVRDrawable)
+{
+	return (psPVRDrawable->psPVRScreen->psDRIScreen->image.loader) ?
+			PVRImageDrawableGetNativeInfo(psPVRDrawable) :
+			PVRDRI2DrawableGetNativeInfo(psPVRDrawable);
+}
+
+/*************************************************************************/ /*!
+ Function Name	: PVRDRIDrawableCreate
+ Inputs		: psPVRDrawable
+ Description	: Create drawable
+*/ /**************************************************************************/
+bool PVRDRIDrawableRecreate(PVRDRIDrawable *psPVRDrawable)
+{
+	bool bRes;
+
+	PVRDRIDrawableLock(psPVRDrawable);
+
+	if (psPVRDrawable->psPVRScreen->bUseInvalidate)
+	{
+		if (!psPVRDrawable->bDrawableInfoInvalid)
+		{
+			PVRDRIDrawableUnlock(psPVRDrawable);
+			return true;
+		}
+	}
+
+	if (!psPVRDrawable->bDrawableInfoUpdated)
+	{
+		if (!PVRDRIDrawableUpdateNativeInfo(psPVRDrawable))
+		{
+			PVRDRIDrawableUnlock(psPVRDrawable);
+			return false;
+		}
+	}
+
+	if (psPVRDrawable->psPVRScreen->psDRIScreen->image.loader)
+	{
+		bRes = PVRImageDrawableRecreate(psPVRDrawable);
+	}
+	else
+	{
+		bRes = PVRDRI2DrawableRecreate(psPVRDrawable);
+	}
+
+	if (bRes)
+	{
+		psPVRDrawable->bDrawableInfoUpdated = false;
+		psPVRDrawable->bDrawableInfoInvalid = false;
+	}
+
+	PVRDRIDrawableUnlock(psPVRDrawable);
+
+	return bRes;
+}
+
+/*************************************************************************/ /*!
+ Function Name	: PVRDRIDrawableCreate
+ Inputs		: psPVRDrawable
+ Description	: Create drawable
+*/ /**************************************************************************/
+bool PVRDRIDrawableCreate(PVRDRIDrawable *psPVRDrawable)
+{
+	bool bRes;
+
+	if (psPVRDrawable->psPVRScreen->psDRIScreen->image.loader)
+	{
+		bRes = PVRImageDrawableCreate(psPVRDrawable);
+	}
+	else
+	{
+		bRes = PVRDRI2DrawableCreate(psPVRDrawable);
+	}
+
+	return bRes;
+}
+
+/*************************************************************************/ /*!
+ PVR drawable interface
+*/ /**************************************************************************/
+bool PVRDRIDrawableInit(PVRDRIDrawable *psPVRDrawable)
+{
+	unsigned uNumBufs = psPVRDrawable->bDoubleBuffered ? DRI2_BUFFERS_MAX : 1;
+	PVRObjectCacheInsertCB pfnInsert;
+	PVRObjectCachePurgeCB pfnPurge;
+	PVRObjectCacheCompareCB pfnCompare;
+
+	if (psPVRDrawable->bInitialised)
+	{
+		return true;
+	}
+
+	if (psPVRDrawable->psPVRScreen->psDRIScreen->image.loader)
+	{
+		pfnInsert = PVRImageObjectCacheInsert;
+		pfnPurge = PVRImageObjectCachePurge;
+		pfnCompare = PVRImageObjectCacheCompare;
+	}
+	else
+	{
+		assert(psPVRDrawable->psPVRScreen->psDRIScreen->dri2.loader);
+
+		pfnInsert = PVRDRI2ObjectCacheInsert;
+		pfnPurge = PVRDRI2ObjectCachePurge;
+		pfnCompare = PVRDRI2ObjectCacheCompare;
+	}
+
+	psPVRDrawable->hBufferCache = PVRObjectCacheCreate(uNumBufs,
+	                                                   uNumBufs,
+	                                                   psPVRDrawable,
+	                                                   pfnInsert,
+	                                                   pfnPurge,
+	                                                   pfnCompare);
+	if (psPVRDrawable->hBufferCache == NULL)
+	{
+		errorMessage("%s: Failed to create buffer cache\n", __func__);
+		return false;
+	}
+
+	if (!PVRDRIDrawableCreate(psPVRDrawable))
+	{
+		PVRObjectCacheDestroy(psPVRDrawable->hBufferCache);
+		psPVRDrawable->hBufferCache = NULL;
+
+		return false;
+	}
+
+	psPVRDrawable->bInitialised = true;
+
+	return true;
+}
+
+void PVRDRIDrawableDeinit(PVRDRIDrawable *psPVRDrawable)
+{
+	(void) PVREGLDrawableDestroy(psPVRDrawable->psPVRScreen->psImpl,
+	                             psPVRDrawable->psImpl);
+
+	if (psPVRDrawable->hBufferCache != NULL)
+	{
+		PVRObjectCacheDestroy(psPVRDrawable->hBufferCache);
+		psPVRDrawable->hBufferCache = NULL;
+	}
+
+	psPVRDrawable->bInitialised = false;
+}
+
+PVRDRIBufferImpl *PVRDRIDrawableGetDstBuffer(PVRDRIDrawable *psPVRDrawable)
+{
+	PVRDRIBuffer *psBuffer = PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+
+	return PVRGetBackingBuffer(psBuffer);
+}
+
+PVRDRIBufferImpl *PVRDRIDrawableGetAccumBuffer(PVRDRIDrawable *psPVRDrawable)
+{
+	PVRDRIBuffer *psBuffer;
+
+	psBuffer = PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 1);
+	if (!psBuffer)
+	{
+		psBuffer = PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+	}
+
+	return PVRGetBackingBuffer(psBuffer);
+}
+
+bool PVRDRIDrawableGetParameters(PVRDRIDrawable *psPVRDrawable,
+                                 PVRDRIBufferImpl **psDstBuffer,
+                                 PVRDRIBufferImpl **psAccumBuffer,
+                                 PVRDRIBufferAttribs *psAttribs,
+                                 bool *pbDoubleBuffered)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	PVRDRIBuffer *psPVRBuffer;
+
+	psPVRBuffer = PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+
+	*psDstBuffer = PVRGetBackingBuffer(psPVRBuffer);
+	if (*psDstBuffer == NULL)
+	{
+		errorMessage("%s: Couldn't get render buffer from cache\n", __func__);
+		return false;
+	}
+
+	psPVRBuffer = PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 1);
+
+	*psAccumBuffer = PVRGetBackingBuffer(psPVRBuffer);
+	if (*psAccumBuffer == NULL)
+	{
+		*psAccumBuffer = *psDstBuffer;
+	}
+
+	*pbDoubleBuffered = psPVRDrawable->bDoubleBuffered;
+
+	psAttribs->uiWidth           = psDRIDrawable->w;
+	psAttribs->uiHeight          = psDRIDrawable->h;
+	psAttribs->ePixFormat        = psPVRDrawable->ePixelFormat;
+	psAttribs->uiStrideInBytes   = psPVRDrawable->uStride;
+
+	return true;
+}
diff --git a/src/mesa/drivers/dri/pvr/pvrdri.c b/src/mesa/drivers/dri/pvr/pvrdri.c
new file mode 100644
index 0000000..b1e3708
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrdri.c
@@ -0,0 +1,1514 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          PVR DRI Mesa Driver
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include <assert.h>
+#include <pthread.h>
+#include <string.h>
+#include <xf86drm.h>
+
+#include "EGL/egl.h"
+#include "EGL/eglext.h"
+
+#include "dri_util.h"
+
+#include "pvrdri.h"
+#include "pvrimage.h"
+#include "pvrsyncobj.h"
+
+#include "pvrmesa.h"
+
+#define PVR_IMAGE_LOADER_VER_MIN 1
+#define PVR_DRI2_LOADER_VER_MIN 3
+
+typedef struct PVRBufferRec
+{
+	__DRIbuffer sDRIBuffer;
+	PVRDRIBufferImpl *psImpl;
+} PVRBuffer;
+
+extern const __DRIextension *apsScreenExtensions[];
+extern const __DRIextension asScreenExtensionVersionInfo[];
+
+/* We need to know the current screen in order to lookup EGL images. */
+static __thread PVRDRIScreen *gpsPVRScreen;
+
+/*************************************************************************/ /*!
+ Local functions
+*/ /**************************************************************************/
+
+static GLboolean PVRLoaderIsSupported(__DRIscreen *psDRIScreen)
+{
+	if (psDRIScreen->image.loader)
+	{
+		if (psDRIScreen->image.loader->base.version < PVR_IMAGE_LOADER_VER_MIN)
+		{
+			__driUtilMessage("%s: Image loader extension version %d but need %d",
+					 __func__,
+					 psDRIScreen->image.loader->base.version,
+					 PVR_IMAGE_LOADER_VER_MIN);
+			return GL_FALSE;
+		}
+		else if (!psDRIScreen->image.loader->getBuffers)
+		{
+			__driUtilMessage("%s: Image loader extension missing support for getBuffers",
+					 __func__);
+			return GL_FALSE;
+		}
+	}
+	else if (psDRIScreen->dri2.loader)
+	{
+		if (psDRIScreen->dri2.loader->base.version < PVR_DRI2_LOADER_VER_MIN)
+		{
+			__driUtilMessage("%s: DRI2 loader extension version %d but need %d",
+					 __func__,
+					 psDRIScreen->dri2.loader->base.version,
+					 PVR_DRI2_LOADER_VER_MIN);
+			return GL_FALSE;
+		}
+		else if (!psDRIScreen->dri2.loader->getBuffersWithFormat)
+		{
+			__driUtilMessage("%s: DRI2 loader extension missing support for getBuffersWithFormat",
+					 __func__);
+			return GL_FALSE;
+		}
+	}
+	else
+	{
+		__driUtilMessage("%s: Missing required loader extension (need "
+				 "either the image or DRI2 loader extension)",
+				 __func__);
+		return GL_FALSE;
+	}
+
+	return GL_TRUE;
+}
+
+static bool PVRMutexInit(pthread_mutex_t *psMutex, int iType)
+{
+	pthread_mutexattr_t sMutexAttr;
+	int res;
+
+	res = pthread_mutexattr_init(&sMutexAttr);
+	if (res != 0)
+	{
+		__driUtilMessage("%s: pthread_mutexattr_init failed (%d)",
+				 __func__,
+				 res);
+		return false;
+	}
+
+	res = pthread_mutexattr_settype(&sMutexAttr, iType);
+	if (res != 0)
+	{
+		__driUtilMessage("%s: pthread_mutexattr_settype failed (%d)",
+				 __func__,
+				 res);
+		goto ErrorMutexAttrDestroy;
+	}
+
+	res = pthread_mutex_init(psMutex, &sMutexAttr);
+	if (res != 0)
+	{
+		__driUtilMessage("%s: pthread_mutex_init failed (%d)",
+				 __func__,
+				 res);
+		goto ErrorMutexAttrDestroy;
+	}
+
+	(void) pthread_mutexattr_destroy(&sMutexAttr);
+
+	return true;
+
+ErrorMutexAttrDestroy:
+	(void) pthread_mutexattr_destroy(&sMutexAttr);
+
+	return false;
+}
+
+static void PVRMutexDeinit(pthread_mutex_t *psMutex)
+{
+	int res;
+
+	res = pthread_mutex_destroy(psMutex);
+	if (res != 0)
+	{
+		__driUtilMessage("%s: pthread_mutex_destroy failed (%d)",
+				 __func__,
+				 res);
+	}
+}
+
+static inline bool
+PVRDRIFlushBuffers(PVRDRIContext *psPVRContext,
+                   PVRDRIDrawable *psPVRDrawable,
+                   bool bFlushAllSurfaces,
+                   bool bSwapBuffers,
+                   bool bWaitForHW)
+{
+	return PVRDRIEGLFlushBuffers(psPVRContext->eAPI,
+	                             psPVRContext->psPVRScreen->psImpl,
+	                             psPVRContext->psImpl,
+	                             psPVRDrawable ? psPVRDrawable->psImpl : NULL,
+	                             bFlushAllSurfaces,
+                               bSwapBuffers,
+	                             bWaitForHW);
+}
+
+static inline bool
+PVRDRIFlushBuffersAndWait(PVRDRIContext *psPVRContext)
+{
+	return PVRDRIFlushBuffers(psPVRContext, NULL, true, false, true);
+}
+
+static inline bool
+PVRDRIFlushContextForSwapNoWait(PVRDRIContext *psPVRContext,
+                                PVRDRIDrawable *psPVRDrawable)
+{
+	return PVRDRIFlushBuffers(psPVRContext, psPVRDrawable, false, true, false);
+}
+
+static inline bool
+PVRDRIFlushBuffersForSwapAndWait(PVRDRIContext *psPVRContext)
+{
+	return PVRDRIFlushBuffers(psPVRContext, NULL, true, true, true);
+}
+
+static void
+PVRDRIFlushDrawable(PVRDRIDrawable *psPVRDrawable,
+                    bool bSwapBuffers,
+                    PVRDRIContext *psPVRSwapContext)
+{
+	PVRQElem *psQElem = psPVRDrawable->sPVRContextHead.pvForw;
+
+	while (psQElem != &psPVRDrawable->sPVRContextHead)
+	{
+		PVRDRIContext *psPVRContext = PVRQ_CONTAINER_OF(psQElem, PVRDRIContext, sQElem);
+
+		if (bSwapBuffers && (psPVRContext == psPVRSwapContext || psPVRSwapContext == NULL))
+		{
+			(void) PVRDRIFlushBuffersForSwapAndWait(psPVRContext);
+		}
+		else
+		{
+			(void) PVRDRIFlushBuffersAndWait(psPVRContext);
+		}
+
+		psQElem = psPVRContext->sQElem.pvForw;
+	}
+}
+
+static void
+PVRDRIFlushDrawableForSwapNoWait(PVRDRIDrawable *psPVRDrawable)
+{
+	PVRQElem *psQElem = psPVRDrawable->sPVRContextHead.pvForw;
+
+	while (psQElem != &psPVRDrawable->sPVRContextHead)
+	{
+		PVRDRIContext *psPVRContext = PVRQ_CONTAINER_OF(psQElem, PVRDRIContext, sQElem);
+
+		(void) PVRDRIFlushContextForSwapNoWait(psPVRContext, psPVRDrawable);
+
+		psQElem = psPVRContext->sQElem.pvForw;
+	}
+}
+
+static bool
+PVRDRICacheFlushSurfaces(bool bSwapBuffers,
+                         PVRDRIContext *psPVRSwapContext,
+                         PVRDRIDrawable *psPVRDrawable)
+{
+	if (PVRQIsEmpty(&psPVRDrawable->sCacheFlushHead))
+	{
+		return false;
+	}
+
+	PVRDRIFlushDrawable(psPVRDrawable, bSwapBuffers, psPVRSwapContext);
+
+	while (!PVRQIsEmpty(&psPVRDrawable->sCacheFlushHead))
+	{
+		PVRDRIBuffer *psPVRBuffer = PVRQ_CONTAINER_OF(psPVRDrawable->sCacheFlushHead.pvForw,
+		                                              PVRDRIBuffer,
+		                                              sCacheFlushElem);
+
+		PVRQDequeue(&psPVRBuffer->sCacheFlushElem);
+
+		switch (psPVRBuffer->eBackingType)
+		{
+			case PVRDRI_BUFFER_BACKING_DRI2:
+				PVRDRIBufferDestroy(psPVRBuffer->uBacking.sDRI2.psBuffer);
+				break;
+			case PVRDRI_BUFFER_BACKING_IMAGE:
+				PVRDRIUnrefImage(psPVRBuffer->uBacking.sImage.psImage);
+				break;
+			default:
+				assert(0);
+				continue;
+		}
+
+		free(psPVRBuffer);
+	}
+
+	return true;
+}
+
+bool
+PVRDRIFlushBuffersForSwap(PVRDRIContext *psPVRContext,
+                          PVRDRIDrawable *psPVRDrawable)
+{
+	if (PVRDRICacheFlushSurfaces(true, psPVRContext, psPVRDrawable))
+	{
+		return true;
+	}
+
+	if (psPVRContext != NULL)
+	{
+		return PVRDRIFlushContextForSwapNoWait(psPVRContext, psPVRDrawable);
+	}
+
+	PVRDRIFlushDrawableForSwapNoWait(psPVRDrawable);
+
+	return true;
+}
+
+static bool
+PVRDRIFlushBuffersGC(PVRDRIContext *psPVRContext)
+{
+	if (psPVRContext->psPVRDrawable != NULL)
+	{
+		if (PVRDRICacheFlushSurfaces(false, NULL, psPVRContext->psPVRDrawable))
+		{
+			return true;
+		}
+	}
+
+	return PVRDRIFlushBuffersAndWait(psPVRContext);
+}
+
+static void PVRDRIDisplayFrontBuffer(PVRDRIDrawable *psPVRDrawable)
+{
+	if (!psPVRDrawable->bDoubleBuffered)
+	{
+		PVRDRIScreen *psPVRScreen = psPVRDrawable->psPVRScreen;
+		__DRIscreen *psDRIScreen = psPVRScreen->psDRIScreen;
+
+		/* Only double buffered drawables should need flushing */
+		assert(PVRQIsEmpty(&psPVRDrawable->sCacheFlushHead));
+
+		if (psDRIScreen->image.loader && psDRIScreen->image.loader->flushFrontBuffer)
+		{
+			psDRIScreen->image.loader->flushFrontBuffer(psPVRDrawable->psDRIDrawable,
+								    psPVRDrawable->psDRIDrawable->loaderPrivate);
+		}
+		else if (psDRIScreen->dri2.loader && psDRIScreen->dri2.loader->flushFrontBuffer)
+		{
+			psDRIScreen->dri2.loader->flushFrontBuffer(psPVRDrawable->psDRIDrawable,
+								   psPVRDrawable->psDRIDrawable->loaderPrivate);
+		}
+	}
+}
+
+static void PVRContextUnbind(PVRDRIContext *psPVRContext,
+			     GLboolean bMakeUnCurrent,
+			     GLboolean bMarkSurfaceInvalid)
+{
+	if (bMakeUnCurrent || psPVRContext->psPVRDrawable != NULL)
+	{
+		(void) PVRDRIFlushBuffersGC(psPVRContext);
+	}
+
+	if (bMakeUnCurrent)
+	{
+		PVRDRIMakeUnCurrentGC(psPVRContext->eAPI,
+		                      psPVRContext->psPVRScreen->psImpl);
+	}
+
+	if (psPVRContext->psPVRDrawable != NULL)
+	{
+		if (bMarkSurfaceInvalid)
+		{
+			PVRDRIEGLMarkRendersurfaceInvalid(psPVRContext->eAPI,
+			                                  psPVRContext->psPVRScreen->psImpl,
+			                                  psPVRContext->psImpl);
+		}
+
+		psPVRContext->psPVRDrawable = NULL;
+	}
+
+	PVRQDequeue(&psPVRContext->sQElem);
+	PVRQQueue(&psPVRContext->psPVRScreen->sPVRContextHead,
+	          &psPVRContext->sQElem);
+}
+
+static inline PVRDRIContextImpl *
+getSharedContextImpl(void *pvSharedContextPrivate)
+{
+	if (pvSharedContextPrivate == NULL)
+	{
+		return NULL;
+	}
+	return ((PVRDRIContext *)pvSharedContextPrivate)->psImpl;
+}
+
+
+static inline void PVRDRIConfigFromMesa(PVRDRIConfigInfo *psConfigInfo,
+                                        const struct gl_config *psGLMode)
+{
+	memset(psConfigInfo, 0, sizeof(*psConfigInfo));
+	
+	psConfigInfo->samples           = psGLMode->samples;
+	psConfigInfo->redBits           = psGLMode->redBits;
+	psConfigInfo->greenBits         = psGLMode->greenBits;
+	psConfigInfo->blueBits          = psGLMode->blueBits;
+	psConfigInfo->alphaBits         = psGLMode->alphaBits;
+	psConfigInfo->rgbBits           = psGLMode->rgbBits;
+	psConfigInfo->depthBits         = psGLMode->depthBits;
+	psConfigInfo->stencilBits       = psGLMode->stencilBits;
+	psConfigInfo->doubleBufferMode  = psGLMode->doubleBufferMode;
+
+	psConfigInfo->sampleBuffers     = psGLMode->sampleBuffers;
+	psConfigInfo->bindToTextureRgb  = psGLMode->bindToTextureRgb;
+	psConfigInfo->bindToTextureRgba = psGLMode->bindToTextureRgba;
+}
+
+static inline GLboolean
+PVRContextCreateGC(PVRDRIContext *psPVRContext,
+                   const struct gl_config *psGLMode,
+                   uint32_t uFlags,
+                   void *pvSharedContextPrivate)
+{
+	InitialiseEGLModeInfo(psPVRContext->psImpl,
+	                      uFlags,
+	                      psPVRContext->uPriority);
+
+	if (psGLMode != NULL)
+	{
+		PVRDRIConfigInfo sConfigInfo;
+		PVRDRIConfigFromMesa(&sConfigInfo, psGLMode);
+		SetEGLModeInfoFromGLMode(psPVRContext->psImpl, &sConfigInfo);
+	}
+
+	if (!PVRDRICreateGC(psPVRContext->eAPI,
+			                psPVRContext->psPVRScreen->psImpl,
+			                psPVRContext->psImpl,
+			                getSharedContextImpl(pvSharedContextPrivate)))
+	{
+		__driUtilMessage("%s: PVRDRICreateGC failed", __func__);
+		return GL_FALSE;
+	}
+
+	return GL_TRUE;
+}
+
+
+static GLboolean
+PVRContextCreateOGL(PVRDRIContext *psPVRContext,
+                    gl_api eMesaAPI,
+                    const struct gl_config *psGLMode,
+                    unsigned uMajorVersion,
+                    unsigned uMinorVersion,
+                    uint32_t uFlags,
+                    unsigned *puError,
+                    void *pvSharedContextPrivate)
+{
+	PVRDRIScreen *psPVRScreen = psPVRContext->psPVRScreen;
+
+	assert(eMesaAPI == API_OPENGL_COMPAT || eMesaAPI == API_OPENGL_CORE);
+
+	if (!PVRDRILoadLibOGL(psPVRScreen))
+	{
+		return GL_FALSE;
+	}
+
+	if (!PVRDRIEGLGetPVROGLFunctionTable(psPVRScreen->psImpl, psPVRScreen->pvLibHandleOGL))
+	{
+		return GL_FALSE;
+	}
+
+	psPVRContext->eAPI = PVRDRI_API_GL;
+	if (!pvrdri_create_dispatch_table(psPVRScreen, PVRDRI_API_GL))
+	{
+		__driUtilMessage("%s: Couldn't create dispatch table",
+				 __func__);
+		return GL_FALSE;
+	}
+
+	switch (uMajorVersion)
+	{
+		case 3:
+			if (uMinorVersion > 3)
+			{
+				__driUtilMessage("%s: Only the OpenGL API V 3 up to version 3.3 is supported, not 3.%d",
+						 __func__,
+						 uMinorVersion);
+				*puError = __DRI_CTX_ERROR_BAD_VERSION;
+				return GL_FALSE;
+			}
+			if (uMinorVersion == 2 && eMesaAPI != API_OPENGL_CORE)
+			{
+				__driUtilMessage("%s: You must use a CORE context for OpenGL 3.3. Compatibility is not supported.",
+						 __func__);
+				*puError = __DRI_CTX_ERROR_BAD_API;
+				return GL_FALSE;
+			}
+			break;
+		case 2:
+			if (uMinorVersion > 1)
+			{
+				__driUtilMessage("%s: Only the OpenGL API V 2 up to version 2.1 is supported, not 2.%d",
+						 __func__,
+						 uMinorVersion);
+				*puError = __DRI_CTX_ERROR_BAD_VERSION;
+				return GL_FALSE;
+			}
+			break;
+		case 1:
+			if (uMinorVersion > 5)
+			{
+				__driUtilMessage("%s: Only the OpenGL API V 1 up to version 1.5 is supported, not 1.%d",
+						 __func__,
+						 uMinorVersion);
+				*puError = __DRI_CTX_ERROR_BAD_VERSION;
+				return GL_FALSE;
+			}
+			break;
+		default:
+			__driUtilMessage("%s: Unsupported OpenGL major version %d.  (We support up to 3.3.)",
+					 __func__,
+					 uMajorVersion);
+			*puError = __DRI_CTX_ERROR_BAD_VERSION;
+			return GL_FALSE;
+	}
+
+	/* Throw a BAD_FLAG error for any flags we don't recognise */
+	if ((uFlags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE)) != 0)
+	{
+		__driUtilMessage("%s: Unknown flags: 0x%x.",
+				 __func__,
+				 uFlags);
+		*puError = __DRI_CTX_ERROR_BAD_FLAG;
+		return GL_FALSE;
+	}
+
+	/* Version filtering */
+	if (uMajorVersion < 3)
+	{
+		/* Default is 1.0 but legacy apps need more than that.
+		 * It's OK, since 3.0 is backwards-compatible with 1.0.
+		 * See opengl.org/registry/specs/ARB/glx_create_context.txt
+		 * for full justification */
+		uMajorVersion = 3;
+		uMinorVersion = 0;
+
+		if (uFlags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE)
+		{
+			__driUtilMessage("%s: FORWARD_COMPATIBLE flag not supported in this version.",
+					 __func__);
+			*puError = __DRI_CTX_ERROR_BAD_FLAG;
+			return GL_FALSE;
+		}
+	}
+
+	PVRDRIContextImplSetVersion(psPVRContext->psImpl, uMajorVersion, uMinorVersion);
+	return PVRContextCreateGC(psPVRContext, psGLMode, uFlags, pvSharedContextPrivate);
+}
+
+static GLboolean
+PVRContextCreateOGLES1(PVRDRIContext *psPVRContext,
+                       const struct gl_config *psGLMode,
+                       uint32_t uFlags,
+                       unsigned *puError,
+                       void *pvSharedContextPrivate)
+{
+	PVRDRIScreen *psPVRScreen = psPVRContext->psPVRScreen;
+
+	psPVRContext->eAPI = PVRDRI_API_GLES1;
+
+	if (!PVRDRILoadLibOGLES1(psPVRScreen))
+	{
+		return GL_FALSE;
+	}
+
+	if (!PVRDRIEGLGetOGLES1FunctionTable(psPVRScreen->psImpl, psPVRScreen->pvLibHandleOGLES1))
+	{
+		return GL_FALSE;
+	}
+
+	if (!pvrdri_create_dispatch_table(psPVRScreen, PVRDRI_API_GLES1))
+	{
+		__driUtilMessage("%s: Couldn't create dispatch table",
+				 __func__);
+		return GL_FALSE;
+	}
+
+	/* Ignore DEBUG flag and throw a BAD_FLAG error if unrecognised */
+	uFlags &= ~__DRI_CTX_FLAG_DEBUG;
+	if (uFlags != 0)
+	{
+		__driUtilMessage("%s: Unknown flags: 0x%x.",
+				 __func__,
+				 uFlags);
+		*puError = __DRI_CTX_ERROR_BAD_FLAG;
+		return GL_FALSE;
+	}
+
+	return PVRContextCreateGC(psPVRContext, psGLMode, uFlags, pvSharedContextPrivate);
+}
+
+static GLboolean
+PVRContextCreateOGLES2(PVRDRIContext *psPVRContext,
+                       const struct gl_config *psGLMode,
+                       unsigned uMajorVersion,
+                       uint32_t uFlags,
+                       unsigned *puError,
+                       void *pvSharedContextPrivate)
+{
+	PVRDRIScreen *psPVRScreen = psPVRContext->psPVRScreen;
+
+	psPVRContext->eAPI = PVRDRI_API_GLES2;
+
+	if (!PVRDRILoadLibOGLES2(psPVRScreen))
+	{
+		return GL_FALSE;
+	}
+
+	if (!PVRDRIEGLGetOGLES2FunctionTable(psPVRScreen->psImpl, psPVRScreen->pvLibHandleOGLES2))
+	{
+		return GL_FALSE;
+	}
+
+	if (!pvrdri_create_dispatch_table(psPVRScreen, PVRDRI_API_GLES2))
+	{
+		__driUtilMessage("%s: Couldn't create dispatch table",
+				 __func__);
+		return GL_FALSE;
+	}
+
+	switch (uMajorVersion)
+	{
+		case 3:
+		case 2:
+			break;
+		default:
+			__driUtilMessage("%s: Unsupported OpenGLES major version %d.",
+					 __func__,
+					 uMajorVersion);
+			*puError = __DRI_CTX_ERROR_BAD_VERSION;
+			return GL_FALSE;
+	}
+
+	/* Ignore flags that have already been processed */
+	uFlags &= ~(__DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS);
+	
+	/* Check for any flags we don't support. */
+	if ((uFlags & ~__DRI_CTX_FLAG_DEBUG) != 0)
+	{
+		__driUtilMessage("%s: Unknown flags: 0x%x.",
+				 __func__,
+				 uFlags);
+		*puError = __DRI_CTX_ERROR_BAD_FLAG;
+		return GL_FALSE;
+	}
+
+	return PVRContextCreateGC(psPVRContext, psGLMode, uFlags, pvSharedContextPrivate);
+}
+
+static void PVRContextDestroy(PVRDRIContext *psPVRContext)
+{
+	PVRContextUnbind(psPVRContext, GL_FALSE, GL_FALSE);
+
+	if (!PVRDRIDestroyGC(psPVRContext->eAPI,
+			                 psPVRContext->psPVRScreen->psImpl,
+			                 psPVRContext->psImpl))
+	{
+		__driUtilMessage("%s: PVRDRIDestroyGC failed", __func__);
+	}
+
+	PVRQDequeue(&psPVRContext->sQElem);
+
+	PVRDRIDestroyContextImpl(psPVRContext->psImpl);
+	free(psPVRContext);
+}
+
+static inline void PVRDrawableUnbindContexts(PVRDRIDrawable *psPVRDrawable)
+{
+	PVRQElem *psQElem = psPVRDrawable->sPVRContextHead.pvForw;
+
+	while (psQElem != &psPVRDrawable->sPVRContextHead)
+	{
+		PVRDRIContext *psPVRContext = PVRQ_CONTAINER_OF(psQElem,
+		                                                PVRDRIContext,
+		                                                sQElem);
+
+		/* Get the next element in the list now, as the list will be modified */
+		psQElem = psPVRContext->sQElem.pvForw;
+
+		/* Draw surface? */
+		if (psPVRContext->psPVRDrawable == psPVRDrawable)
+		{
+			PVRContextUnbind(psPVRContext, GL_FALSE, GL_TRUE);
+		}
+		/* Pixmap? */
+		else
+		{
+			(void) PVRDRIFlushBuffersGC(psPVRContext);
+			PVRQDequeue(&psPVRContext->sQElem);
+		}
+	}
+}
+
+static void PVRDrawableDestroy(PVRDRIDrawable *psPVRDrawable)
+{
+	PVRDrawableUnbindContexts(psPVRDrawable);
+
+	PVRDRIDrawableDeinit(psPVRDrawable);
+
+	PVREGLDrawableDestroyConfig(psPVRDrawable->psImpl);
+
+	PVRQDequeue(&psPVRDrawable->sQElem);
+
+	PVRMutexDeinit(&psPVRDrawable->sMutex);
+
+	PVRDRIDestroyDrawableImpl(psPVRDrawable->psImpl);
+	free(psPVRDrawable);
+}
+
+static inline void PVRScreenContextsDestroy(PVRDRIScreen *psPVRScreen)
+{
+	PVRQElem *psQElem = psPVRScreen->sPVRContextHead.pvForw;
+
+	while (psQElem != &psPVRScreen->sPVRContextHead)
+	{
+		PVRDRIContext *psPVRContext = PVRQ_CONTAINER_OF(psQElem, PVRDRIContext, sQElem);
+
+		/* Get the next element in the list now, as the list will be modified */
+		psQElem = psPVRContext->sQElem.pvForw;
+
+		PVRContextDestroy(psPVRContext);
+	}
+}
+
+static inline void PVRScreenDrawablesDestroy(PVRDRIScreen *psPVRScreen)
+{
+	PVRQElem *psQElem = psPVRScreen->sPVRDrawableHead.pvForw;
+
+	while (psQElem != &psPVRScreen->sPVRDrawableHead)
+	{
+		PVRDRIDrawable *psPVRDrawable;
+
+		psPVRDrawable = PVRQ_CONTAINER_OF(psQElem,
+						  PVRDRIDrawable,
+						  sQElem);
+
+		/* Get the next element in the list now, as the list will be modified */
+		psQElem = psPVRDrawable->sQElem.pvForw;
+
+		PVRDrawableDestroy(psPVRDrawable);
+	}
+}
+
+static void PVRScreenPrintExtensions(__DRIscreen *psDRIScreen)
+{
+	/* Don't attempt to print anything if LIBGL_DEBUG isn't in the environment */
+	if (getenv("LIBGL_DEBUG") == NULL)
+	{
+		return;
+	}
+
+	if (psDRIScreen->extensions)
+	{
+		int i;
+		int j;
+
+		__driUtilMessage("Supported screen extensions:");
+
+		for (i = 0; psDRIScreen->extensions[i]; i++)
+		{
+			for (j = 0; asScreenExtensionVersionInfo[j].name; j++)
+			{
+				if (strcmp(psDRIScreen->extensions[i]->name,
+				           asScreenExtensionVersionInfo[j].name) == 0)
+				{
+					__driUtilMessage("\t%s (supported version: %u - max version: %u)",
+							 psDRIScreen->extensions[i]->name,
+							 psDRIScreen->extensions[i]->version,
+							 asScreenExtensionVersionInfo[j].version);
+					break;
+				}
+			}
+
+			if (asScreenExtensionVersionInfo[j].name == NULL)
+			{
+				__driUtilMessage("\t%s (supported version: %u - max version: unknown)",
+						 psDRIScreen->extensions[i]->name,
+						 psDRIScreen->extensions[i]->version);
+			}
+		}
+	}
+	else
+	{
+		__driUtilMessage("No screen extensions found");
+	}
+}
+
+
+/*************************************************************************/ /*!
+ Mesa driver API functions
+*/ /**************************************************************************/
+static const __DRIconfig **PVRDRIInitScreen(__DRIscreen *psDRIScreen)
+{
+	PVRDRIScreen *psPVRScreen;
+	const __DRIconfig **configs;
+	uint32_t uiDisplayCount;
+	PVRDRICallbacks sDRICallbacks = {
+		.DrawableCreate              = PVRDRIDrawableCreate,
+		.DrawableRecreate            = PVRDRIDrawableRecreate,
+		.DrawableGetDstBuffer        = PVRDRIDrawableGetDstBuffer,
+		.DrawableGetAccumBuffer      = PVRDRIDrawableGetAccumBuffer,
+		.DrawableGetParameters       = PVRDRIDrawableGetParameters,
+		.ImageGetSharedType          = PVRDRIImageGetSharedType,
+		.ImageGetSharedBuffer        = PVRDRIImageGetSharedBuffer,
+		.ImageGetSharedEGLImage      = PVRDRIImageGetSharedEGLImage,
+		.ImageGetEGLImage            = PVRDRIImageGetEGLImage,
+		.ScreenGetDRIImage           = PVRDRIScreenGetDRIImage,
+		.RefImage                    = PVRDRIRefImage,
+		.UnrefImage                  = PVRDRIUnrefImage,
+	};
+
+	if (!PVRLoaderIsSupported(psDRIScreen))
+	{
+		return NULL;
+	}
+
+	if (!PVRScreenGlobalInit())
+	{
+		return NULL;
+	}
+
+	PVRDRIRegisterCallbacks(&sDRICallbacks);
+
+	psPVRScreen = calloc(1, sizeof(*psPVRScreen));
+	if (psPVRScreen == NULL)
+	{
+		__driUtilMessage("%s: Couldn't allocate PVRDRIScreen",
+				 __func__);
+		goto ErrorScreenGlobalDeinit;
+	}
+
+	DRIScreenPrivate(psDRIScreen) = psPVRScreen;
+	psPVRScreen->psDRIScreen = psDRIScreen;
+
+	INITIALISE_PVRQ_HEAD(&psPVRScreen->sPVRContextHead);
+	INITIALISE_PVRQ_HEAD(&psPVRScreen->sPVRDrawableHead);
+
+	/*
+	 * KEGLGetDrawableParameters could be called with the mutex either
+	 * locked or unlocked, hence the use of a recursive mutex.
+	 */
+	if (!PVRMutexInit(&psPVRScreen->sMutex, PTHREAD_MUTEX_RECURSIVE))
+	{
+		__driUtilMessage("%s: Screen mutex initialisation failed",
+				 __func__);
+		goto ErrorScreenFree;
+	}
+
+	psPVRScreen->bUseInvalidate = (psDRIScreen->dri2.useInvalidate != NULL);
+
+	psDRIScreen->extensions = apsScreenExtensions;
+
+	psPVRScreen->psImpl = PVRDRICreateScreenImpl(psDRIScreen->fd);
+	if (psPVRScreen->psImpl == NULL)
+	{
+		goto ErrorScreenMutexDeinit;
+	}
+
+	uiDisplayCount = PVRScreenCountInc();
+
+#if defined(PVR_OGL_LIB)
+	/*
+	 * OpenGL doesn't support concurrent EGL displays so only advertise
+	 * OpenGL support for the first display.
+	 */
+	if (uiDisplayCount == 1)
+	{
+		psDRIScreen->max_gl_compat_version = 30;
+		psDRIScreen->max_gl_core_version = 33;
+	}
+#else
+	(void) uiDisplayCount;
+#endif
+
+	psDRIScreen->max_gl_es1_version = 11;
+	psDRIScreen->max_gl_es2_version = 31;
+
+	configs = PVRDRICreateConfigs();
+	if (configs == NULL)
+	{
+		__driUtilMessage("%s: No framebuffer configs", __func__);
+		goto ErrorScreenImplDeinit;
+	}
+
+	PVRScreenPrintExtensions(psDRIScreen);
+
+	return configs;
+
+ErrorScreenImplDeinit:
+	PVRDRIDestroyScreenImpl(psPVRScreen->psImpl);
+
+ErrorScreenMutexDeinit:
+	PVRMutexDeinit(&psPVRScreen->sMutex);
+
+ErrorScreenFree:
+	free(psPVRScreen);
+
+ErrorScreenGlobalDeinit:
+	PVRScreenGlobalDeinit();
+
+	return NULL;
+}
+
+static void PVRDRIDestroyScreen(__DRIscreen *psDRIScreen)
+{
+	PVRDRIScreen *psPVRScreen = DRIScreenPrivate(psDRIScreen);
+
+	(void)PVRScreenCountDec();
+	/*
+	 * The drawables are destroyed first, which will result in any
+	 * bound contexts being placed on the screen's context list.
+	 */
+	PVRScreenDrawablesDestroy(psPVRScreen);
+
+	PVRScreenContextsDestroy(psPVRScreen);
+
+	pvrdri_free_dispatch_tables(psPVRScreen);
+
+	(void)PVRDRIEGLFreeResources(psPVRScreen->psImpl);
+
+#if defined(__DRI2_FENCE)
+	PVRDRIDestroyFences(psPVRScreen);
+#endif
+
+	PVRDRIDestroyScreenImpl(psPVRScreen->psImpl);
+	PVRMutexDeinit(&psPVRScreen->sMutex);
+
+	PVRScreenGlobalDeinit();
+
+	free(psPVRScreen);
+}
+
+static EGLint PVRDRIScreenSupportedAPIs(PVRDRIScreen *psPVRScreen)
+{
+	unsigned api_mask = psPVRScreen->psDRIScreen->api_mask;
+	EGLint supported = 0;
+
+	if ((api_mask & (1 << __DRI_API_OPENGL)) != 0)
+	{
+		supported |= EGL_OPENGL_BIT;
+	}
+
+	if ((api_mask & (1 << __DRI_API_GLES)) != 0)
+	{
+		supported |= EGL_OPENGL_ES_BIT;
+	}
+
+	if ((api_mask & (1 << __DRI_API_GLES2)) != 0)
+	{
+		supported |= EGL_OPENGL_ES2_BIT;
+	}
+
+	if ((api_mask & (1 << __DRI_API_GLES3)) != 0)
+	{
+		supported |= EGL_OPENGL_ES3_BIT_KHR;
+	}
+
+	return supported;
+}
+
+static GLboolean PVRDRICreateContext(gl_api eMesaAPI,
+                                     const struct gl_config *psGLMode,
+                                     __DRIcontext *psDRIContext,
+                                     unsigned uMajorVersion,
+                                     unsigned uMinorVersion,
+                                     uint32_t uFlags,
+                                     bool notify_reset,
+                                     unsigned *puError,
+                                     void *pvSharedContextPrivate)
+{
+	__DRIscreen *psDRIScreen = psDRIContext->driScreenPriv;
+	PVRDRIScreen *psPVRScreen = (PVRDRIScreen *)DRIScreenPrivate(psDRIScreen);
+	PVRDRIContext *psPVRContext = NULL;
+	PVRDRIContextImpl *psContextImpl = NULL;
+	GLboolean res;
+	unsigned uPriority;
+
+	*puError = __DRI_CTX_ERROR_SUCCESS;
+
+	psContextImpl = PVRDRICreateContextImpl(uMajorVersion, uMinorVersion,
+	                                        (uFlags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS) != 0,
+	                                        notify_reset);
+	if (psContextImpl == NULL)
+	{
+		__driUtilMessage("%s: Couldn't allocate PVRDRIContextImpl", __func__);
+		*puError = __DRI_CTX_ERROR_NO_MEMORY;
+		goto ErrorExit;
+	}
+
+	psPVRContext = calloc(1, sizeof(*psPVRContext));
+	if (psPVRContext == NULL)
+	{
+		__driUtilMessage("%s: Couldn't allocate PVRDRIContext",
+				 __func__);
+		*puError = __DRI_CTX_ERROR_NO_MEMORY;
+		goto ErrorExit;
+	}
+
+	psPVRContext->psImpl = psContextImpl;
+	psPVRContext->psDRIContext = psDRIContext;
+	psPVRContext->psPVRScreen = psPVRScreen;
+
+#if defined(__DRI_PRIORITY)
+	switch (psDRIContext->priority)
+	{
+		case __DRI_CTX_PRIORITY_LOW:
+			uPriority = 0;
+			break;
+		case __DRI_CTX_PRIORITY_MEDIUM:
+			uPriority = 1;
+			break;
+		case __DRI_CTX_PRIORITY_HIGH:
+			uPriority = 2;
+			break;
+		default:
+			*puError = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+			goto ErrorExit;
+	}
+#else
+	uPriority = 1;
+#endif
+	psPVRContext->uPriority = uPriority;
+
+	psDRIContext->driverPrivate = (void *)psPVRContext;
+
+	switch (eMesaAPI)
+	{
+		case API_OPENGL_COMPAT:
+		case API_OPENGL_CORE:
+			res = PVRContextCreateOGL(psPVRContext,
+							eMesaAPI,
+						  psGLMode,
+						  uMajorVersion,
+						  uMinorVersion,
+						  uFlags,
+						  puError,
+						  pvSharedContextPrivate);
+			break;
+		case API_OPENGLES:
+			res = PVRContextCreateOGLES1(psPVRContext,
+						     psGLMode,
+						     uFlags,
+						     puError,
+						     pvSharedContextPrivate);
+			break;
+		case API_OPENGLES2:
+			res = PVRContextCreateOGLES2(psPVRContext,
+						     psGLMode,
+						     uMajorVersion,
+						     uFlags,
+						     puError,
+						     pvSharedContextPrivate);
+			break;
+		default:
+			__driUtilMessage("%s: Unsupported API: %d",
+					 __func__,
+					 (int)eMesaAPI);
+			res = GL_FALSE;
+			break;
+	}
+
+	if (!res)
+	{
+		if (*puError == __DRI_CTX_ERROR_SUCCESS)
+		{
+			*puError = __DRI_CTX_ERROR_BAD_API;
+		}
+		goto ErrorExit;
+	}
+
+	PVRDRIScreenLock(psPVRScreen);
+	PVRQQueue(&psPVRScreen->sPVRContextHead, &psPVRContext->sQElem);
+	PVRDRIScreenUnlock(psPVRScreen);
+
+	*puError = __DRI_CTX_ERROR_SUCCESS;
+
+	return GL_TRUE;
+
+ErrorExit:
+	psDRIContext->driverPrivate = NULL;
+
+	PVRDRIDestroyContextImpl(psContextImpl);
+	free(psPVRContext);
+
+	if (*puError == __DRI_CTX_ERROR_SUCCESS)
+	{
+		__driUtilMessage("%s: DRI error code not set!", __func__);
+		*puError = __DRI_CTX_ERROR_BAD_FLAG;
+	}
+
+	return GL_FALSE;
+}
+
+static void PVRDRIDestroyContext(__DRIcontext *psDRIContext)
+{
+	PVRDRIContext *psPVRContext = (PVRDRIContext *)psDRIContext->driverPrivate;
+	PVRDRIScreen *psPVRScreen = psPVRContext->psPVRScreen;
+
+	PVRDRIScreenLock(psPVRScreen);
+	PVRContextDestroy(psPVRContext);
+	PVRDRIScreenUnlock(psPVRScreen);
+}
+
+static IMG_PIXFMT PVRDRIGetPixelFormat(const struct gl_config *psGLMode)
+{
+	switch (psGLMode->rgbBits)
+	{
+		case 32:
+		case 24:
+			if (psGLMode->redMask   == 0x00FF0000 &&
+			    psGLMode->greenMask == 0x0000FF00 &&
+			    psGLMode->blueMask  == 0x000000FF)
+			{
+				if (psGLMode->alphaMask == 0xFF000000)
+				{
+					return IMG_PIXFMT_B8G8R8A8_UNORM;
+				}
+				else if (psGLMode->alphaMask == 0)
+				{
+					return IMG_PIXFMT_B8G8R8X8_UNORM;
+				}
+			}
+
+			__driUtilMessage("%s: Unsupported buffer format", __func__);
+			return IMG_PIXFMT_UNKNOWN;
+
+		case 16:
+			if (psGLMode->redMask   == 0xF800 &&
+			    psGLMode->greenMask == 0x07E0 &&
+			    psGLMode->blueMask  == 0x001F)
+			{
+				return IMG_PIXFMT_B5G6R5_UNORM;
+			}
+
+		default:
+			errorMessage("%s: Unsupported screen format\n", __func__);
+			return IMG_PIXFMT_UNKNOWN;
+	}
+}
+
+static GLboolean PVRDRICreateBuffer(__DRIscreen *psDRIScreen,
+                                    __DRIdrawable *psDRIDrawable,
+                                    const struct gl_config *psGLMode,
+                                    GLboolean bIsPixmap)
+{
+	PVRDRIScreen *psPVRScreen = DRIScreenPrivate(psDRIScreen);
+	PVRDRIDrawable *psPVRDrawable = NULL;
+	PVRDRIDrawableImpl *psDrawableImpl = NULL;
+	EGLint supportedAPIs = PVRDRIScreenSupportedAPIs(psPVRScreen);
+	PVRDRIConfigInfo sConfigInfo;
+
+	/* No known callers ever set this to true */
+	if (bIsPixmap)
+	{
+		return GL_FALSE;
+	}
+
+	if (!psGLMode)
+	{
+		__driUtilMessage("%s: Invalid GL config", __func__);
+		return GL_FALSE;
+	}
+
+	psPVRDrawable = calloc(1, sizeof(*psPVRDrawable));
+	if (!psPVRDrawable)
+	{
+		__driUtilMessage("%s: Couldn't allocate PVR drawable", __func__);
+		goto ErrorDrawableFree;
+	}
+
+	psDrawableImpl = PVRDRICreateDrawableImpl(psPVRDrawable);
+	if (!psDrawableImpl)
+	{
+		__driUtilMessage("%s: Couldn't allocate PVR drawable", __func__);
+		goto ErrorDrawableFree;
+	}
+
+	psPVRDrawable->psImpl = psDrawableImpl;
+
+	psDRIDrawable->driverPrivate = (void *)psPVRDrawable;
+
+	INITIALISE_PVRQ_HEAD(&psPVRDrawable->sPVRContextHead);
+	INITIALISE_PVRQ_HEAD(&psPVRDrawable->sCacheFlushHead);
+
+	psPVRDrawable->psDRIDrawable = psDRIDrawable;
+	psPVRDrawable->psPVRScreen = psPVRScreen;
+	psPVRDrawable->bDoubleBuffered = psGLMode->doubleBufferMode;
+
+	psPVRDrawable->ePixelFormat = PVRDRIGetPixelFormat(psGLMode);
+	if (psPVRDrawable->ePixelFormat == IMG_PIXFMT_UNKNOWN)
+	{
+		__driUtilMessage("%s: Couldn't work out pixel format", __func__);
+		goto ErrorDrawableFree;
+	}
+
+	if (!PVRMutexInit(&psPVRDrawable->sMutex, PTHREAD_MUTEX_RECURSIVE))
+	{
+		__driUtilMessage("%s: Couldn't initialise drawable mutex", __func__);
+		goto ErrorDrawableFree;
+	}
+
+	PVRDRIConfigFromMesa(&sConfigInfo, psGLMode);
+	if (!PVRDRIEGLDrawableConfigFromGLMode(psDrawableImpl,
+	                                       &sConfigInfo,
+	                                       supportedAPIs,
+	                                       psPVRDrawable->ePixelFormat))
+	{
+		__driUtilMessage("%s: Couldn't derive EGL config", __func__);
+		goto ErrirDrawableMutexDeinit;
+	}
+
+	PVRDRIScreenLock(psPVRScreen);
+	PVRQQueue(&psPVRScreen->sPVRDrawableHead, &psPVRDrawable->sQElem);
+	PVRDRIScreenUnlock(psPVRScreen);
+
+	/* Initialisation is completed in MakeCurrent */
+
+	return GL_TRUE;
+
+ErrirDrawableMutexDeinit:
+	PVRMutexDeinit(&psPVRDrawable->sMutex);
+
+ErrorDrawableFree:
+	PVRDRIDestroyDrawableImpl(psDrawableImpl);
+	free(psPVRDrawable);
+	psDRIDrawable->driverPrivate= NULL;
+
+	return GL_FALSE;
+}
+
+static void PVRDRIDestroyBuffer(__DRIdrawable *psDRIDrawable)
+{
+	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
+	PVRDRIScreen *psPVRScreen = psPVRDrawable->psPVRScreen;
+
+	PVRDRIScreenLock(psPVRScreen);
+	PVRDrawableDestroy(psPVRDrawable);
+	PVRDRIScreenUnlock(psPVRScreen);
+}
+
+static GLboolean PVRDRIMakeCurrent(__DRIcontext *psDRIContext,
+				   __DRIdrawable *psDRIWrite,
+				   __DRIdrawable *psDRIRead)
+{
+	PVRDRIContext *psPVRContext = (PVRDRIContext *)psDRIContext->driverPrivate;
+	PVRDRIDrawable *psPVRWrite = (psDRIWrite) ? (PVRDRIDrawable *)psDRIWrite->driverPrivate : NULL;
+	PVRDRIDrawable *psPVRRead = (psDRIRead) ? (PVRDRIDrawable *)psDRIRead->driverPrivate : NULL;
+
+	PVRDRIScreenLock(psPVRContext->psPVRScreen);
+
+	if (psPVRWrite != NULL)
+	{
+		if (!PVRDRIDrawableInit(psPVRWrite))
+		{
+			__driUtilMessage("%s: Couldn't initialise write drawable",
+					 __func__);
+			goto ErrorUnlock;
+		}
+	}
+
+	if (psPVRRead != NULL)
+	{
+		if (!PVRDRIDrawableInit(psPVRRead))
+		{
+			__driUtilMessage("%s: Couldn't initialise read drawable",
+					 __func__);
+			goto ErrorUnlock;
+		}
+	}
+
+	if (!PVRDRIMakeCurrentGC(psPVRContext->eAPI,
+	                         psPVRContext->psPVRScreen->psImpl,
+	                         psPVRContext->psImpl,
+	                         psPVRWrite == NULL ? NULL : psPVRWrite->psImpl,
+	                         psPVRRead  == NULL ? NULL : psPVRRead->psImpl))
+	{
+		pvrdri_set_null_dispatch_table();
+		goto ErrorUnlock;
+	}
+
+	PVRQDequeue(&psPVRContext->sQElem);
+
+	if (psPVRWrite != NULL)
+	{
+		PVRQQueue(&psPVRWrite->sPVRContextHead, &psPVRContext->sQElem);
+	}
+
+	psPVRContext->psPVRDrawable = psPVRWrite;
+
+	if (psPVRWrite != NULL && psPVRContext->eAPI == PVRDRI_API_GL)
+	{
+		PVRDRIEGLSetOGLFrontBufferCallback(psPVRContext->eAPI,
+		                                   psPVRContext->psPVRScreen->psImpl,
+		                                   psPVRWrite->psImpl,
+		                                   PVRDRIDisplayFrontBuffer);
+	}
+
+	pvrdri_set_dispatch_table(psPVRContext);
+
+	PVRDRIThreadSetCurrentScreen(psPVRContext->psPVRScreen);
+
+	PVRDRIScreenUnlock(psPVRContext->psPVRScreen);
+
+	return GL_TRUE;
+
+ErrorUnlock:
+	PVRDRIScreenUnlock(psPVRContext->psPVRScreen);
+
+	return GL_FALSE;
+}
+
+static GLboolean PVRDRIUnbindContext(__DRIcontext *psDRIContext)
+{
+	PVRDRIContext *psPVRContext = (PVRDRIContext *)psDRIContext->driverPrivate;
+	PVRDRIScreen *psPVRScreen = psPVRContext->psPVRScreen;
+
+	PVRDRIScreenLock(psPVRScreen);
+	PVRContextUnbind(psPVRContext, GL_TRUE, GL_FALSE);
+	PVRDRIThreadSetCurrentScreen(NULL);
+	PVRDRIScreenUnlock(psPVRScreen);
+
+	return GL_TRUE;
+}
+
+static __DRIbuffer *PVRDRIAllocateBuffer(__DRIscreen *psDRIScreen,
+					 unsigned int uAttachment,
+					 unsigned int uFormat,
+					 int iWidth,
+					 int iHeight)
+{
+	PVRDRIScreen *psPVRScreen = DRIScreenPrivate(psDRIScreen);
+	PVRBuffer *psBuffer;
+	unsigned int uiBpp;
+
+	/* GEM names are only supported on primary nodes */
+	if (drmGetNodeTypeFromFd(psDRIScreen->fd) != DRM_NODE_PRIMARY)
+	{
+		__driUtilMessage("%s: Cannot allocate buffer", __func__);
+		return NULL;
+	}
+
+	/* This is based upon PVRDRIGetPixelFormat */
+	switch (uFormat)
+	{
+		case 32:
+		case 16:
+			/* Format (depth) and bpp match */
+			uiBpp = uFormat;
+			break;
+		case 24:
+			uiBpp = 32;
+			break;
+		default:
+			__driUtilMessage("%s: Unsupported format '%u'",
+					 __func__, uFormat);
+			return NULL;
+	}
+
+	psBuffer = calloc(1, sizeof(*psBuffer));
+	if (psBuffer == NULL)
+	{
+		__driUtilMessage("%s: Failed to allocate buffer", __func__);
+		return NULL;
+	}
+
+	psBuffer->psImpl = PVRDRIBufferCreate(psPVRScreen->psImpl,
+					      iWidth,
+					      iHeight,
+					      uiBpp,
+					      PVDRI_BUFFER_USE_SHARE,
+					      &psBuffer->sDRIBuffer.pitch);
+	if (!psBuffer->psImpl)
+	{
+		__driUtilMessage("%s: Failed to create backing buffer",
+				 __func__);
+		goto ErrorFreeDRIBuffer;
+	}
+
+	psBuffer->sDRIBuffer.attachment = uAttachment;
+	psBuffer->sDRIBuffer.name = PVRDRIBufferGetName(psBuffer->psImpl);
+	psBuffer->sDRIBuffer.cpp = uiBpp / 8;
+
+	return &psBuffer->sDRIBuffer;
+
+ErrorFreeDRIBuffer:
+	free(psBuffer);
+
+	return NULL;
+}
+
+static void PVRDRIReleaseBuffer(__DRIscreen *psDRIScreen,
+				__DRIbuffer *psDRIBuffer)
+{
+	PVRBuffer *psBuffer = (PVRBuffer *)psDRIBuffer;
+
+	(void)psDRIScreen;
+
+	PVRDRIBufferDestroy(psBuffer->psImpl);
+	free(psBuffer);
+}
+
+/* Publish our driver implementation to the world. */
+static const struct __DriverAPIRec pvr_driver_api =
+{
+	.InitScreen     = PVRDRIInitScreen,
+	.DestroyScreen  = PVRDRIDestroyScreen,
+	.CreateContext  = PVRDRICreateContext,
+	.DestroyContext = PVRDRIDestroyContext,
+	.CreateBuffer   = PVRDRICreateBuffer,
+	.DestroyBuffer  = PVRDRIDestroyBuffer,
+	.SwapBuffers    = NULL,
+	.MakeCurrent    = PVRDRIMakeCurrent,
+	.UnbindContext  = PVRDRIUnbindContext,
+	.AllocateBuffer = PVRDRIAllocateBuffer,
+	.ReleaseBuffer  = PVRDRIReleaseBuffer,
+};
+
+static const struct __DRIDriverVtableExtensionRec pvr_vtable = {
+   .base = { __DRI_DRIVER_VTABLE, 1 },
+   .vtable = &pvr_driver_api,
+};
+
+static const __DRIextension *pvr_driver_extensions[] = {
+    &driCoreExtension.base,
+    &driImageDriverExtension.base,
+    &driDRI2Extension.base,
+    &pvr_vtable.base,
+    NULL
+};
+
+const __DRIextension **__driDriverGetExtensions_pvr(void);
+PUBLIC const __DRIextension **__driDriverGetExtensions_pvr(void)
+{
+   globalDriverAPI = &pvr_driver_api;
+
+   return pvr_driver_extensions;
+}
+
+/*************************************************************************/ /*!
+ Global functions
+*/ /**************************************************************************/
+
+/***********************************************************************************
+ Function Name	: PVRDRIDrawableLock
+ Inputs		: psPVRDrawable - PVRDRI drawable structure
+ Returns	: Boolean
+ Description	: Lock drawable mutex (can be called recursivly)
+************************************************************************************/
+void PVRDRIDrawableLock(PVRDRIDrawable *psPVRDrawable)
+{
+	int res;
+
+	res  = pthread_mutex_lock(&psPVRDrawable->sMutex);
+	if (res != 0)
+	{
+		errorMessage("%s: Failed to lock drawable (%d)\n", __func__, res);
+		abort();
+	}
+}
+
+/***********************************************************************************
+ Function Name	: PVRDRIDrawableUnlock
+ Inputs		: psPVRDrawable - PVRDRI drawable structure
+ Returns	: Boolean
+ Description	: Unlock drawable mutex (can be called recursivly)
+************************************************************************************/
+void PVRDRIDrawableUnlock(PVRDRIDrawable *psPVRDrawable)
+{
+	int res;
+
+	res  = pthread_mutex_unlock(&psPVRDrawable->sMutex);
+	if (res != 0)
+	{
+		errorMessage("%s: Failed to unlock drawable (%d)\n", __func__, res);
+		abort();
+	}
+}
+
+/***********************************************************************************
+ Function Name	: PVRDRIScreenLock
+ Inputs		: psPVRScreen - PVRDRI screen structure
+ Returns	: Boolean
+ Description	: Lock screen mutex (can be called recursivly)
+************************************************************************************/
+void PVRDRIScreenLock(PVRDRIScreen *psPVRScreen)
+{
+	int res;
+
+	res  = pthread_mutex_lock(&psPVRScreen->sMutex);
+	if (res != 0)
+	{
+		errorMessage("%s: Failed to lock screen (%d)\n", __func__, res);
+		abort();
+	}
+}
+
+/***********************************************************************************
+ Function Name	: PVRDRIScreenUnlock
+ Inputs		: psPVRScreen - PVRDRI screen structure
+ Returns	: Boolean
+ Description	: Unlock screen mutex (can be called recursivly)
+************************************************************************************/
+void PVRDRIScreenUnlock(PVRDRIScreen *psPVRScreen)
+{
+	int res;
+
+	res  = pthread_mutex_unlock(&psPVRScreen->sMutex);
+	if (res != 0)
+	{
+		errorMessage("%s: Failed to unlock screen (%d)\n", __func__, res);
+		abort();
+	}
+}
+
+void PVRDRIThreadSetCurrentScreen(PVRDRIScreen *psPVRScreen)
+{
+	gpsPVRScreen = psPVRScreen;
+}
+
+PVRDRIScreen *PVRDRIThreadGetCurrentScreen(void)
+{
+	return gpsPVRScreen;
+}
diff --git a/src/mesa/drivers/dri/pvr/pvrdri.h b/src/mesa/drivers/dri/pvr/pvrdri.h
new file mode 100644
index 0000000..51b1743
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrdri.h
@@ -0,0 +1,280 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          PVR DRI Mesa Driver
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVRDRI2_H__)
+#define __PVRDRI2_H__
+#include <stdbool.h>
+
+#include <glapi/glapi.h>
+
+#include "main/mtypes.h"
+#include "pvr_mesa_version.h"
+#include "GL/internal/dri_interface.h"
+
+#include "imgpixfmts.h"
+#include "pvr_dri_support.h"
+#include "pvrqueue.h"
+#include "EGL/egl.h"
+#include "pvr_object_cache.h"
+
+/* This should match EGL_MAX_ALLOCS */
+#define DRI_PLANES_MAX 3
+
+#define	DRI2_BUFFERS_MAX (3)
+
+#define	DRIScreenPrivate(pScreen)	((pScreen)->driverPrivate)
+
+/** Our PVR related screen data */
+typedef struct PVRDRIScreen_TAG
+{
+	/* DRI screen structure pointer */
+	__DRIscreen        *psDRIScreen;
+	/* Mutex for this screen */
+	pthread_mutex_t     sMutex;
+	/* List of contexts */
+	PVRQHead            sPVRContextHead;
+	/* List of drawables */
+	PVRQHead            sPVRDrawableHead;
+	/* X Server sends invalidate events */
+	bool                bUseInvalidate;
+
+	/* PVR OGL dispatch table */
+	_glapi_proc        *psPVROGLDispatch;
+	/* PVR OGLES 1 dispatch table */
+	_glapi_proc        *psOGLES1Dispatch;
+	/* PVR OGLES 2/3 dispatch table */
+	_glapi_proc        *psOGLES2Dispatch;
+
+	/* PVR OGL library handle */
+	void               *pvLibHandleOGL;
+	/* PVR OGLES 1 library handle */
+	void               *pvLibHandleOGLES1;
+	/* PVR OGLES 2/3 library handle */
+	void               *pvLibHandleOGLES2;
+	/* PVR OCL library handle */
+	void               *pvLibHandleOCL;
+
+	PVRDRIScreenImpl   *psImpl;
+} PVRDRIScreen;
+
+/** Our PVR related context data */
+typedef struct PVRDRIContext_TAG
+{
+	PVRQElem                   sQElem;
+
+	/* Pointer to DRI context */
+	__DRIcontext              *psDRIContext;
+	/* Pointer to PVRDRIScreen structure */
+	PVRDRIScreen              *psPVRScreen;
+	/* Pointer to currently bound drawable */
+	struct PVRDRIDrawable_TAG	*psPVRDrawable;
+
+	/* API */
+	pvrdri_api_type            eAPI;
+
+	/* Context priority */
+	unsigned                   uPriority;
+
+	PVRDRIContextImpl         *psImpl;
+} PVRDRIContext;
+
+/** Our PVR related drawable data */
+typedef struct PVRDRIDrawable_TAG
+{
+	PVRQElem            sQElem;
+
+	/** Ptr to PVR screen, that spawned this drawable */
+	PVRDRIScreen       *psPVRScreen;
+
+	/** DRI drawable data */
+	__DRIdrawable      *psDRIDrawable;
+
+	/** Are surface/buffers created? */
+	bool                bInitialised;
+
+	/** Are we using double buffering? */
+	bool                bDoubleBuffered;
+
+	/** Buffer stride */
+	unsigned            uStride;
+
+	/* Number of bytes per pixel */
+	unsigned int        uBytesPerPixel;
+
+	/* List of contexts bound to this drawable */
+	PVRQHead            sPVRContextHead;
+
+	/* Mutex for this drawable */
+	pthread_mutex_t     sMutex;
+
+	/* IMG Pixel format for this drawable */
+	IMG_PIXFMT          ePixelFormat;
+
+	/* Indicates the drawable info is invalid */
+	bool                bDrawableInfoInvalid;
+
+	/* Indicates updated drawable info is available */
+	bool                bDrawableInfoUpdated;
+
+	/* Buffer cache handle */
+	PVRObjectCache      hBufferCache;
+
+	/* Queue of buffers evicted from cache, waiting for flush */
+	PVRQHead            sCacheFlushHead;
+
+	union {
+		struct {
+			__DRIbuffer	sDRI;
+			int		w;
+			int		h;
+		} sBuffer;
+		struct {
+			__DRIimage	*psDRI;
+		} sImage;
+	} uDRI;
+	PVRDRIDrawableImpl *psImpl;
+} PVRDRIDrawable;
+
+typedef enum PVRDRIBufferBackingType_TAG
+{
+	PVRDRI_BUFFER_BACKING_INVALID = 0,
+	PVRDRI_BUFFER_BACKING_DRI2,
+	PVRDRI_BUFFER_BACKING_IMAGE,
+} PVRDRIBufferBackingType;
+
+typedef struct PVRDRIBuffer_TAG
+{
+	PVRDRIBufferBackingType eBackingType;
+
+	union
+	{
+		struct
+		{
+			uint32_t uiName;
+			PVRDRIBufferImpl *psBuffer;
+
+		} sDRI2;
+
+		struct
+		{
+			__DRIimage *psImage;
+		} sImage;
+	} uBacking;
+
+	PVRQElem sCacheFlushElem;
+} PVRDRIBuffer;
+
+typedef struct PVRDRIImageFormat_TAG
+{
+	IMG_PIXFMT eIMGPixelFormat;
+	int iDRIFourCC;
+	int iDRIFormat;
+	int iDRIComponents;
+	unsigned uiNumPlanes;
+	struct
+	{
+		IMG_PIXFMT eIMGPixelFormat;
+		int iDRIFormat;
+		unsigned int uiWidthShift;
+		unsigned int uiHeightShift;
+	} sPlanes[DRI_PLANES_MAX];
+} PVRDRIImageFormat;
+
+
+/*************************************************************************/ /*!
+ pvrdri.c
+*/ /**************************************************************************/
+
+void PVRDRIDrawableLock(PVRDRIDrawable *psPVRDrawable);
+void PVRDRIDrawableUnlock(PVRDRIDrawable *psPVRDrawable);
+
+void PVRDRIScreenLock(PVRDRIScreen *psPVRScreen);
+void PVRDRIScreenUnlock(PVRDRIScreen *psPVRScreen);
+
+PVRDRIScreen *PVRDRIThreadGetCurrentScreen(void);
+void PVRDRIThreadSetCurrentScreen(PVRDRIScreen *psPVRScreen);
+
+bool PVRDRIFlushBuffersForSwap(PVRDRIContext *psPVRContext,
+                               PVRDRIDrawable *psPVRDrawable);
+
+/*************************************************************************/ /*!
+ pvrutil.c
+*/ /**************************************************************************/
+void __attribute__((format(printf, 1, 2))) __driUtilMessage(const char *f, ...);
+void __attribute__((format(printf, 1, 2))) errorMessage(const char *f, ...);
+
+void *PVRDRILoadAPILib(const char *name);
+
+bool PVRDRILoadLibOGL(PVRDRIScreen *psPVRScreen);
+bool PVRDRILoadLibOGLES2(PVRDRIScreen *psPVRScreen);
+bool PVRDRILoadLibOGLES1(PVRDRIScreen *psPVRScreen);
+bool PVRDRILoadLibOCL(PVRDRIScreen *psPVRScreen);
+
+const __DRIconfig **PVRDRICreateConfigs(void);
+
+const PVRDRIImageFormat *PVRDRIFormatToImageFormat(int iDRIFormat);
+const PVRDRIImageFormat *PVRDRIFourCCToImageFormat(int iDRIFourCC);
+const PVRDRIImageFormat *PVRDRIIMGPixelFormatToImageFormat(IMG_PIXFMT eIMGPixelFormat);
+
+IMG_YUV_COLORSPACE PVRDRIToIMGColourSpace(const PVRDRIImageFormat *psFormat,
+					  enum __DRIYUVColorSpace eDRIColourSpace,
+					  enum __DRISampleRange eDRISampleRange);
+IMG_YUV_CHROMA_INTERP PVRDRIChromaSittingToIMGInterp(const PVRDRIImageFormat *psFormat,
+						     enum __DRIChromaSiting eChromaSitting);
+
+
+/*************************************************************************/ /*!
+ pvrdrawable.c
+*/ /**************************************************************************/
+
+bool PVRDRIDrawableInit(PVRDRIDrawable *psPVRDrawable);
+void PVRDRIDrawableDeinit(PVRDRIDrawable *psPVRDrawable);
+
+/* Callbacks into non-impl layer */
+bool PVRDRIDrawableUpdateNativeInfo(PVRDRIDrawable *psPVRDrawable);
+bool PVRDRIDrawableCreate(PVRDRIDrawable *psPVRDrawable);
+bool PVRDRIDrawableRecreate(PVRDRIDrawable *psPVRDrawable);
+PVRDRIBufferImpl *PVRDRIDrawableGetDstBuffer(PVRDRIDrawable *psPVRDrawable);
+PVRDRIBufferImpl *PVRDRIDrawableGetAccumBuffer(PVRDRIDrawable *psPVRDrawable);
+bool PVRDRIDrawableGetParameters(PVRDRIDrawable *psPVRDrawable,
+                                 PVRDRIBufferImpl **psDstBuffer,
+                                 PVRDRIBufferImpl **psAccumBuffer,
+                                 PVRDRIBufferAttribs *psAttribs,
+                                 bool *pbDoubleBuffered);
+
+PVRDRIImageType PVRDRIImageGetSharedType(__DRIimage *image);
+PVRDRIBufferImpl *PVRDRIImageGetSharedBuffer(__DRIimage *image);
+_EGLImage *PVRDRIImageGetSharedEGLImage(__DRIimage *image);
+_EGLImage *PVRDRIImageGetEGLImage(__DRIimage *image);
+
+__DRIimage *PVRDRIScreenGetDRIImage(void *hEGLImage);
+void PVRDRIRefImage(__DRIimage *image);
+void PVRDRIUnrefImage(__DRIimage *image);
+
+#endif /* defined(__PVRDRI2_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvrext.c b/src/mesa/drivers/dri/pvr/pvrext.c
new file mode 100644
index 0000000..18b2417
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrext.c
@@ -0,0 +1,332 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File           
+@Title          PVR DRI driver extension support
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+/*
+ * EXTENSION SUPPORT
+ *
+ * As the driver supports a range of Mesa versions it can be the case that it
+ * needs to support different extensions and extension versions depending on
+ * the version of Mesa that it's built against. As a guide the following rules
+ * should be followed:
+ *
+ * 1) If an extension appears in some supported versions of Mesa but not others
+ *    then it should be protected by the extension define, e.g.:
+ *    #if defined(__DRI_IMAGE)
+ *    <code>
+ *    #endif
+ *
+ *    However, if it appears in all versions then there's no need for it to
+ *    be protected.
+ *
+ * 2) Each driver supported extension should have a define for the maximum
+ *    version supported by the driver. This should be used when initialising
+ *    the corresponding extension structure. The Mesa extension version define
+ *    should *NOT* be used.
+ *
+ * 3) If the driver supports a range of versions for a given extension then
+ *    it should protect the extension code based on the Mesa extension version
+ *    define. For example, if the driver has to support versions 7 to 8 of the
+ *    __DRI_IMAGE extension then any fields, in the __DRIimageExtension
+ *    structure, that appear in version 8 but not 7 should be protected as
+ *    follows:
+ *    #if (__DRI_IMAGE_VERSION >= 8)
+ *    .createImageFromDmaBufs = PVRDRICreateImageFromDmaBufs,
+ *    #endif
+ *
+ *    Obviously any other associated code should also be protected in the same
+ *    way.
+ */
+
+#include "dri_util.h"
+
+#include "pvrimage.h"
+#include "pvrsyncobj.h"
+
+/* Maximum version numbers for each supported extension */
+#define PVR_DRI_TEX_BUFFER_VERSION	2
+#define PVR_DRI2_FLUSH_VERSION		4
+#define PVR_DRI_IMAGE_VERSION		8
+#define PVR_DRI2_ROBUSTNESS_VERSION	1
+#define PVR_DRI_PRIORITY_VERSION	1
+#define PVR_DRI2_FENCE_VERSION		1
+
+/* IMG extension */
+#define	PVR_DRI_QUERY_BUFFERS_VERSION	1
+
+static void PVRDRIFlushAllContexts(PVRDRIDrawable *psPVRDrawable)
+{
+	PVRQElem *psQElem;
+
+	PVRDRIDrawableLock(psPVRDrawable);
+	psQElem = psPVRDrawable->sPVRContextHead.pvForw;
+
+	while (psQElem != &psPVRDrawable->sPVRContextHead)
+	{
+		PVRDRIContext *psPVRContext = PVRQ_CONTAINER_OF(psQElem, PVRDRIContext, sQElem);
+		PVRDRIEGLFlushBuffers(psPVRContext->eAPI,
+		                      psPVRContext->psPVRScreen->psImpl,
+		                      psPVRContext->psImpl,
+		                      psPVRDrawable->psImpl,
+		                      false,
+		                      false,
+		                      false);
+		psQElem = psPVRContext->sQElem.pvForw;
+	}
+
+	PVRDRIDrawableUnlock(psPVRDrawable);
+}
+
+static void PVRDRIExtSetTexBuffer(__DRIcontext  *psDRIContext,
+				  GLint          target,
+				  GLint          format,
+				  __DRIdrawable *psDRIDrawable)
+{
+	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
+	PVRDRIContext *psPVRContext = (PVRDRIContext *)psDRIContext->driverPrivate;
+
+	(void)target;
+	(void)format;
+
+	if (!psPVRDrawable->bInitialised)
+	{
+		if (!PVRDRIDrawableInit(psPVRDrawable))
+		{
+			__driUtilMessage("%s: Couldn't initialise pixmap", __func__);
+			return;
+		}
+	}
+
+	PVRDRIFlushAllContexts(psPVRDrawable);
+	PVRDRI2BindTexImage(psPVRContext->eAPI,
+	                    psPVRContext->psPVRScreen->psImpl,
+	                    psPVRContext->psImpl,
+	                    psPVRDrawable->psImpl);
+}
+
+static void PVRDRIExtReleaseTexBuffer(__DRIcontext  *psDRIContext,
+				      GLint          target,
+				      __DRIdrawable *psDRIDrawable)
+{
+	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
+	PVRDRIContext *psPVRContext = (PVRDRIContext *)psDRIContext->driverPrivate;
+
+	(void)target;
+
+	PVRDRI2ReleaseTexImage(psPVRContext->eAPI,
+	                       psPVRContext->psPVRScreen->psImpl,
+	                       psPVRContext->psImpl,
+	                       psPVRDrawable->psImpl);
+}
+
+static __DRItexBufferExtension pvrDRITexBufferExtension =
+{
+	.base			= { .name = __DRI_TEX_BUFFER, .version = PVR_DRI_TEX_BUFFER_VERSION },
+	.setTexBuffer		= NULL,
+	.setTexBuffer2		= PVRDRIExtSetTexBuffer,
+	.releaseTexBuffer	= PVRDRIExtReleaseTexBuffer
+};
+
+
+static void PVRDRI2Flush(__DRIdrawable *psDRIDrawable)
+{
+	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
+
+	PVRDRIDrawableLock(psPVRDrawable);
+
+	(void) PVRDRIFlushBuffersForSwap(NULL, psPVRDrawable);
+	/*
+	 * Work around for missing X Server invalidate events. Mark
+	 * the drawable as invalid, to force a query for new buffers.
+	 */
+	psPVRDrawable->bDrawableInfoInvalid = true;
+
+	PVRDRIDrawableUnlock(psPVRDrawable);
+}
+
+static void PVRDRI2Invalidate(__DRIdrawable *psDRIDrawable)
+{
+	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
+
+	if (psPVRDrawable->psPVRScreen->bUseInvalidate)
+	{
+		PVRDRIDrawableLock(psPVRDrawable);
+		psPVRDrawable->bDrawableInfoInvalid = true;
+		psPVRDrawable->bDrawableInfoUpdated = false;
+		PVRDRIDrawableUnlock(psPVRDrawable);
+	}
+}
+
+static void PVRDRI2FlushWithFlags(__DRIcontext *psDRIContext,
+				  __DRIdrawable *psDRIDrawable,
+				  unsigned uFlags,
+				  enum __DRI2throttleReason eThrottleReason)
+{
+	PVRDRIContext *psPVRContext = (PVRDRIContext *)psDRIContext->driverPrivate;
+
+	(void)eThrottleReason;
+
+	if ((uFlags & __DRI2_FLUSH_DRAWABLE) != 0)
+	{
+		PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *) psDRIDrawable->driverPrivate;
+
+		PVRDRIDrawableLock(psPVRDrawable);
+
+		(void) PVRDRIFlushBuffersForSwap(psPVRContext, psPVRDrawable);
+		/*
+		 * Work around for missing X Server invalidate events. Mark
+		 * the drawable as invalid, to force a query for new buffers.
+		 */
+		psPVRDrawable->bDrawableInfoInvalid = true;
+
+		PVRDRIDrawableUnlock(psPVRDrawable);
+	}
+	else if ((uFlags & __DRI2_FLUSH_CONTEXT) != 0)
+	{
+		(void) PVRDRIEGLFlushBuffers(psPVRContext->eAPI,
+		                             psPVRContext->psPVRScreen->psImpl,
+					     psPVRContext->psImpl,
+		                             NULL, true, false, false);
+	}
+}
+
+static __DRI2flushExtension pvrDRI2FlushExtension =
+{
+	.base			= { .name = __DRI2_FLUSH, .version = PVR_DRI2_FLUSH_VERSION },
+	.flush			= PVRDRI2Flush,
+	.invalidate		= PVRDRI2Invalidate,
+	.flush_with_flags	= PVRDRI2FlushWithFlags,
+};
+
+
+static __DRIimageExtension pvrDRIImage =
+{
+	.base				= { .name = __DRI_IMAGE, .version = PVR_DRI_IMAGE_VERSION },
+	.createImageFromName		= PVRDRICreateImageFromName,
+	.createImageFromRenderbuffer	= PVRDRICreateImageFromRenderbuffer,
+	.destroyImage			= PVRDRIDestroyImage,
+	.createImage			= PVRDRICreateImage,
+	.queryImage			= PVRDRIQueryImage,
+	.dupImage			= PVRDRIDupImage,
+	.validateUsage			= PVRDRIValidateUsage,
+	.createImageFromNames		= PVRDRICreateImageFromNames,
+	.fromPlanar			= PVRDRIFromPlanar,
+	.createImageFromTexture		= PVRDRICreateImageFromTexture,
+	.createImageFromFds		= PVRDRICreateImageFromFds,
+#if defined(PVR_OCL_LIB)
+	.createImageFromBuffer		= PVRDRICreateImageFromBuffer,
+#endif
+	.createImageFromDmaBufs		= PVRDRICreateImageFromDmaBufs,
+};
+
+static __DRIrobustnessExtension pvrDRIRobustness =
+{
+	.base = { .name = __DRI2_ROBUSTNESS, .version = PVR_DRI2_ROBUSTNESS_VERSION }
+};
+
+#if defined(__DRI_PRIORITY)
+static __DRIpriorityExtension pvrDRIPriority =
+{
+	.base = { .name = __DRI_PRIORITY, .version = PVR_DRI_PRIORITY_VERSION }
+};
+#endif /* defined(__DRI_PRIORITY) */
+
+
+#if defined(__DRI2_FENCE)
+const __DRI2fenceExtension pvrDRIFenceExtension =
+{
+	.base				= { .name = __DRI2_FENCE, .version = PVR_DRI2_FENCE_VERSION },
+	.create_fence			= PVRDRICreateFence,
+	/* Not currently supported */
+	.get_fence_from_cl_event	= NULL,
+	.destroy_fence			= PVRDRIDestroyFence,
+	.client_wait_sync		= PVRDRIClientWaitSync,
+	.server_wait_sync		= PVRDRIServerWaitSync,
+};
+#endif /* defined(__DRI2_FENCE) */
+
+
+#if defined(__DRI_QUERY_BUFFERS)
+static void PVRDRIQueryBuffersEXT(__DRIdrawable *psDRIDrawable)
+{
+	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
+
+	PVRDRIDrawableLock(psPVRDrawable);
+	psPVRDrawable->bDrawableInfoUpdated =
+		 PVRDRIDrawableUpdateNativeInfo(psPVRDrawable);
+	PVRDRIDrawableUnlock(psPVRDrawable);
+}
+
+static __DRIqueryBuffersExtension pvrDRIQueryBuffers = 
+{
+	.base		= { .name = __DRI_QUERY_BUFFERS, .version = PVR_DRI_QUERY_BUFFERS_VERSION },
+	.query_buffers = PVRDRIQueryBuffersEXT
+};
+#endif /* defined(__DRI_QUERY_BUFFERS) */
+
+/*
+ * Extension lists
+ *
+ * NOTE: When adding a new screen extension asScreenExtensionVersionInfo
+ *       should also be updated accordingly.
+ */
+const __DRIextension *apsScreenExtensions[] =
+{
+	&pvrDRITexBufferExtension.base,
+	&pvrDRI2FlushExtension.base,
+	&pvrDRIImage.base,
+	&pvrDRIRobustness.base,
+#if defined(__DRI_PRIORITY)
+	&pvrDRIPriority.base,
+#endif
+#if defined(__DRI2_FENCE)
+	&pvrDRIFenceExtension.base,
+#endif
+#if defined(__DRI_QUERY_BUFFERS)
+	&pvrDRIQueryBuffers.base,
+#endif
+	NULL
+};
+
+const __DRIextension asScreenExtensionVersionInfo[] =
+{
+	{ .name = __DRI_TEX_BUFFER, .version = __DRI_TEX_BUFFER_VERSION },
+	{ .name = __DRI2_FLUSH, .version = __DRI2_FLUSH_VERSION },
+	{ .name = __DRI_IMAGE, .version = __DRI_IMAGE_VERSION },
+	{ .name = __DRI2_ROBUSTNESS, .version = __DRI2_ROBUSTNESS_VERSION },
+#if defined(__DRI_PRIORITY)
+	{ .name = __DRI_PRIORITY, .version = __DRI_PRIORITY_VERSION },
+#endif
+#if defined(__DRI2_FENCE)
+	{ .name = __DRI2_FENCE, .version = __DRI2_FENCE_VERSION },
+#endif
+#if defined(__DRI_QUERY_BUFFERS)
+	{ .name = __DRI_QUERY_BUFFERS, .version = __DRI_QUERY_BUFFERS_VERSION },
+#endif
+	{ .name = NULL, .version = 0 },
+};
diff --git a/src/mesa/drivers/dri/pvr/pvrimage.c b/src/mesa/drivers/dri/pvr/pvrimage.c
new file mode 100644
index 0000000..f912cc4
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrimage.c
@@ -0,0 +1,1084 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          DRI IMAGE extension
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include <assert.h>
+#include <xf86drm.h>
+
+#include "dri_util.h"
+
+#include "imgpixfmts.h"
+#include "pvrdri.h"
+#include "pvrimage.h"
+#include "EGL/eglext.h"
+
+struct PVRDRIImageShared
+{
+	int iRefCount;
+
+	PVRDRIScreen *psPVRScreen;
+
+	PVRDRIImageType eType;
+	const PVRDRIImageFormat *psFormat;
+	IMG_YUV_COLORSPACE eColourSpace;
+	IMG_YUV_CHROMA_INTERP eChromaUInterp;
+	IMG_YUV_CHROMA_INTERP eChromaVInterp;
+
+	PVRDRIBufferImpl *apsBuffers[DRI_PLANES_MAX];
+	_EGLImage *psEGLImage;
+};
+
+struct __DRIimageRec
+{
+	int iRefCount;
+
+	void *loaderPrivate;
+
+	struct PVRDRIImageShared *psShared;
+
+	_EGLImage *psEGLImage;
+};
+
+
+static struct PVRDRIImageShared *
+CommonImageSharedSetup(PVRDRIImageType eType,
+                       __DRIscreen *screen)
+{
+	struct PVRDRIImageShared *shared;
+
+	shared = calloc(1, sizeof(*shared));
+	if (!shared)
+	{
+		return NULL;
+	}
+
+	shared->psPVRScreen = DRIScreenPrivate(screen);
+	shared->eType = eType;
+	shared->iRefCount = 1;
+
+	assert(shared->eColourSpace == IMG_COLORSPACE_UNDEFINED &&
+	       shared->eChromaUInterp == IMG_CHROMA_INTERP_UNDEFINED &&
+	       shared->eChromaVInterp == IMG_CHROMA_INTERP_UNDEFINED);
+
+	return shared;
+}
+
+static void DestroyImageShared(struct PVRDRIImageShared *shared)
+{
+	int iRefCount = __sync_sub_and_fetch(&shared->iRefCount, 1);
+	int i;
+
+	assert(iRefCount >= 0);
+
+	if (iRefCount > 0)
+	{
+		return;
+	}
+
+	switch (shared->eType)
+	{
+		case PVRDRI_IMAGE_FROM_NAMES:
+		case PVRDRI_IMAGE_FROM_DMABUFS:
+			for (i = 0; i < ARRAY_SIZE(shared->apsBuffers); i++)
+			{
+				if (shared->apsBuffers[i])
+				{
+					PVRDRIBufferDestroy(shared->apsBuffers[i]);
+				}
+			}
+			break;
+		case PVRDRI_IMAGE:
+			PVRDRIBufferDestroy(shared->apsBuffers[0]);
+			break;
+		case PVRDRI_IMAGE_FROM_EGLIMAGE:
+			PVRDRIEGLImageDestroyExternal(shared->psPVRScreen->psImpl,
+			                              shared->psEGLImage);
+			break;
+		default:
+			errorMessage("%s: Unknown image type: %d\n", __func__, (int)shared->eType);
+			break;
+	}
+
+	free(shared);
+}
+
+static struct PVRDRIImageShared *
+CreateImageSharedFromEGLImage(__DRIscreen *screen,
+                              _EGLImage *psEGLImage)
+{
+	struct PVRDRIImageShared *shared;
+	PVRDRIBufferAttribs sAttribs;
+	const PVRDRIImageFormat *psFormat;
+
+	PVRDRIEGLImageGetAttribs(psEGLImage, &sAttribs);
+
+	psFormat = PVRDRIIMGPixelFormatToImageFormat(sAttribs.ePixFormat);
+	if (!psFormat)
+	{
+		return NULL;
+	}
+
+	shared = CommonImageSharedSetup(PVRDRI_IMAGE_FROM_EGLIMAGE, screen);
+	if (!shared)
+	{
+		return NULL;
+	}
+
+	shared->psEGLImage = psEGLImage;
+	shared->psFormat = psFormat;
+
+	return shared;
+}
+
+static struct PVRDRIImageShared *
+CreateImageSharedFromNames(__DRIscreen *screen,
+			   int width,
+			   int height,
+			   int fourcc,
+			   int *names,
+			   int num_names,
+			   int *strides,
+			   int *offsets)
+{
+	struct PVRDRIImageShared *shared;
+	const PVRDRIImageFormat *psFormat;
+	int i;
+
+	psFormat = PVRDRIFourCCToImageFormat(fourcc);
+	if (!psFormat)
+	{
+		errorMessage("%s: Unsupported DRI FourCC (fourcc = 0x%X)\n",
+			     __func__, fourcc);
+		return NULL;
+	}
+
+	if (psFormat->uiNumPlanes < num_names)
+	{
+		errorMessage("%s: Unexpected number of names for DRI FourCC (names = %d, fourcc = 0x%X)\n",
+			     __func__, num_names, fourcc);
+		return NULL;
+	}
+
+	for (i = 0; i < num_names; i++)
+	{
+		if (offsets[i] < 0)
+		{
+			errorMessage("%s: Offset %d unsupported (value = %d)\n",
+				     __func__, i, offsets[i]);
+			return NULL;
+		}
+	}
+
+	shared = CommonImageSharedSetup(PVRDRI_IMAGE_FROM_NAMES, screen);
+	if (!shared)
+	{
+		return NULL;
+	}
+
+	for (i = 0; i < num_names; i++)
+	{
+		shared->apsBuffers[i] =
+			PVRDRIBufferCreateFromName(shared->psPVRScreen->psImpl,
+						   names[i],
+						   width >> psFormat->sPlanes[i].uiWidthShift,
+						   height >> psFormat->sPlanes[i].uiHeightShift,
+						   strides[i],
+						   offsets[i]);
+		if (!shared->apsBuffers[i])
+		{
+			errorMessage("%s: Failed to create plane %d for shared image\n", __func__, i);
+			goto ErrorDestroyImage;
+		}
+	}
+
+	shared->psFormat = psFormat;
+	shared->eColourSpace = PVRDRIToIMGColourSpace(psFormat,
+						      __DRI_YUV_COLOR_SPACE_UNDEFINED,
+						      __DRI_YUV_RANGE_UNDEFINED);
+	shared->eChromaUInterp = PVRDRIChromaSittingToIMGInterp(psFormat,
+								__DRI_YUV_RANGE_UNDEFINED);
+	shared->eChromaVInterp = PVRDRIChromaSittingToIMGInterp(psFormat,
+								__DRI_YUV_RANGE_UNDEFINED);
+
+	return shared;
+
+ErrorDestroyImage:
+	DestroyImageShared(shared);
+
+	return NULL;
+}
+
+static struct PVRDRIImageShared *
+CreateImageSharedFromDmaBufs(__DRIscreen *screen,
+			     int width,
+			     int height,
+			     int fourcc,
+			     int *fds,
+			     int num_fds,
+			     int *strides,
+			     int *offsets,
+			     enum __DRIYUVColorSpace color_space,
+			     enum __DRISampleRange sample_range,
+			     enum __DRIChromaSiting horiz_siting,
+			     enum __DRIChromaSiting vert_siting,
+			     unsigned *error)
+{
+	struct PVRDRIImageShared *shared;
+	const PVRDRIImageFormat *psFormat;
+	int i;
+
+	psFormat = PVRDRIFourCCToImageFormat(fourcc);
+	if (!psFormat)
+	{
+		errorMessage("%s: Unsupported DRI FourCC (fourcc = 0x%X)\n",
+			     __func__, fourcc);
+		*error = __DRI_IMAGE_ERROR_BAD_MATCH;
+		return NULL;
+	}
+
+	if (psFormat->uiNumPlanes < num_fds)
+	{
+		errorMessage("%s: Unexpected number of fds for format (fds = %d, fourcc = 0x%X)\n",
+			     __func__, num_fds, fourcc);
+		*error = __DRI_IMAGE_ERROR_BAD_MATCH;
+		return NULL;
+	}
+
+	for (i = 0; i < num_fds; i++)
+	{
+		if (offsets[i] < 0)
+		{
+			errorMessage("%s: Offset %d unsupported (value = %d)\n",
+				     __func__, i, offsets[i]);
+			*error = __DRI_IMAGE_ERROR_BAD_ACCESS;
+			return NULL;
+		}
+	}
+
+	shared = CommonImageSharedSetup(PVRDRI_IMAGE_FROM_DMABUFS, screen);
+	if (!shared)
+	{
+		*error = __DRI_IMAGE_ERROR_BAD_ALLOC;
+		return NULL;
+	}
+
+	for (i = 0; i < num_fds; i++)
+	{
+		shared->apsBuffers[i] =
+			PVRDRIBufferCreateFromFd(shared->psPVRScreen->psImpl,
+						 fds[i],
+						 width >> psFormat->sPlanes[i].uiWidthShift,
+						 height >> psFormat->sPlanes[i].uiHeightShift,
+						 strides[i],
+						 offsets[i]);
+		if (!shared->apsBuffers[i])
+		{
+			errorMessage("%s: Failed to create plane %d for shared image\n", __func__, i);
+			*error = __DRI_IMAGE_ERROR_BAD_ALLOC;
+			goto ErrorDestroyImage;
+		}
+	}
+
+	shared->psFormat = psFormat;
+	shared->eColourSpace = PVRDRIToIMGColourSpace(psFormat, color_space, sample_range);
+	shared->eChromaUInterp = PVRDRIChromaSittingToIMGInterp(psFormat, horiz_siting);
+	shared->eChromaVInterp = PVRDRIChromaSittingToIMGInterp(psFormat, vert_siting);
+
+	return shared;
+
+ErrorDestroyImage:
+	DestroyImageShared(shared);
+
+	return NULL;
+}
+
+static struct PVRDRIImageShared *
+CreateImageShared(__DRIscreen *screen,
+                  int width,
+                  int height,
+                  int format,
+                  unsigned int use,
+                  int *piStride)
+{
+	struct PVRDRIImageShared *shared;
+	const PVRDRIImageFormat *psFormat;
+	unsigned int uiStride;
+
+	if ((use & __DRI_IMAGE_USE_CURSOR) && (use & __DRI_IMAGE_USE_SCANOUT))
+	{
+		return NULL;
+	}
+
+	psFormat = PVRDRIFormatToImageFormat(format);
+	if (!psFormat)
+	{
+		errorMessage("%s: Unsupported DRI image format (format = 0x%X)\n",
+			     __func__, format);
+		return NULL;
+	}
+
+	shared = CommonImageSharedSetup(PVRDRI_IMAGE, screen);
+	if (!shared)
+	{
+		return NULL;
+	}
+
+	shared->apsBuffers[0] =
+		PVRDRIBufferCreate(shared->psPVRScreen->psImpl,
+				   width,
+				   height,
+				   PVRDRIPixFmtGetBPP(psFormat->eIMGPixelFormat),
+				   use,
+				   &uiStride);
+	if (!shared->apsBuffers[0])
+	{
+		errorMessage("%s: Failed to create buffer\n", __func__);
+		goto ErrorDestroyImage;
+	}
+
+	shared->psFormat = psFormat;
+
+	*piStride = uiStride;
+
+	return shared;
+
+ErrorDestroyImage:
+	DestroyImageShared(shared);
+
+	return NULL;
+}
+
+static struct PVRDRIImageShared *RefImageShared(struct PVRDRIImageShared *shared)
+{
+	int iRefCount = __sync_fetch_and_add(&shared->iRefCount, 1);
+
+	(void)iRefCount;
+	assert(iRefCount > 0);
+
+	return shared;
+}
+
+static __DRIimage *CommonImageSetup(void *loaderPrivate)
+{
+	struct __DRIimageRec *image;
+
+	image = calloc(1, sizeof(*image));
+	if (!image)
+	{
+		return NULL;
+	}
+
+	image->loaderPrivate = loaderPrivate;
+	image->iRefCount = 1;
+
+	return image;
+}
+
+void PVRDRIDestroyImage(__DRIimage *image)
+{
+	int iRefCount = __sync_sub_and_fetch(&image->iRefCount, 1);
+
+	assert(iRefCount >= 0);
+
+	if (iRefCount > 0)
+	{
+		return;
+	}
+
+	if (image->psShared)
+	{
+		DestroyImageShared(image->psShared);
+	}
+
+	PVRDRIEGLImageFree(image->psEGLImage);
+	free(image);
+}
+
+__DRIimage *PVRDRICreateImageFromName(__DRIscreen *screen,
+				      int width, int height, int format,
+				      int name, int pitch,
+				      void *loaderPrivate)
+{
+	const PVRDRIImageFormat *psFormat;
+	int iStride;
+	int iOffset;
+
+	psFormat = PVRDRIFormatToImageFormat(format);
+	if (!psFormat)
+	{
+		errorMessage("%s: Unsupported DRI image format (format = 0x%X)\n",
+			     __func__, format);
+		return NULL;
+	}
+
+	iStride = pitch * PVRDRIPixFmtGetBlockSize(psFormat->eIMGPixelFormat);
+	iOffset = 0;
+
+	return PVRDRICreateImageFromNames(screen, width, height, psFormat->iDRIFourCC,
+					  &name, 1, &iStride, &iOffset, loaderPrivate);
+}
+
+static PVRDRIImageError GetImageSourceError(PVRDRIImageError e)
+{
+	switch (e)
+	{
+		case PVRDRI_IMAGE_ERROR_SUCCESS:
+			return __DRI_IMAGE_ERROR_SUCCESS;
+		case PVRDRI_IMAGE_ERROR_BAD_PARAMETER:
+			return __DRI_IMAGE_ERROR_BAD_PARAMETER;
+		case PVRDRI_IMAGE_ERROR_BAD_MATCH:
+			return __DRI_IMAGE_ERROR_BAD_MATCH;
+		case PVRDRI_IMAGE_ERROR_BAD_ALLOC:
+			return __DRI_IMAGE_ERROR_BAD_ALLOC;
+		case PVRDRI_IMAGE_ERROR_BAD_ACCESS:
+			return __DRI_IMAGE_ERROR_BAD_ACCESS;
+		default:
+			return __DRI_IMAGE_ERROR_BAD_MATCH;
+	}
+}
+
+/*
+ * Calling GetImageSourceOCL adds a reference to the resulting EGLImage.
+ * Bump the reference count on the image after calling this function.
+ */
+static PVRDRIImageError
+GetImageSourceOCL(PVRDRIContext *psPVRContext,
+                  uint32_t target,
+                  void *buffer,
+                  _EGLImage *psEGLImage)
+{
+	PVRDRIImageError e;
+	PVRDRIScreen *psPVRScreen = psPVRContext->psPVRScreen;
+
+	if (!PVRDRILoadLibOCL(psPVRScreen))
+	{
+		return __DRI_IMAGE_ERROR_BAD_MATCH;
+	}
+
+	if (!PVRDRIEGLGetOCLFunctionTable(psPVRScreen->psImpl, psPVRScreen->pvLibHandleOCL))
+	{
+		return __DRI_IMAGE_ERROR_BAD_MATCH;
+	}
+
+	e = PVRDRIGetImageSourceOCL(psPVRScreen->psImpl,
+	                            target,
+	                            buffer,
+	                            psEGLImage);
+
+	return GetImageSourceError(e);
+}
+
+__DRIimage *PVRDRICreateImageFromRenderbuffer(__DRIcontext *context,
+                                              int           renderbuffer,
+                                              void         *loaderPrivate)
+{
+	PVRDRIContext *psPVRContext = context->driverPrivate;
+	__DRIscreen *screen = psPVRContext->psPVRScreen->psDRIScreen;
+	PVRDRIImageError e;
+	_EGLImage *psEGLImage;
+	struct __DRIimageRec *image;
+
+	image = CommonImageSetup(loaderPrivate);
+	if (!image)
+	{
+		return NULL;
+	}
+
+	psEGLImage = PVRDRIEGLImageCreate();
+	if (!psEGLImage)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	e = PVRDRIGetImageSource(psPVRContext->eAPI,
+	                         psPVRContext->psPVRScreen->psImpl,
+	                         psPVRContext->psImpl,
+	                         EGL_GL_RENDERBUFFER_KHR,
+	                         (uintptr_t)renderbuffer,
+	                         0,
+	                         psEGLImage);
+
+	if (e != PVRDRI_IMAGE_ERROR_SUCCESS)
+	{
+		PVRDRIEGLImageFree(psEGLImage);
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	PVRDRIEGLImageSetCallbackData(psEGLImage, image);
+	
+	/*
+	 * We can't destroy the image after this point, as the
+	 * renderbuffer now has a reference to it.
+	 */
+	image->psShared = CreateImageSharedFromEGLImage(screen, psEGLImage);
+	if (!image->psShared)
+	{
+		return NULL;
+	}
+
+	image->psEGLImage = PVRDRIEGLImageDup(image->psShared->psEGLImage);
+	if (!image->psEGLImage)
+	{
+		return NULL;
+	}
+
+	image->iRefCount++;
+
+	return image;
+}
+
+__DRIimage *PVRDRICreateImage(__DRIscreen *screen,
+			      int width, int height, int format,
+			      unsigned int use,
+			      void *loaderPrivate)
+{
+	struct __DRIimageRec *image;
+	int iStride;
+
+	image = CommonImageSetup(loaderPrivate);
+	if (!image)
+	{
+		return NULL;
+	}
+
+	image->psShared = CreateImageShared(screen, width, height, format, use, &iStride);
+	if (!image->psShared)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	image->psEGLImage = PVRDRIEGLImageCreateFromBuffers(width, height, iStride,
+							    image->psShared->psFormat->eIMGPixelFormat,
+							    image->psShared->eColourSpace,
+							    image->psShared->eChromaUInterp,
+							    image->psShared->eChromaUInterp,
+							    &image->psShared->apsBuffers[0],
+							    1);
+	if (!image->psEGLImage)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	PVRDRIEGLImageSetCallbackData(image->psEGLImage, image);
+
+	return image;
+}
+
+GLboolean PVRDRIQueryImage(__DRIimage *image, int attrib, int *value_ptr)
+{
+	struct PVRDRIImageShared *shared = image->psShared;
+	PVRDRIBufferAttribs sAttribs;
+	int value;
+
+	PVRDRIEGLImageGetAttribs(image->psEGLImage, &sAttribs);
+
+	if (attrib == __DRI_IMAGE_ATTRIB_HANDLE ||
+	    attrib == __DRI_IMAGE_ATTRIB_NAME ||
+	    attrib == __DRI_IMAGE_ATTRIB_FD)
+	{
+		if (!shared->psFormat)
+		{
+			return GL_FALSE;
+		}
+
+		if (shared->psFormat->iDRIComponents != __DRI_IMAGE_COMPONENTS_RGBA &&
+		    shared->psFormat->iDRIComponents != __DRI_IMAGE_COMPONENTS_RGB)
+		{
+			return GL_FALSE;
+		}
+	}
+
+	switch (attrib)
+	{
+		case __DRI_IMAGE_ATTRIB_STRIDE:
+			*value_ptr = sAttribs.uiStrideInBytes;
+			break;
+		case __DRI_IMAGE_ATTRIB_HANDLE:
+			value = PVRDRIBufferGetHandle(shared->apsBuffers[0]);
+			if (value == -1)
+			{
+				return GL_FALSE;
+			}
+
+			*value_ptr = value;
+			break;
+		case __DRI_IMAGE_ATTRIB_NAME:
+			value = PVRDRIBufferGetName(shared->apsBuffers[0]);
+			if (value == -1)
+			{
+				return GL_FALSE;
+			}
+
+			*value_ptr = value;
+			break;
+		case __DRI_IMAGE_ATTRIB_FORMAT:
+			if (!shared->psFormat)
+			{
+				return GL_FALSE;
+			}
+
+			*value_ptr = shared->psFormat->iDRIFormat;
+			break;
+		case __DRI_IMAGE_ATTRIB_WIDTH:
+			*value_ptr = sAttribs.uiWidth;
+			break;
+		case __DRI_IMAGE_ATTRIB_HEIGHT:
+			*value_ptr = sAttribs.uiHeight;
+			break;
+		case __DRI_IMAGE_ATTRIB_COMPONENTS:
+			if (!shared->psFormat)
+			{
+				return GL_FALSE;
+			}
+
+			*value_ptr = shared->psFormat->iDRIComponents;
+			break;
+		case __DRI_IMAGE_ATTRIB_FD:
+			value = PVRDRIBufferGetFd(shared->apsBuffers[0]);
+			if (value == -1)
+			{
+				return GL_FALSE;
+			}
+
+			*value_ptr = value;
+			break;
+		default:
+			return GL_FALSE;
+	}
+
+	return GL_TRUE;
+}
+
+__DRIimage *PVRDRIDupImage(__DRIimage *srcImage, void *loaderPrivate)
+{
+	struct __DRIimageRec *image;
+
+	image = CommonImageSetup(loaderPrivate);
+	if (!image)
+	{
+		return NULL;
+	}
+
+	image->psShared = RefImageShared(srcImage->psShared);
+
+	image->psEGLImage = PVRDRIEGLImageDup(srcImage->psEGLImage);
+	if (!image->psEGLImage)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	PVRDRIEGLImageSetCallbackData(image->psEGLImage, image);
+
+	return image;
+}
+
+GLboolean PVRDRIValidateUsage(__DRIimage *image, unsigned int use)
+{
+	__DRIscreen *screen = image->psShared->psPVRScreen->psDRIScreen;
+
+	if (use & (__DRI_IMAGE_USE_SCANOUT | __DRI_IMAGE_USE_CURSOR))
+	{
+		/*
+		 * We are extra strict in this case as an application may ask for a
+		 * handle so that the memory can be wrapped as a framebuffer/used as
+		 * a cursor and this can only be done on a card node.
+		 */
+		if (drmGetNodeTypeFromFd(screen->fd) != DRM_NODE_PRIMARY)
+		{
+			return GL_FALSE;
+		}
+	}
+	else if (use & (__DRI_IMAGE_USE_SHARE))
+	{
+		/*
+		 * We are less strict in this case as it's possible to share buffers
+		 * using prime (but not flink) on a render node so we only need to know
+		 * whether or not the fd belongs to the display.
+		 */
+		if (PVRDRIGetDeviceTypeFromFd(screen->fd) != PVRDRI_DEVICE_TYPE_DISPLAY)
+		{
+			return GL_FALSE;
+		}
+	}
+
+	return GL_TRUE;
+}
+
+__DRIimage *PVRDRICreateImageFromNames(__DRIscreen *screen,
+				       int width, int height, int fourcc,
+				       int *names, int num_names,
+				       int *strides, int *offsets,
+				       void *loaderPrivate)
+{
+	struct __DRIimageRec *image;
+	int iStride;
+
+	image = CommonImageSetup(loaderPrivate);
+	if (!image)
+	{
+		return NULL;
+	}
+
+	image->psShared = CreateImageSharedFromNames(screen, width, height, fourcc,
+						     names, num_names, strides, offsets);
+	if (!image->psShared)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	if (image->psShared->psFormat->uiNumPlanes == 1)
+	{
+		iStride = strides[0];
+	}
+	else
+	{
+		iStride = width * PVRDRIPixFmtGetBlockSize(image->psShared->psFormat->eIMGPixelFormat);
+	}
+
+	image->psEGLImage = PVRDRIEGLImageCreateFromBuffers(width, height,
+							    iStride,
+							    image->psShared->psFormat->eIMGPixelFormat,
+							    image->psShared->eColourSpace,
+							    image->psShared->eChromaUInterp,
+							    image->psShared->eChromaVInterp,
+							    &image->psShared->apsBuffers[0],
+							    num_names);
+	if (!image->psEGLImage)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	PVRDRIEGLImageSetCallbackData(image->psEGLImage, image);
+
+	return image;
+}
+
+__DRIimage *PVRDRIFromPlanar(__DRIimage *image, int plane,
+			     void *loaderPrivate)
+{
+	if (plane != 0)
+	{
+		errorMessage("%s: plane %d not supported\n", __func__, plane);
+	}
+
+	return PVRDRIDupImage(image, loaderPrivate);
+}
+
+__DRIimage *
+PVRDRICreateImageFromTexture(__DRIcontext *context,
+                             int glTarget,
+                             unsigned texture,
+                             int depth,
+                             int level,
+                             unsigned *error,
+                             void *loaderPrivate)
+{
+	PVRDRIContext *psPVRContext = context->driverPrivate;
+	__DRIscreen *screen = psPVRContext->psPVRScreen->psDRIScreen;
+	_EGLImage *psEGLImage;
+	struct __DRIimageRec *image;
+	uint32_t eglTarget;
+	PVRDRIImageError e;
+
+	switch (glTarget)
+	{
+		case GL_TEXTURE_2D:
+			eglTarget = EGL_GL_TEXTURE_2D_KHR;
+			break;
+		case GL_TEXTURE_CUBE_MAP:
+			eglTarget = EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR + depth;
+			break;
+		default:
+			errorMessage("%s: GL Target %d is not supported\n", __func__, glTarget);
+			*error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
+			return NULL;
+	}
+
+	image = CommonImageSetup(loaderPrivate);
+	if (!image)
+	{
+		return NULL;
+	}
+
+	psEGLImage = PVRDRIEGLImageCreate();
+	if (!psEGLImage)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	e = PVRDRIGetImageSource(psPVRContext->eAPI,
+	                         psPVRContext->psPVRScreen->psImpl,
+	                         psPVRContext->psImpl,
+	                         eglTarget,
+	                         (uintptr_t)texture,
+	                         (uint32_t)level,
+	                         psEGLImage);
+	*error = GetImageSourceError(e);
+
+	if (e != PVRDRI_IMAGE_ERROR_SUCCESS)
+	{
+		PVRDRIEGLImageFree(psEGLImage);
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	PVRDRIEGLImageSetCallbackData(psEGLImage, image);
+
+	/*
+	 * We can't destroy the image after this point, as the
+	 * texture now has a reference to it.
+	 */
+	image->psShared = CreateImageSharedFromEGLImage(screen, psEGLImage);
+	if (!image->psShared)
+	{
+		return NULL;
+	}
+
+	image->psEGLImage = PVRDRIEGLImageDup(image->psShared->psEGLImage);
+	if (!image->psEGLImage)
+	{
+		return NULL;
+	}
+
+	image->iRefCount++;
+
+	return image;
+}
+
+__DRIimage *PVRDRICreateImageFromFds(__DRIscreen *screen,
+				     int width, int height, int fourcc,
+				     int *fds, int num_fds,
+				     int *strides, int *offsets,
+				     void *loaderPrivate)
+{
+	unsigned error;
+
+	return PVRDRICreateImageFromDmaBufs(screen, width, height, fourcc,
+					    fds, num_fds, strides, offsets,
+					    __DRI_YUV_COLOR_SPACE_UNDEFINED,
+					    __DRI_YUV_RANGE_UNDEFINED,
+					    __DRI_YUV_CHROMA_SITING_UNDEFINED,
+					    __DRI_YUV_CHROMA_SITING_UNDEFINED,
+					    &error,
+					    loaderPrivate);
+}
+
+__DRIimage *
+PVRDRICreateImageFromBuffer(__DRIcontext *context,
+                            int target,
+                            void *buffer,
+                            unsigned *error,
+                            void *loaderPrivate)
+{
+	PVRDRIContext *psPVRContext = context->driverPrivate;
+	__DRIscreen *screen = psPVRContext->psPVRScreen->psDRIScreen;
+	_EGLImage *psEGLImage;
+	struct __DRIimageRec *image;
+
+	switch (target)
+	{
+#if defined(EGL_CL_IMAGE_IMG)
+		case EGL_CL_IMAGE_IMG:
+			break;
+#endif
+		default:
+			errorMessage("%s: Target %d is not supported\n", __func__, target);
+			*error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
+			return NULL;
+	}
+
+	image = CommonImageSetup(loaderPrivate);
+	if (!image)
+	{
+		return NULL;
+	}
+
+	psEGLImage = PVRDRIEGLImageCreate();
+	if (!psEGLImage)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	*error = GetImageSourceOCL(psPVRContext, target, buffer, psEGLImage);
+	if (*error != __DRI_IMAGE_ERROR_SUCCESS)
+	{
+		PVRDRIEGLImageFree(psEGLImage);
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	PVRDRIEGLImageSetCallbackData(psEGLImage, image);
+
+	/*
+	 * We can't destroy the image after this point, as the
+	 * OCL image now has a reference to it.
+	 */
+	image->psShared = CreateImageSharedFromEGLImage(screen, psEGLImage);
+	if (!image->psShared)
+	{
+		return NULL;
+	}
+
+	image->psEGLImage = PVRDRIEGLImageDup(image->psShared->psEGLImage);
+	if (!image->psEGLImage)
+	{
+		return NULL;
+	}
+
+	image->iRefCount++;
+
+	return image;
+}
+
+__DRIimage *PVRDRICreateImageFromDmaBufs(__DRIscreen *screen,
+                                         int width, int height, int fourcc,
+                                         int *fds, int num_fds,
+                                         int *strides, int *offsets,
+                                         enum __DRIYUVColorSpace color_space,
+                                         enum __DRISampleRange sample_range,
+                                         enum __DRIChromaSiting horiz_siting,
+                                         enum __DRIChromaSiting vert_siting,
+                                         unsigned *error,
+                                         void *loaderPrivate)
+{
+	__DRIimage *image;
+	int iStride;
+
+	image = CommonImageSetup(loaderPrivate);
+	if (!image)
+	{
+		*error = __DRI_IMAGE_ERROR_BAD_ALLOC;
+		return NULL;
+	}
+
+	image->psShared = CreateImageSharedFromDmaBufs(screen, width, height, fourcc,
+						       fds, num_fds, strides, offsets,
+						       color_space, sample_range,
+						       horiz_siting, vert_siting,
+						       error);
+	if (!image->psShared)
+	{
+		PVRDRIDestroyImage(image);
+		return NULL;
+	}
+
+	if (image->psShared->psFormat->uiNumPlanes == 1)
+	{
+		iStride = strides[0];
+	}
+	else
+	{
+		iStride = width * PVRDRIPixFmtGetBlockSize(image->psShared->psFormat->eIMGPixelFormat);
+	}
+
+	image->psEGLImage = PVRDRIEGLImageCreateFromBuffers(width, height,
+							    iStride,
+							    image->psShared->psFormat->eIMGPixelFormat,
+							    image->psShared->eColourSpace,
+							    image->psShared->eChromaUInterp,
+							    image->psShared->eChromaVInterp,
+							    &image->psShared->apsBuffers[0],
+							    num_fds);
+	if (!image->psEGLImage)
+	{
+		PVRDRIDestroyImage(image);
+		*error = __DRI_IMAGE_ERROR_BAD_ALLOC;
+		return NULL;
+	}
+
+	PVRDRIEGLImageSetCallbackData(image->psEGLImage, image);
+
+	*error = __DRI_IMAGE_ERROR_SUCCESS;
+
+	return image;
+}
+
+void PVRDRIRefImage(__DRIimage *image)
+{
+	int iRefCount = __sync_fetch_and_add(&image->iRefCount, 1);
+
+	(void)iRefCount;
+	assert(iRefCount > 0);
+}
+
+void PVRDRIUnrefImage(__DRIimage *image)
+{
+	PVRDRIDestroyImage(image);
+}
+
+PVRDRIImageType PVRDRIImageGetSharedType(__DRIimage *image)
+{
+	return image->psShared->eType;
+}
+
+PVRDRIBufferImpl *PVRDRIImageGetSharedBuffer(__DRIimage *pImage)
+{
+	assert(pImage->psShared->eType != PVRDRI_IMAGE_FROM_EGLIMAGE);
+
+	if (pImage->psShared->psFormat->uiNumPlanes == 1)
+	{
+		return pImage->psShared->apsBuffers[0];
+	}
+
+	return NULL;
+}
+
+_EGLImage *PVRDRIImageGetSharedEGLImage(__DRIimage *pImage)
+{
+	assert(pImage->psShared->eType == PVRDRI_IMAGE_FROM_EGLIMAGE);
+	return pImage->psShared->psEGLImage;
+}
+
+_EGLImage *PVRDRIImageGetEGLImage(__DRIimage *pImage)
+{
+	return pImage->psEGLImage;
+}
+
+__DRIimage *PVRDRIScreenGetDRIImage(void *hEGLImage)
+{
+	PVRDRIScreen *psPVRScreen = PVRDRIThreadGetCurrentScreen();
+
+	if (!psPVRScreen)
+	{
+		return NULL;
+	}
+
+	return psPVRScreen->psDRIScreen->dri2.image->lookupEGLImage(
+	      psPVRScreen->psDRIScreen,
+	      hEGLImage,
+	      psPVRScreen->psDRIScreen->loaderPrivate);
+}
diff --git a/src/mesa/drivers/dri/pvr/pvrimage.h b/src/mesa/drivers/dri/pvr/pvrimage.h
new file mode 100644
index 0000000..773ccb4
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrimage.h
@@ -0,0 +1,96 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File           
+@Title          DRI IMAGE support
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVRIMAGE_H__)
+#define __PVRIMAGE_H__
+#include "pvr_dri_support.h"
+
+__DRIimage *PVRDRICreateImageFromName(__DRIscreen *screen,
+				      int width, int height, int format,
+				      int name, int pitch,
+				      void *loaderPrivate);
+
+__DRIimage *PVRDRICreateImageFromRenderbuffer(__DRIcontext *context,
+					      int renderbuffer,
+					      void *loaderPrivate);
+
+void PVRDRIDestroyImage(__DRIimage *image);
+
+__DRIimage *PVRDRICreateImage(__DRIscreen *screen,
+			      int width, int height, int format,
+			      unsigned int use,
+			      void *loaderPrivate);
+
+GLboolean PVRDRIQueryImage(__DRIimage *image, int attrib, int *value);
+
+__DRIimage *PVRDRIDupImage(__DRIimage *image, void *loaderPrivate);
+
+GLboolean PVRDRIValidateUsage(__DRIimage *image, unsigned int use);
+
+__DRIimage *PVRDRICreateImageFromNames(__DRIscreen *screen,
+				       int width, int height, int fourcc,
+				       int *names, int num_names,
+				       int *strides, int *offsets,
+				       void *loaderPrivate);
+
+__DRIimage *PVRDRIFromPlanar(__DRIimage *image, int plane,
+			     void *loaderPrivate);
+
+__DRIimage *PVRDRICreateImageFromTexture(__DRIcontext *context,
+					 int glTarget,
+					 unsigned texture,
+					 int depth,
+					 int level,
+					 unsigned *error,
+					 void *loaderPrivate);
+
+__DRIimage *PVRDRICreateImageFromFds(__DRIscreen *screen,
+				     int width, int height, int fourcc,
+				     int *fds, int num_fds,
+				     int *strides, int *offsets,
+				     void *loaderPrivate);
+
+__DRIimage *PVRDRICreateImageFromBuffer(__DRIcontext *context,
+					int target,
+					void *buffer,
+					unsigned *error,
+					void *loaderPrivate);
+
+__DRIimage *PVRDRICreateImageFromDmaBufs(__DRIscreen *screen,
+                                         int width, int height, int fourcc,
+                                         int *fds, int num_fds,
+                                         int *strides, int *offsets,
+                                         enum __DRIYUVColorSpace color_space,
+                                         enum __DRISampleRange sample_range,
+                                         enum __DRIChromaSiting horiz_siting,
+                                         enum __DRIChromaSiting vert_siting,
+                                         unsigned *error,
+                                         void *loaderPrivate);
+
+#endif /* !defined(__PVRIMAGE_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvrmesa.h b/src/mesa/drivers/dri/pvr/pvrmesa.h
new file mode 100644
index 0000000..f01704b
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrmesa.h
@@ -0,0 +1,43 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File           
+@Title          Mesa dispatch table handling
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVRMESA_H__)
+#define __PVRMESA_H__
+
+#include "pvrdri.h"
+
+void pvrdri_free_dispatch_tables(PVRDRIScreen *psPVRScreen);
+
+GLboolean pvrdri_create_dispatch_table(PVRDRIScreen *psPVRScreen, pvrdri_api_type eAPI);
+
+void pvrdri_set_null_dispatch_table(void);
+
+void pvrdri_set_dispatch_table(PVRDRIContext *psPVRContext);
+
+#endif /* !defined(__PVRMESA_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvrqueue.h b/src/mesa/drivers/dri/pvr/pvrqueue.h
new file mode 100644
index 0000000..3fdc0a8
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrqueue.h
@@ -0,0 +1,74 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File           pvrqueue.h
+@Title          Queue related definitions
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVRQUEUE_H__)
+#define __PVRQUEUE_H__
+#include <assert.h>
+#include <search.h>
+#include <stddef.h>
+
+#define	PVRQ_CONTAINER_OF(p, t, f) ((t *)((char *)(p) - offsetof(t, f)))
+
+typedef struct _PVRQElem
+{
+	struct _PVRQElem *pvForw;
+	struct _PVRQElem *pvBack;
+} PVRQElem;
+
+typedef PVRQElem PVRQHead;
+
+#define DECLARE_PVRQ_HEAD(h) PVRQHead h = {&h, &h}
+
+static inline void INITIALISE_PVRQ_HEAD(PVRQHead *ph)
+{
+	ph->pvForw = ph->pvBack = ph;
+	insque(ph, ph);
+}
+
+static inline int PVRQIsEmpty(PVRQHead *ph)
+{
+	return ph->pvForw == ph && ph->pvBack == ph;
+}
+
+static inline void PVRQQueue(PVRQHead *ph, PVRQElem *pe)
+{
+	assert(pe->pvForw == NULL && pe->pvBack == NULL);
+
+	insque(pe, ph->pvBack);
+}
+
+static inline void PVRQDequeue(PVRQElem *pe)
+{
+	remque(pe);
+
+	pe->pvForw = NULL;
+	pe->pvBack = NULL;
+}
+
+#endif /* defined(__PVRQUEUE_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvrsyncobj.c b/src/mesa/drivers/dri/pvr/pvrsyncobj.c
new file mode 100644
index 0000000..d1f9ec6
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrsyncobj.c
@@ -0,0 +1,206 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          PVR DRI sync object support
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include <assert.h>
+#include <search.h>
+
+#include "dri_util.h"
+#include "pvr_dri_support.h"
+#include "pvrsyncobj.h"
+
+#if defined(__DRI2_FENCE)
+
+typedef struct __DRI2fenceRec
+{
+	PVRQElem sQElem;
+	PVRDRIScreenImpl *psScreenImpl;
+
+	/* Services SyncPrim that tracks completion of TQ Blit */
+	PVRSRV_CLIENT_SYNC_PRIM *psEGLFenceSyncPrim;
+
+	/* Sync management object for TQ Blit inserted into GL command stream */
+	SyncCommand *psSyncCommand;
+} __DRI2fence;
+
+static DECLARE_PVRQ_HEAD(sDeferredFree);
+
+static void
+DeleteFence(__DRI2fence *psFence)
+{
+	if (psFence != NULL)
+	{
+		PVRDRISyncPrimDelete(psFence->psScreenImpl,
+		                     psFence->psEGLFenceSyncPrim,
+		                     psFence->psSyncCommand);
+		free(psFence);
+	}
+}
+
+void *
+PVRDRICreateFence(__DRIcontext *psDRIContext)
+{
+	PVRDRIContext *psPVRContext = psDRIContext->driverPrivate;
+	PVRDRIScreen *psPVRScreen = psPVRContext->psPVRScreen;
+	__DRI2fence *psFence;
+
+	psFence = calloc(1, sizeof(*psFence));
+	if (psFence == NULL)
+	{
+		goto error;
+	}
+	psFence->psScreenImpl = psPVRScreen->psImpl;
+
+	if (!PVRDRISyncPrimAlloc(psFence->psScreenImpl,
+				 &psFence->psEGLFenceSyncPrim))
+	{
+		goto error;
+	}
+
+	if (!PVRDRIInsertClientFence(psPVRContext->eAPI,
+				     psPVRContext->psImpl,
+				     psFence->psScreenImpl,
+				     psFence->psEGLFenceSyncPrim,
+				     &psFence->psSyncCommand))
+	{
+		goto error;
+	}
+
+	return psFence;
+
+error:
+	DeleteFence(psFence);
+
+	return NULL;
+}
+
+static void
+GarbageCollectFences(void)
+{
+	PVRQElem *psQElem = sDeferredFree.pvForw;
+
+	while (psQElem != &sDeferredFree)
+	{
+		__DRI2fence *psFence =
+			PVRQ_CONTAINER_OF(psQElem, __DRI2fence, sQElem);
+
+		psQElem = psFence->sQElem.pvForw;
+
+		if (PVRDRIIsFenceSyncComplete(psFence->psEGLFenceSyncPrim)) {
+			remque(&psFence->sQElem);
+			DeleteFence(psFence);
+		}
+	}
+}
+
+void
+PVRDRIDestroyFence(__DRIscreen *psDRIScreen, void *psDRIFence)
+{
+	__DRI2fence *psFence = psDRIFence;
+
+	(void)psDRIScreen;
+
+	GarbageCollectFences();
+
+	if (PVRDRIIsFenceSyncComplete(psFence->psEGLFenceSyncPrim))
+	{
+		DeleteFence(psFence);
+	}
+	else
+	{
+		insque(&psFence->sQElem, sDeferredFree.pvBack);
+	}
+}
+
+GLboolean
+PVRDRIClientWaitSync(__DRIcontext *psDRIContext, void *psDRIFence,
+		     unsigned uFlags, uint64_t uiTimeout)
+{
+	__DRI2fence *psFence = psDRIFence;
+
+	if (uFlags & __DRI2_FENCE_FLAG_FLUSH_COMMANDS)
+	{
+		PVRDRIContext *psPVRContext = (PVRDRIContext *)psDRIContext->driverPrivate;
+
+		(void) PVRDRIEGLFlushBuffers(psPVRContext->eAPI,
+		                             psPVRContext->psPVRScreen->psImpl,
+					     psPVRContext->psImpl,
+		                             NULL, true, false, false);
+	}
+
+	return PVRDRIEventObjectWait(psFence->psScreenImpl,
+				     psFence->psEGLFenceSyncPrim,
+				     uiTimeout != __DRI2_FENCE_TIMEOUT_INFINITE,
+				     uiTimeout);
+}
+
+void
+PVRDRIServerWaitSync(__DRIcontext *psDRIContext, void *psDRIFence,
+		     unsigned uFlags)
+{
+	PVRDRIContext *psPVRContext = psDRIContext->driverPrivate;
+	__DRI2fence *psFence = psDRIFence;
+
+	(void)uFlags;
+	assert(uFlags == 0);
+
+	if (!PVRDRIInsertServerFence(psPVRContext->eAPI,
+				     psPVRContext->psImpl,
+				     psFence->psScreenImpl,
+				     psFence->psSyncCommand))
+	{
+		__driUtilMessage("%s: Failed to insert server fence", __func__);
+	}
+}
+
+void
+PVRDRIDestroyFences(PVRDRIScreen *psPVRScreen)
+{
+	PVRQElem *psQElem = sDeferredFree.pvForw;
+
+	while (psQElem != &sDeferredFree)
+	{
+		__DRI2fence *psFence =
+			PVRQ_CONTAINER_OF(psQElem, __DRI2fence, sQElem);
+
+		psQElem = psFence->sQElem.pvForw;
+
+		if (psFence->psScreenImpl == psPVRScreen->psImpl)
+		{
+			remque(&psFence->sQElem);
+
+			if (!PVRDRIIsFenceSyncComplete(psFence->psEGLFenceSyncPrim))
+			{
+				__driUtilMessage("%s: Fence not complete. Freeing anyway.", __func__);
+			}
+			DeleteFence(psFence);
+		}
+	}
+}
+
+#endif /* defined(__DRI2_FENCE) */
diff --git a/src/mesa/drivers/dri/pvr/pvrsyncobj.h b/src/mesa/drivers/dri/pvr/pvrsyncobj.h
new file mode 100644
index 0000000..a850170
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrsyncobj.h
@@ -0,0 +1,48 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          PVR DRI sync object support
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(__PVRSYNCOBJ_H__)
+#define __PVRSYNCOBJ_H__
+
+#include "dri_util.h"
+#include "pvrdri.h"
+#include "pvr_dri_support.h"
+
+#if defined(__DRI2_FENCE)
+
+void *PVRDRICreateFence(__DRIcontext *psDRIContext);
+void PVRDRIDestroyFence(__DRIscreen *psDRIScreen, void *psDRIFence);
+GLboolean PVRDRIClientWaitSync(__DRIcontext *psDRIContext, void *psDRIFence,
+			       unsigned uFlags, uint64_t uiTimeout);
+void PVRDRIServerWaitSync(__DRIcontext *psDRIContext, void *psDRIFence,
+			  unsigned uFlags);
+void PVRDRIDestroyFences(PVRDRIScreen *psPVRScreen);
+
+#endif /* defined(__DRI2_FENCE) */
+#endif /* !defined(__PVRSYNCOBJ_H__) */
diff --git a/src/mesa/drivers/dri/pvr/pvrutil.c b/src/mesa/drivers/dri/pvr/pvrutil.c
new file mode 100644
index 0000000..74fd4f6
--- /dev/null
+++ b/src/mesa/drivers/dri/pvr/pvrutil.c
@@ -0,0 +1,512 @@
+/* -*- mode: c; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* vi: set ts=8 sw=8 sts=8: */
+/*************************************************************************/ /*!
+@File
+@Title          PVR DRI utility functions
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        MIT
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <dlfcn.h>
+
+#include "utils.h"
+#include "GL/gl.h"
+
+#include "pvrdri.h"
+
+static const PVRDRIImageFormat g_asFormats[] =
+{
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_B8G8R8A8_UNORM,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_ARGB8888,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_ARGB8888,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_RGBA,
+		.uiNumPlanes = 1,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_B8G8R8A8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_ARGB8888,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+	},
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_R8G8B8A8_UNORM,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_ABGR8888,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_ABGR8888,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_RGBA,
+		.uiNumPlanes = 1,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8G8B8A8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_ABGR8888,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+	},
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_B8G8R8X8_UNORM,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_XRGB8888,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_XRGB8888,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_RGB,
+		.uiNumPlanes = 1,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_B8G8R8X8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_XRGB8888,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+	},
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_R8G8B8X8_UNORM,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_XBGR8888,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_XBGR8888,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_RGB,
+		.uiNumPlanes = 1,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8G8B8X8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_XBGR8888,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+	},
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_B5G6R5_UNORM,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_RGB565,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_RGB565,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_RGB,
+		.uiNumPlanes = 1,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_B5G6R5_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_RGB565,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+	},
+#if defined(__DRI_IMAGE_FORMAT_ARGB4444)
+	/* We patch this format into Mesa */
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_B4G4R4A4_UNORM,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_ARGB4444,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_ARGB4444,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_RGBA,
+		.uiNumPlanes = 1,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_B4G4R4A4_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_ARGB4444,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+	},
+#endif
+#if defined(__DRI_IMAGE_FORMAT_ARGB1555)
+	/* We patch this format into Mesa */
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_B5G5R5A1_UNORM,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_ARGB1555,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_ARGB1555,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_RGBA,
+		.uiNumPlanes = 1,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_B5G5R5A1_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_ARGB1555,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+	},
+#endif
+#if defined(__DRI_IMAGE_FOURCC_MT21)
+	/* We patch this format into Mesa */
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_YVU8_420_2PLANE_PACK8_P,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_MT21,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_NONE,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_Y_UV,
+		.uiNumPlanes = 2,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_R8,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+		.sPlanes[1] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8G8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_GR88,
+				.uiWidthShift = 1,
+				.uiHeightShift = 1
+		},
+	},
+#endif
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_YUV420_2PLANE,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_NV12,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_NONE,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_Y_UV,
+		.uiNumPlanes = 2,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_R8,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+		.sPlanes[1] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8G8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_GR88,
+				.uiWidthShift = 1,
+				.uiHeightShift = 1
+		},
+	},
+#if defined(__DRI_IMAGE_FOURCC_YVU420)
+	{
+		.eIMGPixelFormat = IMG_PIXFMT_YVU420_3PLANE,
+		.iDRIFourCC = __DRI_IMAGE_FOURCC_YVU420,
+		.iDRIFormat = __DRI_IMAGE_FORMAT_NONE,
+		.iDRIComponents = __DRI_IMAGE_COMPONENTS_Y_U_V,
+		.uiNumPlanes = 3,
+		.sPlanes[0] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_R8,
+				.uiWidthShift = 0,
+				.uiHeightShift = 0
+		},
+		.sPlanes[1] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_R8,
+				.uiWidthShift = 1,
+				.uiHeightShift = 1
+		},
+		.sPlanes[2] =
+		{
+				.eIMGPixelFormat = IMG_PIXFMT_R8_UNORM,
+				.iDRIFormat = __DRI_IMAGE_FORMAT_R8,
+				.uiWidthShift = 1,
+				.uiHeightShift = 1
+		},
+	},
+#endif
+};
+
+
+/* Standard error message */
+void __attribute__((format(printf, 1, 2))) errorMessage(const char *f, ...)
+{
+	va_list args;
+
+	va_start(args, f);
+	vfprintf(stderr, f, args);
+	va_end(args);
+}
+
+void __attribute__((format(printf, 1, 2))) __driUtilMessage(const char *f, ...)
+{
+	va_list args;
+	char *ev;
+
+	ev = getenv("LIBGL_DEBUG");
+	if (ev != NULL && (strcmp(ev, "verbose") == 0))
+	{
+		fputs("LibGL: ", stderr);
+		va_start(args, f);
+		vfprintf(stderr, f, args);
+		va_end(args);
+		fputc('\n', stderr);
+	}
+}
+
+void *PVRDRILoadAPILib(const char *name)
+{
+	const char *error;
+	void *handle;
+
+	(void) dlerror();
+
+	handle = dlopen(name, RTLD_NOW);
+	if (handle == NULL)
+	{
+		error = dlerror();
+
+		__driUtilMessage("%s: dlopen of %s failed: %s",
+				 __func__, name, ((error != NULL) ? error : "unknown"));
+
+	}
+
+	return handle;
+}
+
+bool PVRDRILoadLibOGL(PVRDRIScreen *psPVRScreen)
+{
+#if defined(PVR_OGL_LIB)
+	if (psPVRScreen->pvLibHandleOGL == NULL)
+	{
+		psPVRScreen->pvLibHandleOGL = PVRDRILoadAPILib(PVR_OGL_LIB);
+	}
+#endif
+	return psPVRScreen->pvLibHandleOGL != NULL;
+}
+
+bool PVRDRILoadLibOGLES2(PVRDRIScreen *psPVRScreen)
+{
+	if (psPVRScreen->pvLibHandleOGLES2 == NULL)
+	{
+		psPVRScreen->pvLibHandleOGLES2 = PVRDRILoadAPILib(PVR_OGLES2_LIB);
+	}
+
+	return psPVRScreen->pvLibHandleOGLES2 != NULL;
+}
+
+bool PVRDRILoadLibOGLES1(PVRDRIScreen *psPVRScreen)
+{
+	if (psPVRScreen->pvLibHandleOGLES1 == NULL)
+	{
+		psPVRScreen->pvLibHandleOGLES1 = PVRDRILoadAPILib(PVR_OGLES1_LIB);
+	}
+
+	return psPVRScreen->pvLibHandleOGLES1 != NULL;
+}
+
+bool PVRDRILoadLibOCL(PVRDRIScreen *psPVRScreen)
+{
+#if defined(PVR_OCL_LIB)
+	if (psPVRScreen->pvLibHandleOCL == NULL)
+	{
+		psPVRScreen->pvLibHandleOCL = PVRDRILoadAPILib(PVR_OCL_LIB);
+	}
+#endif
+	return psPVRScreen->pvLibHandleOCL != NULL;
+}
+
+const __DRIconfig **PVRDRICreateConfigs(void)
+{
+	static const GLenum asBackBufferModes[]	= { GLX_NONE, GLX_SWAP_COPY_OML };
+	mesa_format aePixelFormats[] =
+		{
+			MESA_FORMAT_B8G8R8A8_UNORM,
+			MESA_FORMAT_B8G8R8X8_UNORM,
+			MESA_FORMAT_B5G6R5_UNORM
+		};
+	uint8_t auDepthBits[] = { 0, 32 };
+	uint8_t auStencilBits[] = { 0, 8 };
+	uint8_t auMSAASamples[] = { 0, 2, 4, 8 };
+	unsigned uNumBackBufferModes;
+	unsigned uNumDepthStencilBits;
+	unsigned uNumMSAASamples;
+	__DRIconfig **ppsConfigs = NULL;
+	__DRIconfig **ppsNewConfigs;
+	unsigned i;
+
+	uNumBackBufferModes	= ARRAY_SIZE(asBackBufferModes);
+	uNumDepthStencilBits	= ARRAY_SIZE(auDepthBits);
+	uNumMSAASamples		= ARRAY_SIZE(auMSAASamples);
+
+	/* The size of the depth and stencil arrays should be the same */
+	assert(ARRAY_SIZE(auStencilBits) == uNumDepthStencilBits);
+
+	for (i = 0; i < ARRAY_SIZE(aePixelFormats); i++)
+	{
+		ppsNewConfigs = driCreateConfigs(aePixelFormats[i],
+						 auDepthBits,
+						 auStencilBits,
+						 uNumDepthStencilBits, 
+						 asBackBufferModes,
+						 uNumBackBufferModes, 
+						 auMSAASamples,
+						 uNumMSAASamples,
+						 GL_FALSE);
+
+		ppsConfigs = driConcatConfigs(ppsConfigs, ppsNewConfigs);
+	}
+
+	if (ppsConfigs)
+	{
+		for (i = 0; ppsConfigs[i]; i++)
+		{
+			ppsConfigs[i]->modes.maxPbufferWidth = 8192;
+			ppsConfigs[i]->modes.maxPbufferHeight = 8192;
+
+			ppsConfigs[i]->modes.maxPbufferPixels  = ppsConfigs[i]->modes.maxPbufferWidth;
+			ppsConfigs[i]->modes.maxPbufferPixels *= ppsConfigs[i]->modes.maxPbufferHeight;
+		}
+	}
+
+	return (const __DRIconfig **)ppsConfigs;
+}
+
+const PVRDRIImageFormat *PVRDRIFormatToImageFormat(int iDRIFormat)
+{
+	unsigned i;
+
+	for (i = 0; i < ARRAY_SIZE(g_asFormats); i++)
+	{
+		if (g_asFormats[i].iDRIFormat == iDRIFormat)
+		{
+			return &g_asFormats[i];
+		}
+	}
+
+	return NULL;
+}
+
+const PVRDRIImageFormat *PVRDRIFourCCToImageFormat(int iDRIFourCC)
+{
+	unsigned i;
+
+	for (i = 0; i < ARRAY_SIZE(g_asFormats); i++)
+	{
+		if (g_asFormats[i].iDRIFourCC == iDRIFourCC)
+		{
+			return &g_asFormats[i];
+		}
+	}
+
+	return NULL;
+}
+
+const PVRDRIImageFormat *PVRDRIIMGPixelFormatToImageFormat(IMG_PIXFMT eIMGPixelFormat)
+{
+	unsigned i;
+
+	for (i = 0; i < ARRAY_SIZE(g_asFormats); i++)
+	{
+		if (g_asFormats[i].eIMGPixelFormat == eIMGPixelFormat)
+		{
+			return &g_asFormats[i];
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * The EGL_EXT_image_dma_buf_import says that if a hint is unspecified then
+ * the implementation may guess based on the pixel format or may fallback
+ * to some default value. Furthermore, if a hint is unsupported then the
+ * implementation may use whichever settings it wants to achieve the closest
+ * match.
+ */
+IMG_YUV_COLORSPACE PVRDRIToIMGColourSpace(const PVRDRIImageFormat *psFormat,
+					  enum __DRIYUVColorSpace eDRIColourSpace,
+					  enum __DRISampleRange eDRISampleRange)
+{
+	switch (psFormat->iDRIComponents)
+	{
+		case __DRI_IMAGE_COMPONENTS_RGB:
+		case __DRI_IMAGE_COMPONENTS_RGBA:
+			return IMG_COLORSPACE_UNDEFINED;
+		case __DRI_IMAGE_COMPONENTS_Y_U_V:
+		case __DRI_IMAGE_COMPONENTS_Y_UV:
+		case __DRI_IMAGE_COMPONENTS_Y_XUXV:
+			break;
+		default:
+			errorMessage("Unrecognised DRI components (components = 0x%X)\n",
+				     psFormat->iDRIComponents);
+			assert(0);
+			return IMG_COLORSPACE_UNDEFINED;
+	}
+
+	switch (eDRIColourSpace)
+	{
+		case __DRI_YUV_COLOR_SPACE_UNDEFINED:
+		case __DRI_YUV_COLOR_SPACE_ITU_REC601:
+			switch (eDRISampleRange)
+			{
+				case __DRI_YUV_RANGE_UNDEFINED:
+				case __DRI_YUV_NARROW_RANGE:
+					return IMG_COLORSPACE_BT601_CONFORMANT_RANGE;
+				case __DRI_YUV_FULL_RANGE:
+					return IMG_COLORSPACE_BT601_FULL_RANGE;
+				default:
+					errorMessage("Unrecognised DRI sample range (sample range = 0x%X)\n",
+						     eDRISampleRange);
+					assert(0);
+					return IMG_COLORSPACE_UNDEFINED;
+			}
+		case __DRI_YUV_COLOR_SPACE_ITU_REC709:
+		case __DRI_YUV_COLOR_SPACE_ITU_REC2020:
+			switch (eDRISampleRange)
+			{
+				case __DRI_YUV_RANGE_UNDEFINED:
+				case __DRI_YUV_NARROW_RANGE:
+					return IMG_COLORSPACE_BT709_CONFORMANT_RANGE;
+				case __DRI_YUV_FULL_RANGE:
+					return IMG_COLORSPACE_BT709_FULL_RANGE;
+				default:
+					errorMessage("Unrecognised DRI sample range (sample range = 0x%X)\n",
+						     eDRISampleRange);
+					assert(0);
+					return IMG_COLORSPACE_UNDEFINED;
+			}
+		default:
+			errorMessage("Unrecognised DRI colour space (colour space = 0x%X)\n",
+				     eDRIColourSpace);
+			assert(0);
+			return IMG_COLORSPACE_UNDEFINED;
+	}
+}
+
+IMG_YUV_CHROMA_INTERP PVRDRIChromaSittingToIMGInterp(const PVRDRIImageFormat *psFormat,
+						     enum __DRIChromaSiting eChromaSitting)
+{
+	switch (psFormat->iDRIComponents)
+	{
+		case __DRI_IMAGE_COMPONENTS_RGB:
+		case __DRI_IMAGE_COMPONENTS_RGBA:
+			return IMG_CHROMA_INTERP_UNDEFINED;
+		case __DRI_IMAGE_COMPONENTS_Y_U_V:
+		case __DRI_IMAGE_COMPONENTS_Y_UV:
+		case __DRI_IMAGE_COMPONENTS_Y_XUXV:
+			break;
+		default:
+			errorMessage("Unrecognised DRI components (components = 0x%X)\n",
+				     psFormat->iDRIComponents);
+			assert(0);
+			return IMG_CHROMA_INTERP_UNDEFINED;
+	}
+
+	switch (eChromaSitting)
+	{
+		case __DRI_YUV_CHROMA_SITING_UNDEFINED:
+		case __DRI_YUV_CHROMA_SITING_0:
+			return IMG_CHROMA_INTERP_ZERO;
+		case __DRI_YUV_CHROMA_SITING_0_5:
+			return IMG_CHROMA_INTERP_HALF;
+		default:
+			errorMessage("Unrecognised DRI chroma sitting (chroma sitting = 0x%X)\n",
+				     eChromaSitting);
+			assert(0);
+			return IMG_CHROMA_INTERP_UNDEFINED;
+	}
+}
-- 
1.9.1

