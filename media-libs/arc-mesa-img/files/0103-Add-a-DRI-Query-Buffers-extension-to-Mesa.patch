From ce273ec15ffbb47a57df5b2ab67ab24f39380ad2 Mon Sep 17 00:00:00 2001
From: Rufus Hamade <rufus.hamade@imgtec.com>
Date: Fri, 3 Jun 2016 18:35:53 +0100
Subject: [PATCH 103/103] Add a DRI Query Buffers extension to Mesa.

The extension is used to notify the DRI module that it should fetch
updated buffer information immediately. This fixes some failures in
the dEQP EGL surface resize tests, where the surface is resized
immediately before calling eglSwapBuffers, and the surface
dimensions queried immediately afterwards (using eglQuerySurface).
Without the extension, the buffer information is updated when
KEGLGetDrawableParameters is next called, but this is too late for
the test cases in question.

Change-Id: Ie40292de6b8429588802afe9b52f768a32cffc3e
---
 src/mesa/drivers/dri/pvr/pvr_dri_support.h |   3 +-
 src/mesa/drivers/dri/pvr/pvrdrawable.c     | 360 +++++++++++++++++++----------
 src/mesa/drivers/dri/pvr/pvrdri.c          |   9 +-
 src/mesa/drivers/dri/pvr/pvrdri.h          |  23 +-
 src/mesa/drivers/dri/pvr/pvrext.c          |  63 ++++-
 5 files changed, 318 insertions(+), 140 deletions(-)

diff --git a/src/mesa/drivers/dri/pvr/pvr_dri_support.h b/src/mesa/drivers/dri/pvr/pvr_dri_support.h
index e0a3da2..6060484 100644
--- a/src/mesa/drivers/dri/pvr/pvr_dri_support.h
+++ b/src/mesa/drivers/dri/pvr/pvr_dri_support.h
@@ -332,7 +332,8 @@ PVRDRIEGLDrawableConfigFromGLMode(PVRDRIDrawableImpl *psPVRDrawable,
 /* Callbacks into non-impl layer */
 typedef struct
 {
-	bool                 (*DrawableGetInfo)(PVRDRIDrawable *psPVRDrawable, bool bUpdate);
+	bool                 (*DrawableCreate)(PVRDRIDrawable *psPVRDrawable);
+	bool                 (*DrawableRecreate)(PVRDRIDrawable *psPVRDrawable);
 	PVRDRIBufferImpl    *(*DrawableGetDstBuffer)(PVRDRIDrawable *psPVRDrawable);
 	PVRDRIBufferImpl    *(*DrawableGetAccumBuffer)(PVRDRIDrawable *psPVRDrawable);
 	bool                 (*DrawableGetParameters)(PVRDRIDrawable *psPVRDrawable,
diff --git a/src/mesa/drivers/dri/pvr/pvrdrawable.c b/src/mesa/drivers/dri/pvr/pvrdrawable.c
index 599d00d..3527819 100644
--- a/src/mesa/drivers/dri/pvr/pvrdrawable.c
+++ b/src/mesa/drivers/dri/pvr/pvrdrawable.c
@@ -75,33 +75,22 @@ static inline void PVRDRIMarkAllRenderSurfacesAsInvalid(PVRDRIDrawable *psPVRDra
 */ /**************************************************************************/
 
 /*************************************************************************/ /*!
- Function Name		: PVRImageDrawableGetInfo
+ Function Name		: PVRImageDrawableGetNativeInfo
  Inputs			: psPVRDrawable
  Returns		: Boolean
- Description		: Get or update drawable buffers
+ Description		: Update native drawable information.
 */ /**************************************************************************/
-static bool PVRImageDrawableGetInfo(PVRDRIDrawable *psPVRDrawable,
-                                    bool bUpdate)
+static bool PVRImageDrawableGetNativeInfo(PVRDRIDrawable *psPVRDrawable)
 {
 	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
 	__DRIscreen *psDRIScreen = psPVRDrawable->psPVRScreen->psDRIScreen;
-	PVRDRIBuffer *psPVRBuffer;
-	__DRIimage *psImage;
 	struct __DRIimageList sImages;
 	uint32_t uiBufferMask;
-	uint32_t uBytesPerPixel;
-	PVRDRIBufferAttribs sBufferAttribs;
-	bool bRecreate = false;
 	const PVRDRIImageFormat *psFormat;
 
 	assert(psDRIScreen->image.loader != NULL);
 	assert(psDRIScreen->image.loader->getBuffers);
 
-	if (psPVRDrawable->bUseInvalidate && !psPVRDrawable->bDrawableInfoInvalid)
-	{
-		return true;
-	}
-
 	psFormat = PVRDRIIMGPixelFormatToImageFormat(psPVRDrawable->ePixelFormat);
 	if (!psFormat)
 	{
@@ -110,14 +99,9 @@ static bool PVRImageDrawableGetInfo(PVRDRIDrawable *psPVRDrawable,
 		return false;
 	}
 
-	if (psPVRDrawable->bDoubleBuffered)
-	{
-		uiBufferMask = __DRI_IMAGE_BUFFER_BACK;
-	}
-	else
-	{
-		uiBufferMask = __DRI_IMAGE_BUFFER_FRONT;
-	}
+	uiBufferMask = psPVRDrawable->bDoubleBuffered ?
+					__DRI_IMAGE_BUFFER_BACK :
+					__DRI_IMAGE_BUFFER_FRONT;
 
 	if (!psDRIScreen->image.loader->getBuffers(psDRIDrawable,
 						   psFormat->iDRIFormat,
@@ -130,32 +114,91 @@ static bool PVRImageDrawableGetInfo(PVRDRIDrawable *psPVRDrawable,
 		return false;
 	}
 
-	if (!psPVRDrawable->bDoubleBuffered)
+	psPVRDrawable->uDRI.sImage.psDRI =
+		(sImages.image_mask & __DRI_IMAGE_BUFFER_BACK) ?
+			sImages.back : sImages.front;
+
+	return true;
+}
+
+/*************************************************************************/ /*!
+ Function Name		: PVRImageDrawableCreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Create drawable
+*/ /**************************************************************************/
+static bool PVRImageDrawableCreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	uint32_t uBytesPerPixel;
+	PVRDRIBufferAttribs sBufferAttribs;
+
+	if (!PVRImageDrawableGetNativeInfo(psPVRDrawable))
 	{
-		psPVRBuffer = PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+		return false;
 	}
-	else
+
+	PVRDRIEGLImageGetAttribs(
+		PVRDRIImageGetEGLImage(psPVRDrawable->uDRI.sImage.psDRI),
+					&sBufferAttribs);
+	uBytesPerPixel = PVRDRIPixFmtGetBlockSize(sBufferAttribs.ePixFormat);
+
+	psDRIDrawable->w = sBufferAttribs.uiWidth;
+	psDRIDrawable->h = sBufferAttribs.uiHeight;
+	psPVRDrawable->uStride = sBufferAttribs.uiStrideInBytes;
+	psPVRDrawable->uBytesPerPixel = uBytesPerPixel;
+
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache,
+					psPVRDrawable->uDRI.sImage.psDRI))
 	{
-		psPVRBuffer = NULL;
+		errorMessage("%s: Couldn't insert buffer into cache\n", __func__);
+		return false;
+	}
+
+	if (!PVREGLDrawableCreate(psPVRDrawable->psPVRScreen->psImpl,
+				  psPVRDrawable->psImpl))
+	{
+		errorMessage("%s: Couldn't create EGL drawable\n", __func__);
+		return false;
 	}
 
-	psImage = (sImages.back) ? sImages.back : sImages.front;
-	PVRDRIEGLImageGetAttribs(PVRDRIImageGetEGLImage(psImage), &sBufferAttribs);
+	return true;
+}
+
+/*************************************************************************/ /*!
+ Function Name		: PVRImageDrawableRecreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Recreate drawable, if necessary.
+*/ /**************************************************************************/
+static bool PVRImageDrawableRecreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	PVRDRIBuffer *psPVRBuffer;
+	uint32_t uBytesPerPixel;
+	PVRDRIBufferAttribs sBufferAttribs;
+	bool bRecreate;
+
+	psPVRBuffer = (psPVRDrawable->bDoubleBuffered) ? NULL :
+			PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+
+	PVRDRIEGLImageGetAttribs(
+		PVRDRIImageGetEGLImage(psPVRDrawable->uDRI.sImage.psDRI),
+					&sBufferAttribs);
 	uBytesPerPixel = PVRDRIPixFmtGetBlockSize(sBufferAttribs.ePixFormat);
 
-	if (!bUpdate ||
-	    (psPVRBuffer && psPVRBuffer->uBacking.sImage.psImage != sImages.front) ||
-	    psDRIDrawable->w != sBufferAttribs.uiWidth ||
-	    psDRIDrawable->h != sBufferAttribs.uiHeight ||
-	    psPVRDrawable->uStride != sBufferAttribs.uiStrideInBytes ||
-	    psPVRDrawable->uBytesPerPixel != uBytesPerPixel)
-	{
-		if (bUpdate)
-		{
-			PVRDRIMarkAllRenderSurfacesAsInvalid(psPVRDrawable);
+	bRecreate = (psPVRBuffer &&
+			psPVRBuffer->uBacking.sImage.psImage !=
+				psPVRDrawable->uDRI.sImage.psDRI) ||
+			(psDRIDrawable->w != sBufferAttribs.uiWidth) ||
+			(psDRIDrawable->h != sBufferAttribs.uiHeight) ||
+			(psPVRDrawable->uStride !=
+				sBufferAttribs.uiStrideInBytes) ||
+			(psPVRDrawable->uBytesPerPixel != uBytesPerPixel);
 
-			bRecreate = true;
-		}
+	if (bRecreate)
+	{
+		PVRDRIMarkAllRenderSurfacesAsInvalid(psPVRDrawable);
 
 		psDRIDrawable->w = sBufferAttribs.uiWidth;
 		psDRIDrawable->h = sBufferAttribs.uiHeight;
@@ -163,22 +206,14 @@ static bool PVRImageDrawableGetInfo(PVRDRIDrawable *psPVRDrawable,
 		psPVRDrawable->uBytesPerPixel = uBytesPerPixel;
 	}
 
-	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache, psImage))
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache,
+					psPVRDrawable->uDRI.sImage.psDRI))
 	{
 		errorMessage("%s: Couldn't insert buffer into cache\n", __func__);
 		return false;
 	}
 
-	if (!bUpdate)
-	{
-		if (!PVREGLDrawableCreate(psPVRDrawable->psPVRScreen->psImpl,
-		                          psPVRDrawable->psImpl))
-		{
-			errorMessage("%s: Couldn't create EGL drawable\n", __func__);
-			return false;
-		}
-	}
-	else if (bRecreate)
+	if (bRecreate)
 	{
 		if (!PVREGLDrawableRecreate(psPVRDrawable->psPVRScreen->psImpl,
 		                            psPVRDrawable->psImpl))
@@ -188,8 +223,6 @@ static bool PVRImageDrawableGetInfo(PVRDRIDrawable *psPVRDrawable,
 		}
 	}
 
-	psPVRDrawable->bDrawableInfoInvalid = false;
-
 	return true;
 }
 
@@ -256,32 +289,25 @@ static bool PVRImageObjectCacheCompare(void *pvCreateData,
 */ /**************************************************************************/
 
 /***********************************************************************************
- Function Name		: PVRDRI2GetDrawableInfo
+ Function Name		: PVRDRI2DrawableGetNativeInfo
  Inputs			: psPVRDrawable
  Returns		: Boolean
- Description		: Get or update drawable buffers
+ Description		: Update native drawable information.
 ************************************************************************************/
-static bool PVRDRI2DrawableGetInfo(PVRDRIDrawable *psPVRDrawable, bool bUpdate)
+static bool PVRDRI2DrawableGetNativeInfo(PVRDRIDrawable *psPVRDrawable)
 {
 	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
 	__DRIscreen *psDRIScreen = psPVRDrawable->psPVRScreen->psDRIScreen;
 	unsigned int uiAttachment;
 	unsigned int auiAttachmentReq[2];
-	PVRDRIBuffer *psPVRBuffer;
 	__DRIbuffer *psDRIBuffers;
 	int iBufCount;
 	int i;
 	int w, h;
-	bool bRecreate = false;
 
 	assert(psDRIScreen->dri2.loader);
 	assert(psDRIScreen->dri2.loader->getBuffersWithFormat);
 
-	if (psPVRDrawable->bUseInvalidate && !psPVRDrawable->bDrawableInfoInvalid)
-	{
-		return true;
-	}
-
 	switch (psPVRDrawable->eSurfaceType)
 	{
 		case PVRDRI_SURFACE_PIXMAP:
@@ -327,7 +353,7 @@ static bool PVRDRI2DrawableGetInfo(PVRDRIDrawable *psPVRDrawable, bool bUpdate)
 			return false;
 	}
 
-	/* Note that psDRIBuffers must not be freed after it is no longer needed */
+	/* Do not free psDRIBuffers when finished with it */
 	psDRIBuffers = psDRIScreen->dri2.loader->getBuffersWithFormat(psDRIDrawable,
 								      &w,
 								      &h,
@@ -346,9 +372,10 @@ static bool PVRDRI2DrawableGetInfo(PVRDRIDrawable *psPVRDrawable, bool bUpdate)
 	 * distinguish between windows, pixmaps and pbuffers so we initially
 	 * assume we have a window. The situation slightly improves once
 	 * getBuffersWithFormat is called as we have the opportunity to
-	 * attempt to detect whether or not we have something else. Unfortunately,
-	 * we can never detect the difference between a pbuffer and pixmap so
-	 * rightly or wrongly the detection code below assumes we have a pbuffer.
+	 * attempt to detect whether or not we have something else.
+	 * Unfortunately, we can never detect the difference between a pbuffer
+	 * and pixmap so, rightly or wrongly, the detection code below assumes
+	 * we have a pbuffer.
 	 */
 	if (psPVRDrawable->eSurfaceType == PVRDRI_SURFACE_WINDOW)
 	{
@@ -380,68 +407,113 @@ static bool PVRDRI2DrawableGetInfo(PVRDRIDrawable *psPVRDrawable, bool bUpdate)
 		return false;
 	}
 
-	/*
-	 * If we're single buffered then check the name of the first buffer in the cache
-	 * (there should only be one) against the new name of the new DRI buffer. Otherwise
-	 * don't both as the name will change as part of swap buffers
-	 */
-	if (!psPVRDrawable->bDoubleBuffered)
+	psPVRDrawable->uDRI.sBuffer.sDRI = psDRIBuffers[i];
+	psPVRDrawable->uDRI.sBuffer.w = w;
+	psPVRDrawable->uDRI.sBuffer.h = h;
+
+	return true;
+}
+
+/***********************************************************************************
+ Function Name		: PVRDRI2DrawableCreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Create drawable.
+************************************************************************************/
+static bool PVRDRI2DrawableCreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+
+	if (!PVRDRI2DrawableGetNativeInfo(psPVRDrawable))
 	{
-		psPVRBuffer = PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
+		return false;
 	}
-	else
+
+	psDRIDrawable->w = psPVRDrawable->uDRI.sBuffer.w;
+	psDRIDrawable->h = psPVRDrawable->uDRI.sBuffer.h;
+	psPVRDrawable->uStride = psPVRDrawable->uDRI.sBuffer.sDRI.pitch;
+	psPVRDrawable->uBytesPerPixel = psPVRDrawable->uDRI.sBuffer.sDRI.cpp;
+
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache, &psPVRDrawable->uDRI.sBuffer.sDRI))
 	{
-		psPVRBuffer = NULL;
+		errorMessage("%s: Couldn't insert buffer into cache\n", __func__);
+		return false;
 	}
 
-	if (!bUpdate ||
-	    (psPVRBuffer && psPVRBuffer->uBacking.sDRI2.uiName != psDRIBuffers[i].name) ||
-	    psDRIDrawable->w != w ||
-	    psDRIDrawable->h != h ||
-	    psPVRDrawable->uStride != psDRIBuffers[i].pitch ||
-	    psPVRDrawable->uBytesPerPixel != psDRIBuffers[i].cpp)
+	if (!PVREGLDrawableCreate(psPVRDrawable->psPVRScreen->psImpl,
+				  psPVRDrawable->psImpl))
 	{
-		if (bUpdate)
-		{
-			PVRDRIMarkAllRenderSurfacesAsInvalid(psPVRDrawable);
-			PVRObjectCachePurge(psPVRDrawable->hBufferCache);
+		errorMessage("%s: Couldn't create EGL drawable\n", __func__);
+		return false;
+	}
 
-			bRecreate = true;
-		}
+	return true;
+}
 
-		psDRIDrawable->w = w;
-		psDRIDrawable->h = h;
-		psPVRDrawable->uStride = psDRIBuffers[i].pitch;
-		psPVRDrawable->uBytesPerPixel = psDRIBuffers[i].cpp;
-	}
+/***********************************************************************************
+ Function Name		: PVRDRI2DrawableRecreate
+ Inputs			: psPVRDrawable
+ Returns		: Boolean
+ Description		: Recreate a drawable, if necessary.
+************************************************************************************/
+static bool PVRDRI2DrawableRecreate(PVRDRIDrawable *psPVRDrawable)
+{
+	__DRIdrawable *psDRIDrawable = psPVRDrawable->psDRIDrawable;
+	PVRDRIBuffer *psPVRBuffer;
+	bool bRecreate;
+
+	/*
+	 * If we're single buffered, check the name of the first buffer
+	 * in the cache (there should only be one) against the new name of
+	 * the new DRI buffer. Otherwise don't, as the name will change as
+	 * part of swap buffers.
+	 */
+	psPVRBuffer = (psPVRDrawable->bDoubleBuffered) ? NULL :
+			PVRObjectCacheGetObject(psPVRDrawable->hBufferCache, 0);
 
-	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache, &psDRIBuffers[i]))
+
+	bRecreate = (psPVRBuffer &&
+			psPVRBuffer->uBacking.sDRI2.uiName !=
+				psPVRDrawable->uDRI.sBuffer.sDRI.name) ||
+		(psDRIDrawable->w != psPVRDrawable->uDRI.sBuffer.w) ||
+		(psDRIDrawable->h != psPVRDrawable->uDRI.sBuffer.h) ||
+		(psPVRDrawable->uStride !=
+			psPVRDrawable->uDRI.sBuffer.sDRI.pitch) ||
+		(psPVRDrawable->uBytesPerPixel !=
+			psPVRDrawable->uDRI.sBuffer.sDRI.cpp);
+
+	if (bRecreate)
 	{
-		errorMessage("%s: Couldn't insert buffer into cache\n", __func__);
-		return false;
+		PVRDRIMarkAllRenderSurfacesAsInvalid(psPVRDrawable);
+		PVRObjectCachePurge(psPVRDrawable->hBufferCache);
+
+		psDRIDrawable->w = psPVRDrawable->uDRI.sBuffer.w;
+		psDRIDrawable->h = psPVRDrawable->uDRI.sBuffer.h;
+		psPVRDrawable->uStride =
+			psPVRDrawable->uDRI.sBuffer.sDRI.pitch;
+		psPVRDrawable->uBytesPerPixel =
+			psPVRDrawable->uDRI.sBuffer.sDRI.cpp;
 	}
 
-	if (!bUpdate)
+	if (!PVRObjectCacheInsert(psPVRDrawable->hBufferCache,
+					&psPVRDrawable->uDRI.sBuffer.sDRI))
 	{
-		if (!PVREGLDrawableCreate(psPVRDrawable->psPVRScreen->psImpl,
-		                          psPVRDrawable->psImpl))
-		{
-			errorMessage("%s: Couldn't create EGL drawable\n", __func__);
-			return false;
-		}
+		errorMessage("%s: Couldn't insert buffer into cache\n",
+								__func__);
+		return false;
 	}
-	else if (bRecreate)
+
+	if (bRecreate)
 	{
 		if (!PVREGLDrawableRecreate(psPVRDrawable->psPVRScreen->psImpl,
 		                            psPVRDrawable->psImpl))
 		{
-			errorMessage("%s: Couldn't recreate EGL drawable\n", __func__);
+			errorMessage("%s: Couldn't recreate EGL drawable\n",
+								__func__);
 			return false;
 		}
 	}
 
-	psPVRDrawable->bDrawableInfoInvalid = false;
-
 	return true;
 }
 
@@ -522,33 +594,87 @@ static bool PVRDRI2ObjectCacheCompare(void *pvCreateData,
  PVR drawable local functions
 */ /**************************************************************************/
 
+/***********************************************************************************
+ Function Name		: PVRDRIDrawableUpdateNativeInfo
+ Inputs			: psPVRDrawable
+ Description		: Update native drawable information.
+************************************************************************************/
+bool PVRDRIDrawableUpdateNativeInfo(PVRDRIDrawable *psPVRDrawable)
+{
+	return (psPVRDrawable->psPVRScreen->psDRIScreen->image.loader) ?
+			PVRImageDrawableGetNativeInfo(psPVRDrawable) :
+			PVRDRI2DrawableGetNativeInfo(psPVRDrawable);
+}
+
 /*************************************************************************/ /*!
- Function Name	: PVRDRIDrawableGetInfo
+ Function Name	: PVRDRIDrawableCreate
  Inputs		: psPVRDrawable
- Returns	: Boolean
- Description	: Lock guarded drawable buffers update
+ Description	: Create drawable
 */ /**************************************************************************/
-bool PVRDRIDrawableGetInfo(PVRDRIDrawable *psPVRDrawable,
-                           bool bUpdate)
+bool PVRDRIDrawableRecreate(PVRDRIDrawable *psPVRDrawable)
 {
-	bool bInfoSync;
+	bool bRes;
 
 	PVRDRIDrawableLock(psPVRDrawable);
 
+	if (psPVRDrawable->psPVRScreen->bUseInvalidate)
+	{
+		if (!psPVRDrawable->bDrawableInfoInvalid)
+		{
+			PVRDRIDrawableUnlock(psPVRDrawable);
+			return true;
+		}
+	}
+
+	if (!psPVRDrawable->bDrawableInfoUpdated)
+	{
+		if (!PVRDRIDrawableUpdateNativeInfo(psPVRDrawable))
+		{
+			PVRDRIDrawableUnlock(psPVRDrawable);
+			return false;
+		}
+	}
+
 	if (psPVRDrawable->psPVRScreen->psDRIScreen->image.loader)
 	{
-		bInfoSync = PVRImageDrawableGetInfo(psPVRDrawable, bUpdate);
+		bRes = PVRImageDrawableRecreate(psPVRDrawable);
 	}
 	else
 	{
-		bInfoSync = PVRDRI2DrawableGetInfo(psPVRDrawable, bUpdate);
+		bRes = PVRDRI2DrawableRecreate(psPVRDrawable);
+	}
+
+	if (bRes)
+	{
+		psPVRDrawable->bDrawableInfoUpdated = false;
+		psPVRDrawable->bDrawableInfoInvalid = false;
 	}
 
 	PVRDRIDrawableUnlock(psPVRDrawable);
 
-	return bInfoSync;
+	return bRes;
 }
 
+/*************************************************************************/ /*!
+ Function Name	: PVRDRIDrawableCreate
+ Inputs		: psPVRDrawable
+ Description	: Create drawable
+*/ /**************************************************************************/
+bool PVRDRIDrawableCreate(PVRDRIDrawable *psPVRDrawable)
+{
+	bool bRes;
+
+	if (psPVRDrawable->psPVRScreen->psDRIScreen->image.loader)
+	{
+		bRes = PVRImageDrawableCreate(psPVRDrawable);
+	}
+	else
+	{
+		bRes = PVRDRI2DrawableCreate(psPVRDrawable);
+	}
+
+	return bRes;
+}
 
 /*************************************************************************/ /*!
  PVR drawable interface
@@ -595,7 +721,7 @@ bool PVRDRIDrawableInit(PVRDRIDrawable *psPVRDrawable,
 
 	psPVRDrawable->eSurfaceType = eSurfaceType;
 
-	if (!PVRDRIDrawableGetInfo(psPVRDrawable, false))
+	if (!PVRDRIDrawableCreate(psPVRDrawable))
 	{
 		PVRObjectCacheDestroy(psPVRDrawable->hBufferCache);
 		psPVRDrawable->hBufferCache = NULL;
diff --git a/src/mesa/drivers/dri/pvr/pvrdri.c b/src/mesa/drivers/dri/pvr/pvrdri.c
index f179871..826b9fb 100644
--- a/src/mesa/drivers/dri/pvr/pvrdri.c
+++ b/src/mesa/drivers/dri/pvr/pvrdri.c
@@ -786,7 +786,8 @@ static const __DRIconfig **PVRDRIInitScreen(__DRIscreen *psDRIScreen)
 	const __DRIconfig **configs;
 	uint32_t uiDisplayCount;
 	PVRDRICallbacks sDRICallbacks = {
-		.DrawableGetInfo             = PVRDRIDrawableGetInfo,
+		.DrawableCreate              = PVRDRIDrawableCreate,
+		.DrawableRecreate            = PVRDRIDrawableRecreate,
 		.DrawableGetDstBuffer        = PVRDRIDrawableGetDstBuffer,
 		.DrawableGetAccumBuffer      = PVRDRIDrawableGetAccumBuffer,
 		.DrawableGetParameters       = PVRDRIDrawableGetParameters,
@@ -1176,12 +1177,6 @@ static GLboolean PVRDRICreateBuffer(__DRIscreen *psDRIScreen,
 	psPVRDrawable->psPVRScreen = psPVRScreen;
 	psPVRDrawable->bDoubleBuffered = psGLMode->doubleBufferMode;
 
-	if (psPVRScreen->bUseInvalidate && !psPVRDrawable->bDoubleBuffered)
-	{
-		psPVRDrawable->bUseInvalidate = true;
-		psPVRDrawable->bDrawableInfoInvalid = true;
-	}
-
 	psPVRDrawable->ePixelFormat = PVRDRIGetPixelFormat(psGLMode);
 	if (psPVRDrawable->ePixelFormat == IMG_PIXFMT_UNKNOWN)
 	{
diff --git a/src/mesa/drivers/dri/pvr/pvrdri.h b/src/mesa/drivers/dri/pvr/pvrdri.h
index 05fe505..1561a95 100644
--- a/src/mesa/drivers/dri/pvr/pvrdri.h
+++ b/src/mesa/drivers/dri/pvr/pvrdri.h
@@ -139,18 +139,28 @@ typedef struct PVRDRIDrawable_TAG
 	/* IMG Pixel format for this drawable */
 	IMG_PIXFMT          ePixelFormat;
 
-	/* Use invalidate events to indicate when to get drawable info */
-	bool                bUseInvalidate;
-
-	/* If bUseInvalidate is true, indicates when drawable info is invalid */
+	/* Indicates the drawable info is invalid */
 	bool                bDrawableInfoInvalid;
 
+	/* Indicates updated drawable info is available */
+	bool                bDrawableInfoUpdated;
+
 	/* Buffer cache handle */
 	PVRObjectCache      hBufferCache;
 
 	/* Queue of buffers evicted from cache, waiting for flush */
 	PVRQHead            sCacheFlushHead;
 
+	union {
+		struct {
+			__DRIbuffer	sDRI;
+			int		w;
+			int		h;
+		} sBuffer;
+		struct {
+			__DRIimage	*psDRI;
+		} sImage;
+	} uDRI;
 	PVRDRIDrawableImpl *psImpl;
 } PVRDRIDrawable;
 
@@ -216,7 +226,6 @@ void PVRDRIThreadSetCurrentScreen(PVRDRIScreen *psPVRScreen);
 bool PVRDRIFlushBuffersForSwap(PVRDRIContext *psPVRContext,
                                PVRDRIDrawable *psPVRDrawable);
 
-
 /*************************************************************************/ /*!
  pvrutil.c
 */ /**************************************************************************/
@@ -252,7 +261,9 @@ bool PVRDRIDrawableInit(PVRDRIDrawable *psPVRDrawable,
 void PVRDRIDrawableDeinit(PVRDRIDrawable *psPVRDrawable);
 
 /* Callbacks into non-impl layer */
-bool PVRDRIDrawableGetInfo(PVRDRIDrawable *psPVRDrawable, bool bUpdate);
+bool PVRDRIDrawableUpdateNativeInfo(PVRDRIDrawable *psPVRDrawable);
+bool PVRDRIDrawableCreate(PVRDRIDrawable *psPVRDrawable);
+bool PVRDRIDrawableRecreate(PVRDRIDrawable *psPVRDrawable);
 PVRDRIBufferImpl *PVRDRIDrawableGetDstBuffer(PVRDRIDrawable *psPVRDrawable);
 PVRDRIBufferImpl *PVRDRIDrawableGetAccumBuffer(PVRDRIDrawable *psPVRDrawable);
 bool PVRDRIDrawableGetParameters(PVRDRIDrawable *psPVRDrawable,
diff --git a/src/mesa/drivers/dri/pvr/pvrext.c b/src/mesa/drivers/dri/pvr/pvrext.c
index 2f53ca1..f61ec37 100644
--- a/src/mesa/drivers/dri/pvr/pvrext.c
+++ b/src/mesa/drivers/dri/pvr/pvrext.c
@@ -76,8 +76,10 @@ THE SOFTWARE.
 #define PVR_DRI_PRIORITY_VERSION	1
 #define PVR_DRI2_FENCE_VERSION		1
 
-static void
-PVRDRIFlushAllContexts(PVRDRIDrawable *psPVRDrawable)
+/* IMG extension */
+#define	PVR_DRI_QUERY_BUFFERS_VERSION	1
+
+static void PVRDRIFlushAllContexts(PVRDRIDrawable *psPVRDrawable)
 {
 	PVRQElem *psQElem;
 
@@ -151,22 +153,32 @@ static __DRItexBufferExtension pvrDRITexBufferExtension =
 };
 
 
-static void PVRDRI2FlushDrawable(__DRIdrawable *psDRIDrawable)
+static void PVRDRI2Flush(__DRIdrawable *psDRIDrawable)
 {
 	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
 
-	//PVRDRIDrawableLock(psPVRDrawable);
+	PVRDRIDrawableLock(psPVRDrawable);
+
 	(void) PVRDRIFlushBuffersForSwap(NULL, psPVRDrawable);
-	//PVRDRIDrawableUnlock(psPVRDrawable);
+	/*
+	 * Work around for missing X Server invalidate events. Mark
+	 * the drawable as invalid, to force a query for new buffers.
+	 */
+	psPVRDrawable->bDrawableInfoInvalid = true;
+
+	PVRDRIDrawableUnlock(psPVRDrawable);
 }
 
-static void PVRDRI2InvalidateDrawable(__DRIdrawable *psDRIDrawable)
+static void PVRDRI2Invalidate(__DRIdrawable *psDRIDrawable)
 {
 	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
 
-	if (psPVRDrawable->bUseInvalidate)
+	if (psPVRDrawable->psPVRScreen->bUseInvalidate)
 	{
+		PVRDRIDrawableLock(psPVRDrawable);
 		psPVRDrawable->bDrawableInfoInvalid = true;
+		psPVRDrawable->bDrawableInfoUpdated = false;
+		PVRDRIDrawableUnlock(psPVRDrawable);
 	}
 }
 
@@ -183,7 +195,16 @@ static void PVRDRI2FlushWithFlags(__DRIcontext *psDRIContext,
 	{
 		PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *) psDRIDrawable->driverPrivate;
 
+		PVRDRIDrawableLock(psPVRDrawable);
+
 		(void) PVRDRIFlushBuffersForSwap(psPVRContext, psPVRDrawable);
+		/*
+		 * Work around for missing X Server invalidate events. Mark
+		 * the drawable as invalid, to force a query for new buffers.
+		 */
+		psPVRDrawable->bDrawableInfoInvalid = true;
+
+		PVRDRIDrawableUnlock(psPVRDrawable);
 	}
 	else if ((uFlags & __DRI2_FLUSH_CONTEXT) != 0)
 	{
@@ -197,8 +218,8 @@ static void PVRDRI2FlushWithFlags(__DRIcontext *psDRIContext,
 static __DRI2flushExtension pvrDRI2FlushExtension =
 {
 	.base			= { .name = __DRI2_FLUSH, .version = PVR_DRI2_FLUSH_VERSION },
-	.flush			= PVRDRI2FlushDrawable,
-	.invalidate		= PVRDRI2InvalidateDrawable,
+	.flush			= PVRDRI2Flush,
+	.invalidate		= PVRDRI2Invalidate,
 	.flush_with_flags	= PVRDRI2FlushWithFlags,
 };
 
@@ -250,6 +271,24 @@ const __DRI2fenceExtension pvrDRIFenceExtension =
 #endif /* defined(__DRI2_FENCE) */
 
 
+#if defined(__DRI_QUERY_BUFFERS)
+static void PVRDRIQueryBuffersEXT(__DRIdrawable *psDRIDrawable)
+{
+	PVRDRIDrawable *psPVRDrawable = (PVRDRIDrawable *)psDRIDrawable->driverPrivate;
+
+	PVRDRIDrawableLock(psPVRDrawable);
+	psPVRDrawable->bDrawableInfoUpdated =
+		 PVRDRIDrawableUpdateNativeInfo(psPVRDrawable);
+	PVRDRIDrawableUnlock(psPVRDrawable);
+}
+
+static __DRIqueryBuffersExtension pvrDRIQueryBuffers = 
+{
+	.base		= { .name = __DRI_QUERY_BUFFERS, .version = PVR_DRI_QUERY_BUFFERS_VERSION },
+	.query_buffers = PVRDRIQueryBuffersEXT
+};
+#endif /* defined(__DRI_QUERY_BUFFERS) */
+
 /*
  * Extension lists
  *
@@ -268,6 +307,9 @@ const __DRIextension *apsScreenExtensions[] =
 #if defined(__DRI2_FENCE)
 	&pvrDRIFenceExtension.base,
 #endif
+#if defined(__DRI_QUERY_BUFFERS)
+	&pvrDRIQueryBuffers.base,
+#endif
 	NULL
 };
 
@@ -283,5 +325,8 @@ const __DRIextension asScreenExtensionVersionInfo[] =
 #if defined(__DRI2_FENCE)
 	{ .name = __DRI2_FENCE, .version = __DRI2_FENCE_VERSION },
 #endif
+#if defined(__DRI_QUERY_BUFFERS)
+	{ .name = __DRI_QUERY_BUFFERS, .version = __DRI_QUERY_BUFFERS_VERSION },
+#endif
 	{ .name = NULL, .version = 0 },
 };
-- 
1.9.1

