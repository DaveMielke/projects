From 5741565defa5bbfc666576801c64ecfcd5be3c1a Mon Sep 17 00:00:00 2001
From: Tomasz Figa <tfiga@chromium.org>
Date: Wed, 13 Jul 2016 19:19:16 +0900
Subject: [PATCH 513/517] CHROMIUM: egl/android: Add fallback to kms_swrast
 driver

If no hardware driver is present, it is possible to fall back to
the kms_swrast driver with any DRI node that supports dumb GEM create
and mmap IOCTLs with softpipe/llvmpipe drivers. This patch makes the
Android EGL platform code retry probe with kms_swrast if hardware-only
probe fails.

BUG=b:29036398
TEST=No significant regressions in Android dEQP

Change-Id: Ida864d90a715d563090c0eb5caa8557684a8cb26
Signed-off-by: Tomasz Figa <tfiga@chromium.org>
---
 src/egl/drivers/dri2/platform_android.c | 23 ++++++++++++++---------
 1 file changed, 14 insertions(+), 9 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index 9c8156c..f0afca1 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -870,11 +870,14 @@ droid_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *dpy)
 }
 
 static int
-droid_probe_device(_EGLDisplay *dpy, int fd)
+droid_probe_device(_EGLDisplay *dpy, int fd, int swrast)
 {
    struct dri2_egl_display *dri2_dpy = dpy->DriverData;
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(fd, 0);
+   if (swrast)
+      dri2_dpy->driver_name = strdup("kms_swrast");
+   else
+      dri2_dpy->driver_name = loader_get_driver_for_fd(fd, 0);
    if (!dri2_dpy->driver_name)
       return -1;
 
@@ -891,7 +894,7 @@ droid_probe_device(_EGLDisplay *dpy, int fd)
 
 #ifdef HAS_GRALLOC_DRM_HEADERS
 static int
-droid_open_device(_EGLDisplay *dpy)
+droid_open_device(_EGLDisplay *dpy, int swrast)
 {
    const hw_module_t *mod;
    int fd = -1, err;
@@ -909,13 +912,13 @@ droid_open_device(_EGLDisplay *dpy)
       return -1;
    }
 
-   return droid_probe_device(dpy, fd);
+   return droid_probe_device(dpy, fd, swrast);
 }
 #else
 #define DRM_RENDER_DEV_NAME  "%s/renderD%d"
 
 static int
-droid_open_device(_EGLDisplay *dpy)
+droid_open_device(_EGLDisplay *dpy, int swrast)
 {
    struct dri2_egl_display *dri2_dpy = dpy->DriverData;
    const int limit = 64;
@@ -933,7 +936,7 @@ droid_open_device(_EGLDisplay *dpy)
       if (fd < 0)
          continue;
 
-      if (!droid_probe_device(dpy, fd))
+      if (!droid_probe_device(dpy, fd, swrast))
          return 0;
    }
 
@@ -1015,9 +1018,11 @@ dri2_initialize_android(_EGLDriver *drv, _EGLDisplay *dpy)
 
    dpy->DriverData = (void *) dri2_dpy;
 
-   if (droid_open_device(dpy) < 0) {
-      err = "DRI2: failed to open device";
-      goto cleanup_display;
+   if (droid_open_device(dpy, 0) < 0) {
+      if (droid_open_device(dpy, 1) < 0) {
+         err = "DRI2: failed to open device";
+         goto cleanup_display;
+      }
    }
 
    dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER;
-- 
2.8.0.rc3.226.g39d4020

