From 988e181eb2cc5d856edee3f0c0f205f6f208ac07 Mon Sep 17 00:00:00 2001
From: Gurchetan Singh <gurchetansingh@chromium.org>
Date: Fri, 22 Apr 2016 10:29:56 -0700
Subject: [PATCH 1/2] CHROMIUM: egl/surfaceless: Add pbuffer hooks

This change enables the creation of pbuffer
surfaces on the surfaceless platform.

BUG=b:27656575
BUG=chromium:606472
TEST=Ran dEQP GLES2, GLES3, and GLES31 tests on cyan and alex.
 Only ~100 tests should fail for GLES3 and GLES31 now on cyan.
 ~1000 GLES2 tests should fail on alex (GLES31/GLES3 tests are skipped).

Signed-off-by: Tomasz Figa <tfiga@chromium.org>
---
 src/egl/drivers/dri2/egl_dri2.h             |   7 +-
 src/egl/drivers/dri2/platform_surfaceless.c | 178 +++++++++++++++++++++++++++-
 2 files changed, 180 insertions(+), 5 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 52ad92b..d7587ae 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -289,8 +289,13 @@ struct dri2_egl_surface
    /* EGL-owned buffers */
    __DRIbuffer           *local_buffers[__DRI_BUFFER_COUNT];
 #endif
-};
 
+#if defined(HAVE_SURFACELESS_PLATFORM)
+      __DRIimage           *front;
+      unsigned int         format;
+#endif
+
+};
 
 struct dri2_egl_config
 {
diff --git a/src/egl/drivers/dri2/platform_surfaceless.c b/src/egl/drivers/dri2/platform_surfaceless.c
index 4d4b89d..66914b8 100644
--- a/src/egl/drivers/dri2/platform_surfaceless.c
+++ b/src/egl/drivers/dri2/platform_surfaceless.c
@@ -37,8 +37,168 @@
 #include "egl_dri2_fallbacks.h"
 #include "loader.h"
 
+static __DRIimage*
+surfaceless_alloc_image(struct dri2_egl_display *dri2_dpy,
+                     struct dri2_egl_surface *dri2_surf)
+{
+      __DRIimage *img = NULL;
+
+      img = dri2_dpy->image->createImage(
+               dri2_dpy->dri_screen,
+               dri2_surf->base.Width,
+               dri2_surf->base.Height,
+               dri2_surf->format,
+               0,
+               NULL);
+
+      return img;
+}
+
+static void
+surfaceless_free_images(struct dri2_egl_surface *dri2_surf)
+{
+   struct dri2_egl_display *dri2_dpy =
+      dri2_egl_display(dri2_surf->base.Resource.Display);
+
+   if(dri2_surf->front) {
+      dri2_dpy->image->destroyImage(dri2_surf->front);
+      dri2_surf->front = NULL;
+   }
+}
+
+static int
+surfaceless_image_get_buffers(__DRIdrawable *driDrawable,
+                        unsigned int format,
+                        uint32_t *stamp,
+                        void *loaderPrivate,
+                        uint32_t buffer_mask,
+                        struct __DRIimageList *buffers)
+{
+   struct dri2_egl_surface *dri2_surf = loaderPrivate;
+   struct dri2_egl_display *dri2_dpy =
+      dri2_egl_display(dri2_surf->base.Resource.Display);
+   buffers->image_mask = 0;
+   buffers->front = NULL;
+   buffers->back = NULL;
+
+   if (buffer_mask & __DRI_IMAGE_BUFFER_FRONT) {
+      if (!dri2_surf->front)
+         dri2_surf->front =
+            surfaceless_alloc_image(dri2_dpy, dri2_surf);
+
+      buffers->image_mask |= __DRI_IMAGE_BUFFER_FRONT;
+      buffers->front = dri2_surf->front;
+   }
+
+   return 1;
+}
+
+static _EGLSurface *
+dri2_surfaceless_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
+                        _EGLConfig *conf, void *native_surface,
+                        const EGLint *attrib_list)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_surface *dri2_surf;
+   const __DRIconfig *config;
+
+   // Make sure to calloc so front _DRIimage
+   // is originally NULL.
+   dri2_surf = calloc(1, sizeof *dri2_surf);
+
+   if(!dri2_surf)
+      return NULL;
+
+   if (!_eglInitSurface(&dri2_surf->base, disp, type, conf, attrib_list))
+      goto cleanup_surface;
+
+   config = dri2_get_dri_config(dri2_conf, type,
+                                dri2_surf->base.GLColorspace);
+
+   dri2_surf->dri_drawable =
+      (*dri2_dpy->dri2->createNewDrawable)(dri2_dpy->dri_screen, config,
+                                           dri2_surf);
+   if (dri2_surf->dri_drawable == NULL) {
+      _eglError(EGL_BAD_ALLOC, "dri2->createNewDrawable");
+      goto cleanup_surface;
+    }
+
+   if (conf->RedSize == 5)
+      dri2_surf->format = __DRI_IMAGE_FORMAT_RGB565;
+   else if (conf->AlphaSize == 0)
+      dri2_surf->format = __DRI_IMAGE_FORMAT_XRGB8888;
+   else
+      dri2_surf->format = __DRI_IMAGE_FORMAT_ARGB8888;
+
+   return &dri2_surf->base;
+
+   cleanup_surface:
+      free(dri2_surf);
+      return NULL;
+}
+
+static EGLBoolean
+surfaceless_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
+
+   if (!_eglPutSurface(surf))
+      return EGL_TRUE;
+
+   surfaceless_free_images(dri2_surf);
+
+   (*dri2_dpy->core->destroyDrawable)(dri2_surf->dri_drawable);
+
+   free(dri2_surf);
+   return EGL_TRUE;
+}
+
+static _EGLSurface *
+dri2_surfaceless_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *disp,
+                                _EGLConfig *conf, const EGLint *attrib_list)
+{
+   return dri2_surfaceless_create_surface(drv, disp, EGL_PBUFFER_BIT, conf,
+                                  NULL, attrib_list);
+}
+
+static EGLBoolean
+surfaceless_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *dpy)
+{
+
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
+
+   unsigned int visuals[3][4] = {
+      { 0xff0000, 0xff00, 0xff, 0xff000000 },   // ARGB8888
+      { 0xff0000, 0xff00, 0xff, 0x0 },          // RGB888
+      { 0xf800, 0x7e0, 0x1f, 0x0  },            // RGB565
+   };
+
+   int count, i, j;
+
+   count = 0;
+   for (i = 0; i < ARRAY_SIZE(visuals); i++) {
+      for (j = 0; dri2_dpy->driver_configs[j]; j++) {
+         const EGLint surface_type = EGL_WINDOW_BIT | EGL_PBUFFER_BIT;
+         struct dri2_egl_config *dri2_conf;
+         dri2_conf = dri2_add_config(dpy, dri2_dpy->driver_configs[j],
+               count + 1, surface_type, NULL, visuals[i]);
+         if (dri2_conf)
+            count++;
+      }
+   }
+
+   if (!count)
+         _eglLog(_EGL_DEBUG, "Can't create surfaceless visuals");
+
+   return (count != 0);
+}
+
 static struct dri2_egl_display_vtbl dri2_surfaceless_display_vtbl = {
    .create_pixmap_surface = dri2_fallback_create_pixmap_surface,
+   .create_pbuffer_surface = dri2_surfaceless_create_pbuffer_surface,
+   .destroy_surface = surfaceless_destroy_surface,
    .create_image = dri2_create_image_khr,
    .swap_interval = dri2_fallback_swap_interval,
    .swap_buffers_with_damage = dri2_fallback_swap_buffers_with_damage,
@@ -48,6 +208,7 @@ static struct dri2_egl_display_vtbl dri2_surfaceless_display_vtbl = {
    .query_buffer_age = dri2_fallback_query_buffer_age,
    .create_wayland_buffer_from_image = dri2_fallback_create_wayland_buffer_from_image,
    .get_sync_values = dri2_fallback_get_sync_values,
+   .get_dri_drawable = dri2_surface_get_dri_drawable,
 };
 
 static void
@@ -72,6 +233,12 @@ surfaceless_get_buffers_with_format(__DRIdrawable * driDrawable,
    return dri2_surf->buffers;
 }
 
+static const __DRIimageLoaderExtension image_loader_extension = {
+   .base             = { __DRI_IMAGE_LOADER, 1 },
+   .getBuffers       = surfaceless_image_get_buffers,
+   .flushFrontBuffer = surfaceless_flush_front_buffer,
+};
+
 #define DRM_RENDER_DEV_NAME  "%s/renderD%d"
 
 EGLBoolean
@@ -132,7 +299,7 @@ dri2_initialize_surfaceless(_EGLDriver *drv, _EGLDisplay *disp)
    dri2_dpy->dri2_loader_extension.getBuffersWithFormat =
       surfaceless_get_buffers_with_format;
 
-   dri2_dpy->extensions[0] = &dri2_dpy->dri2_loader_extension.base;
+   dri2_dpy->extensions[0] = &image_loader_extension.base;
    dri2_dpy->extensions[1] = &image_lookup_extension.base;
    dri2_dpy->extensions[2] = &use_invalidate.base;
    dri2_dpy->extensions[3] = NULL;
@@ -142,9 +309,9 @@ dri2_initialize_surfaceless(_EGLDriver *drv, _EGLDisplay *disp)
       goto cleanup_driver;
    }
 
-   for (i = 0; dri2_dpy->driver_configs[i]; i++) {
-      dri2_add_config(disp, dri2_dpy->driver_configs[i],
-                      i + 1, EGL_WINDOW_BIT, NULL, NULL);
+   if (!surfaceless_add_configs_for_visuals(drv, disp)) {
+      err = "DRI2: failed to add configs";
+      goto cleanup_screen;
    }
 
    disp->Extensions.KHR_image_base = EGL_TRUE;
@@ -156,6 +323,9 @@ dri2_initialize_surfaceless(_EGLDriver *drv, _EGLDisplay *disp)
 
    return EGL_TRUE;
 
+cleanup_screen:
+   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
+
 cleanup_driver:
    dlclose(dri2_dpy->driver);
    free(dri2_dpy->driver_name);
-- 
2.1.2

