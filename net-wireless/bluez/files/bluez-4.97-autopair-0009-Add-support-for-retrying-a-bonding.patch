From c19ad62a7dc07c89590716c704448b9d046a1e7e Mon Sep 17 00:00:00 2001
From: Scott James Remnant <scott@netsplit.com>
Date: Tue, 24 Jan 2012 10:34:01 -0800
Subject: [PATCH 09/13] Add support for retrying a bonding

In order to retry a bonding we need a timer that will perform the
retry, we need to stash the status and capability of the bonding
request so it can use them again, and in the case of a retrying
bonding attempt we need to not tear down the temporary D-Bus device
object on the adapter.
---
 src/adapter.c |    2 +-
 src/device.c  |   14 ++++++++++++++
 src/device.h  |    1 +
 3 files changed, 16 insertions(+), 1 deletions(-)

diff --git a/src/adapter.c b/src/adapter.c
index 2b58675..0274dab 100644
--- a/src/adapter.c
+++ b/src/adapter.c
@@ -3109,7 +3109,7 @@ void adapter_remove_connection(struct btd_adapter *adapter,
 	if (device_is_authenticating(device))
 		device_cancel_authentication(device, TRUE);
 
-	if (device_is_temporary(device)) {
+	if (device_is_temporary(device) && !device_is_retrying(device)) {
 		const char *path = device_get_path(device);
 
 		DBG("Removing temporary device %s", path);
diff --git a/src/device.c b/src/device.c
index 1726a61..17a9d49 100644
--- a/src/device.c
+++ b/src/device.c
@@ -86,6 +86,9 @@ struct bonding_req {
 	GIOChannel *io;
 	guint listener_id;
 	struct btd_device *device;
+	uint8_t capability;
+	uint8_t status;
+	guint retry_timer;
 };
 
 struct authentication_req {
@@ -2178,6 +2181,9 @@ static void bonding_request_free(struct bonding_req *bonding)
 	if (bonding->io)
 		g_io_channel_unref(bonding->io);
 
+	if (bonding->retry_timer)
+		g_source_remove(bonding->retry_timer);
+
 	device = bonding->device;
 	g_free(bonding);
 
@@ -2258,6 +2264,7 @@ proceed:
 
 	bonding->conn = dbus_connection_ref(conn);
 	bonding->msg = dbus_message_ref(msg);
+	bonding->capability = capability;
 
 	adapter_suspend_discovery(device->adapter);
 
@@ -2350,6 +2357,13 @@ static void device_auth_req_free(struct btd_device *device)
 	device->authr = NULL;
 }
 
+gboolean device_is_retrying(struct btd_device *device)
+{
+	struct bonding_req *bonding = device->bonding;
+
+	return bonding && bonding->retry_timer != 0;
+}
+
 void device_bonding_complete(struct btd_device *device, uint8_t status)
 {
 	struct bonding_req *bonding = device->bonding;
diff --git a/src/device.h b/src/device.h
index 38765da..314cb0f 100644
--- a/src/device.h
+++ b/src/device.h
@@ -80,6 +80,7 @@ void device_set_type(struct btd_device *device, device_type_t type);
 void device_set_bonded(struct btd_device *device, gboolean bonded);
 void device_set_auto_connect(struct btd_device *device, gboolean enable);
 gboolean device_is_connected(struct btd_device *device);
+gboolean device_is_retrying(struct btd_device *device);
 DBusMessage *device_create_bonding(struct btd_device *device,
 				DBusConnection *conn, DBusMessage *msg,
 				const char *agent_path, uint8_t capability);
-- 
1.7.7.3

