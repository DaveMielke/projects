From 7b823b8fe7d3d4b166852b8714abe52d4344d0fc Mon Sep 17 00:00:00 2001
From: Zhao Yakui <yakui.zhao@intel.com>
Date: Mon, 30 May 2016 09:55:59 -0400
Subject: [PATCH 4/8] Encoding: H264 uses the GPU to construct the PAK obj
 command on Gen8+

This is helpful to reduce the waiting time when preparing the command
buffer of PAK object.

Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
---
 src/gen8_mfc.c                            | 388 +++++++++++++++---------------
 src/shaders/utils/Makefile.am             |  30 ++-
 src/shaders/utils/mfc_batchbuffer_hsw.g8a |  28 +++
 src/shaders/utils/mfc_batchbuffer_hsw.g8b | 105 ++++++++
 src/shaders/utils/mfc_batchbuffer_hsw.g9a |  28 +++
 src/shaders/utils/mfc_batchbuffer_hsw.g9b | 105 ++++++++
 6 files changed, 481 insertions(+), 203 deletions(-)
 create mode 100644 src/shaders/utils/mfc_batchbuffer_hsw.g8a
 create mode 100644 src/shaders/utils/mfc_batchbuffer_hsw.g8b
 create mode 100644 src/shaders/utils/mfc_batchbuffer_hsw.g9a
 create mode 100644 src/shaders/utils/mfc_batchbuffer_hsw.g9b

diff --git a/src/gen8_mfc.c b/src/gen8_mfc.c
index 60e6362..1f8e57b 100644
--- a/src/gen8_mfc.c
+++ b/src/gen8_mfc.c
@@ -49,7 +49,7 @@
 #define SURFACE_STATE_OFFSET(index)             (SURFACE_STATE_PADDED_SIZE * index)
 #define BINDING_TABLE_OFFSET(index)             (SURFACE_STATE_OFFSET(MAX_MEDIA_SURFACES_GEN6) + sizeof(unsigned int) * index)
 
-#define MFC_SOFTWARE_HASWELL	1
+#define MFC_SOFTWARE_BATCH      0
 
 #define B0_STEP_REV		2
 #define IS_STEPPING_BPLUS(i965)	((i965->intel.revision) >= B0_STEP_REV)
@@ -101,32 +101,35 @@ static const int va_to_gen7_jpeg_hufftable[2] = {
     MFX_HUFFTABLE_ID_UV
 };
 
-static const uint32_t gen8_mfc_batchbuffer_avc_intra[][4] = {
-#include "shaders/utils/mfc_batchbuffer_avc_intra.g7b"
+static const uint32_t gen8_mfc_batchbuffer_avc[][4] = {
+#include "shaders/utils/mfc_batchbuffer_hsw.g8b"
 };
 
-static const uint32_t gen8_mfc_batchbuffer_avc_inter[][4] = {
-#include "shaders/utils/mfc_batchbuffer_avc_inter.g7b"
+static const uint32_t gen9_mfc_batchbuffer_avc[][4] = {
+#include "shaders/utils/mfc_batchbuffer_hsw.g9b"
 };
 
 static struct i965_kernel gen8_mfc_kernels[] = {
     {
         "MFC AVC INTRA BATCHBUFFER ",
         MFC_BATCHBUFFER_AVC_INTRA,
-        gen8_mfc_batchbuffer_avc_intra,
-        sizeof(gen8_mfc_batchbuffer_avc_intra),
+        gen8_mfc_batchbuffer_avc,
+        sizeof(gen8_mfc_batchbuffer_avc),
         NULL
     },
+};
 
+static struct i965_kernel gen9_mfc_kernels[] = {
     {
-        "MFC AVC INTER BATCHBUFFER ",
-        MFC_BATCHBUFFER_AVC_INTER,
-        gen8_mfc_batchbuffer_avc_inter,
-        sizeof(gen8_mfc_batchbuffer_avc_inter),
+        "MFC AVC INTRA BATCHBUFFER ",
+        MFC_BATCHBUFFER_AVC_INTRA,
+        gen9_mfc_batchbuffer_avc,
+        sizeof(gen9_mfc_batchbuffer_avc),
         NULL
     },
 };
 
+
 #define		INTER_MODE_MASK		0x03
 #define		INTER_8X8		0x03
 #define		INTER_16X8		0x01
@@ -570,7 +573,7 @@ static void gen8_mfc_init(VADriverContextP ctx,
     mfc_context->aux_batchbuffer_surface.num_blocks = mfc_context->aux_batchbuffer->size / 16;
     mfc_context->aux_batchbuffer_surface.size_block = 16;
 
-    i965_gpe_context_init(ctx, &mfc_context->gpe_context);
+    gen8_gpe_context_init(ctx, &mfc_context->gpe_context);
 }
 
 static void
@@ -930,8 +933,13 @@ gen8_mfc_avc_slice_state(VADriverContextP ctx,
     ADVANCE_BCS_BATCH(batch);
 }
 
+#define    AVC_INTRA_RDO_OFFSET    4
+#define    AVC_INTER_RDO_OFFSET    10
+#define    AVC_INTER_MSG_OFFSET    8
+#define    AVC_INTER_MV_OFFSET     48
+#define    AVC_RDO_MASK            0xFFFF
 
-#ifdef MFC_SOFTWARE_HASWELL
+#if MFC_SOFTWARE_BATCH
 
 static int
 gen8_mfc_avc_pak_object_intra(VADriverContextP ctx, int x, int y, int end_mb,
@@ -1082,12 +1090,6 @@ gen8_mfc_avc_pak_object_inter(VADriverContextP ctx, int x, int y, int end_mb, in
     return len_in_dwords;
 }
 
-#define		AVC_INTRA_RDO_OFFSET	4
-#define		AVC_INTER_RDO_OFFSET	10
-#define		AVC_INTER_MSG_OFFSET	8	
-#define		AVC_INTER_MV_OFFSET		48
-#define		AVC_RDO_MASK		0xFFFF
-
 static void 
 gen8_mfc_avc_pipeline_slice_programing(VADriverContextP ctx,
                                        struct encode_state *encode_state,
@@ -1221,7 +1223,6 @@ static void
 gen8_mfc_batchbuffer_surfaces_input(VADriverContextP ctx,
                                     struct encode_state *encode_state,
                                     struct intel_encoder_context *encoder_context)
-
 {
     struct gen6_vme_context *vme_context = encoder_context->vme_context;
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
@@ -1232,12 +1233,6 @@ gen8_mfc_batchbuffer_surfaces_input(VADriverContextP ctx,
                                      &vme_context->vme_output,
                                      BINDING_TABLE_OFFSET(BIND_IDX_VME_OUTPUT),
                                      SURFACE_STATE_OFFSET(BIND_IDX_VME_OUTPUT));
-    assert(mfc_context->aux_batchbuffer_surface.bo);
-    mfc_context->buffer_suface_setup(ctx,
-                                     &mfc_context->gpe_context,
-                                     &mfc_context->aux_batchbuffer_surface,
-                                     BINDING_TABLE_OFFSET(BIND_IDX_MFC_SLICE_HEADER),
-                                     SURFACE_STATE_OFFSET(BIND_IDX_MFC_SLICE_HEADER));
 }
 
 static void
@@ -1269,41 +1264,39 @@ gen8_mfc_batchbuffer_idrt_setup(VADriverContextP ctx,
                                 struct intel_encoder_context *encoder_context)
 {
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
-    struct gen6_interface_descriptor_data *desc;   
+    struct gen8_interface_descriptor_data *desc;
     int i;
     dri_bo *bo;
+    unsigned char *desc_ptr;
 
-    bo = mfc_context->gpe_context.idrt.bo;
+    bo = mfc_context->gpe_context.dynamic_state.bo;
     dri_bo_map(bo, 1);
     assert(bo->virtual);
-    desc = bo->virtual;
+    desc_ptr = (unsigned char *)bo->virtual + mfc_context->gpe_context.idrt_offset;
+
+    desc = (struct gen8_interface_descriptor_data *)desc_ptr;
 
     for (i = 0; i < mfc_context->gpe_context.num_kernels; i++) {
         struct i965_kernel *kernel;
-
         kernel = &mfc_context->gpe_context.kernels[i];
         assert(sizeof(*desc) == 32);
-
         /*Setup the descritor table*/
         memset(desc, 0, sizeof(*desc));
-        desc->desc0.kernel_start_pointer = (kernel->bo->offset >> 6);
-        desc->desc2.sampler_count = 0;
-        desc->desc2.sampler_state_pointer = 0;
-        desc->desc3.binding_table_entry_count = 2;
-        desc->desc3.binding_table_pointer = (BINDING_TABLE_OFFSET(0) >> 5);
-        desc->desc4.constant_urb_entry_read_offset = 0;
-        desc->desc4.constant_urb_entry_read_length = 4;
+        desc->desc0.kernel_start_pointer = kernel->kernel_offset >> 6;
+        desc->desc3.sampler_count = 0;
+        desc->desc3.sampler_state_pointer = 0;
+        desc->desc4.binding_table_entry_count = 1;
+        desc->desc4.binding_table_pointer = (BINDING_TABLE_OFFSET(0) >> 5);
+        desc->desc5.constant_urb_entry_read_offset = 0;
+        desc->desc5.constant_urb_entry_read_length = 4;
+
  		
-        /*kernel start*/
-        dri_bo_emit_reloc(bo,	
-                          I915_GEM_DOMAIN_INSTRUCTION, 0,
-                          0,
-                          i * sizeof(*desc) + offsetof(struct gen6_interface_descriptor_data, desc0),
-                          kernel->bo);
         desc++;
     }
 
     dri_bo_unmap(bo);
+
+    return;
 }
 
 static void
@@ -1316,147 +1309,129 @@ gen8_mfc_batchbuffer_constant_setup(VADriverContextP ctx,
     (void)mfc_context;
 }
 
+#define AVC_PAK_LEN_IN_BYTE	48
+#define AVC_PAK_LEN_IN_OWORD	3
+
 static void
 gen8_mfc_batchbuffer_emit_object_command(struct intel_batchbuffer *batch,
-                                         int index,
-                                         int head_offset,
-                                         int batchbuffer_offset,
-                                         int head_size,
-                                         int tail_size,
-                                         int number_mb_cmds,
-                                         int first_object,
-                                         int last_object,
-                                         int last_slice,
-                                         int mb_x,
-                                         int mb_y,
-                                         int width_in_mbs,
-                                         int qp)
+                                          uint32_t intra_flag,
+                                          int head_offset,
+                                          int number_mb_cmds,
+                                          int slice_end_x,
+                                          int slice_end_y,
+                                          int mb_x,
+                                          int mb_y,
+                                          int width_in_mbs,
+                                          int qp,
+					  uint32_t fwd_ref,
+					  uint32_t bwd_ref)
 {
-    BEGIN_BATCH(batch, 12);
+    uint32_t temp_value;
+    BEGIN_BATCH(batch, 14);
     
-    OUT_BATCH(batch, CMD_MEDIA_OBJECT | (12 - 2));
-    OUT_BATCH(batch, index);
+    OUT_BATCH(batch, CMD_MEDIA_OBJECT | (14 - 2));
+    OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
    
     /*inline data */
-    OUT_BATCH(batch, head_offset);
-    OUT_BATCH(batch, batchbuffer_offset);
-    OUT_BATCH(batch, 
-              head_size << 16 |
-              tail_size);
-    OUT_BATCH(batch,
-              number_mb_cmds << 16 |
-              first_object << 2 |
-              last_object << 1 |
-              last_slice);
-    OUT_BATCH(batch,
-              mb_y << 8 |
-              mb_x);
+    OUT_BATCH(batch, head_offset / 16);
+    OUT_BATCH(batch, (intra_flag) | (qp << 16));
+    temp_value = (mb_x | (mb_y << 8) | (width_in_mbs << 16));
+    OUT_BATCH(batch, temp_value);
+
+    OUT_BATCH(batch, number_mb_cmds);
+
     OUT_BATCH(batch,
-              qp << 16 |
-              width_in_mbs);
+              ((slice_end_y << 8) | (slice_end_x)));
+    OUT_BATCH(batch, fwd_ref);
+    OUT_BATCH(batch, bwd_ref);
+
+    OUT_BATCH(batch, MI_NOOP);
 
     ADVANCE_BATCH(batch);
 }
 
 static void
 gen8_mfc_avc_batchbuffer_slice_command(VADriverContextP ctx,
-                                       struct intel_encoder_context *encoder_context,
-                                       VAEncSliceParameterBufferH264 *slice_param,
-                                       int head_offset,
-                                       unsigned short head_size,
-                                       unsigned short tail_size,
-                                       int batchbuffer_offset,
-                                       int qp,
-                                       int last_slice)
+                                        struct intel_encoder_context *encoder_context,
+                                        VAEncSliceParameterBufferH264 *slice_param,
+                                        int head_offset,
+                                        int qp,
+                                        int last_slice)
 {
     struct intel_batchbuffer *batch = encoder_context->base.batch;
+    struct gen6_vme_context *vme_context = encoder_context->vme_context;
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
     int width_in_mbs = (mfc_context->surface_state.width + 15) / 16;
     int total_mbs = slice_param->num_macroblocks;
+    int slice_type = intel_avc_enc_slice_type_fixup(slice_param->slice_type);
     int number_mb_cmds = 128;
-    int starting_mb = 0;
-    int last_object = 0;
-    int first_object = 1;
-    int i;
+    int starting_offset = 0;
     int mb_x, mb_y;
-    int index = (slice_param->slice_type == SLICE_TYPE_I) ? MFC_BATCHBUFFER_AVC_INTRA : MFC_BATCHBUFFER_AVC_INTER;
+    int last_mb, slice_end_x, slice_end_y;
+    int remaining_mb = total_mbs;
+    uint32_t fwd_ref , bwd_ref, mb_flag;
 
-    for (i = 0; i < total_mbs / number_mb_cmds; i++) {
-        last_object = (total_mbs - starting_mb) == number_mb_cmds;
-        mb_x = (slice_param->macroblock_address + starting_mb) % width_in_mbs;
-        mb_y = (slice_param->macroblock_address + starting_mb) / width_in_mbs;
-        assert(mb_x <= 255 && mb_y <= 255);
+    last_mb = slice_param->macroblock_address + total_mbs - 1;
+    slice_end_x = last_mb % width_in_mbs;
+    slice_end_y = last_mb / width_in_mbs;
 
-        starting_mb += number_mb_cmds;
-
-        gen8_mfc_batchbuffer_emit_object_command(batch,
-                                                 index,
-                                                 head_offset,
-                                                 batchbuffer_offset,
-                                                 head_size,
-                                                 tail_size,
-                                                 number_mb_cmds,
-                                                 first_object,
-                                                 last_object,
-                                                 last_slice,
-                                                 mb_x,
-                                                 mb_y,
-                                                 width_in_mbs,
-                                                 qp);
-
-        if (first_object) {
-            head_offset += head_size;
-            batchbuffer_offset += head_size;
-        }
-
-        if (last_object) {
-            head_offset += tail_size;
-            batchbuffer_offset += tail_size;
-        }
-
-        batchbuffer_offset += number_mb_cmds * CMD_LEN_IN_OWORD;
+    if (slice_type == SLICE_TYPE_I) {
+	fwd_ref = 0;
+	bwd_ref = 0;
+	mb_flag = 1;
+    } else {
+	fwd_ref = vme_context->ref_index_in_mb[0];
+	bwd_ref = vme_context->ref_index_in_mb[1];
+	mb_flag = 0;
+    }
 
-        first_object = 0;
+    if (width_in_mbs >= 100) {
+	number_mb_cmds = width_in_mbs / 5;
+    } else if (width_in_mbs >= 80) {
+	number_mb_cmds = width_in_mbs / 4;
+    } else if (width_in_mbs >= 60) {
+	number_mb_cmds = width_in_mbs / 3;
+    } else if (width_in_mbs >= 40) {
+	number_mb_cmds = width_in_mbs / 2;
+    } else {
+	number_mb_cmds = width_in_mbs;
     }
 
-    if (!last_object) {
-        last_object = 1;
-        number_mb_cmds = total_mbs % number_mb_cmds;
-        mb_x = (slice_param->macroblock_address + starting_mb) % width_in_mbs;
-        mb_y = (slice_param->macroblock_address + starting_mb) / width_in_mbs;
-        assert(mb_x <= 255 && mb_y <= 255);
-        starting_mb += number_mb_cmds;
+    do {
+	if (number_mb_cmds >= remaining_mb) {
+		number_mb_cmds = remaining_mb;
+	}
+	mb_x = (slice_param->macroblock_address + starting_offset) % width_in_mbs;
+	mb_y = (slice_param->macroblock_address + starting_offset) / width_in_mbs;
 
         gen8_mfc_batchbuffer_emit_object_command(batch,
-                                                 index,
-                                                 head_offset,
-                                                 batchbuffer_offset,
-                                                 head_size,
-                                                 tail_size,
-                                                 number_mb_cmds,
-                                                 first_object,
-                                                 last_object,
-                                                 last_slice,
-                                                 mb_x,
-                                                 mb_y,
-                                                 width_in_mbs,
-                                                 qp);
-    }
+						  mb_flag,
+                                                  head_offset,
+                                                  number_mb_cmds,
+						  slice_end_x,
+						  slice_end_y,
+                                                  mb_x,
+                                                  mb_y,
+                                                  width_in_mbs,
+                                                  qp,
+						  fwd_ref,
+						  bwd_ref);
+
+	head_offset += (number_mb_cmds * AVC_PAK_LEN_IN_BYTE);
+	remaining_mb -= number_mb_cmds;
+	starting_offset += number_mb_cmds;
+    } while (remaining_mb > 0);
 }
-                          
-/*
- * return size in Owords (16bytes)
- */         
-static int
+
+static void
 gen8_mfc_avc_batchbuffer_slice(VADriverContextP ctx,
-                               struct encode_state *encode_state,
-                               struct intel_encoder_context *encoder_context,
-                               int slice_index,
-                               int batchbuffer_offset)
+                                struct encode_state *encode_state,
+                                struct intel_encoder_context *encoder_context,
+                                int slice_index)
 {
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
     struct intel_batchbuffer *slice_batch = mfc_context->aux_batchbuffer;
@@ -1470,8 +1445,6 @@ gen8_mfc_avc_batchbuffer_slice(VADriverContextP ctx,
     unsigned int rate_control_mode = encoder_context->rate_control_mode;
     unsigned int tail_data[] = { 0x0, 0x0 };
     long head_offset;
-    int old_used = intel_batchbuffer_used_size(slice_batch), used;
-    unsigned short head_size, tail_size;
     int slice_type = intel_avc_enc_slice_type_fixup(pSliceParameter->slice_type);
     int qp_slice;
 
@@ -1490,15 +1463,14 @@ gen8_mfc_avc_batchbuffer_slice(VADriverContextP ctx,
     assert(pPicParameter->pic_init_qp >= 0 && pPicParameter->pic_init_qp < 52);
     assert(qp >= 0 && qp < 52);
 
-    head_offset = old_used / 16;
     gen8_mfc_avc_slice_state(ctx,
-                             pPicParameter,
-                             pSliceParameter,
-                             encode_state,
-                             encoder_context,
-                             (rate_control_mode == VA_RC_CBR),
-                             qp_slice,
-                             slice_batch);
+                              pPicParameter,
+                              pSliceParameter,
+                              encode_state,
+                              encoder_context,
+                              (rate_control_mode == VA_RC_CBR),
+                              qp_slice,
+                              slice_batch);
 
     if (slice_index == 0)
         intel_mfc_avc_pipeline_header_programing(ctx, encode_state, encoder_context, slice_batch);
@@ -1506,11 +1478,20 @@ gen8_mfc_avc_batchbuffer_slice(VADriverContextP ctx,
     intel_avc_slice_insert_packed_data(ctx, encode_state, encoder_context, slice_index, slice_batch);
 
     intel_batchbuffer_align(slice_batch, 16); /* aligned by an Oword */
-    used = intel_batchbuffer_used_size(slice_batch);
-    head_size = (used - old_used) / 16;
-    old_used = used;
+    head_offset = intel_batchbuffer_used_size(slice_batch);
+
+    slice_batch->ptr += pSliceParameter->num_macroblocks * AVC_PAK_LEN_IN_BYTE;
 
-    /* tail */
+    gen8_mfc_avc_batchbuffer_slice_command(ctx,
+                                            encoder_context,
+                                            pSliceParameter,
+                                            head_offset,
+                                            qp,
+                                            last_slice);
+
+
+    /* Aligned for tail */
+    intel_batchbuffer_align(slice_batch, 16); /* aligned by an Oword */
     if (last_slice) {    
         mfc_context->insert_object(ctx,
                                    encoder_context,
@@ -1535,22 +1516,7 @@ gen8_mfc_avc_batchbuffer_slice(VADriverContextP ctx,
                                    slice_batch);
     }
 
-    intel_batchbuffer_align(slice_batch, 16); /* aligned by an Oword */
-    used = intel_batchbuffer_used_size(slice_batch);
-    tail_size = (used - old_used) / 16;
-
-   
-    gen8_mfc_avc_batchbuffer_slice_command(ctx,
-                                           encoder_context,
-                                           pSliceParameter,
-                                           head_offset,
-                                           head_size,
-                                           tail_size,
-                                           batchbuffer_offset,
-                                           qp,
-                                           last_slice);
-
-    return head_size + tail_size + pSliceParameter->num_macroblocks * CMD_LEN_IN_OWORD;
+    return;
 }
 
 static void
@@ -1558,19 +1524,41 @@ gen8_mfc_avc_batchbuffer_pipeline(VADriverContextP ctx,
                                   struct encode_state *encode_state,
                                   struct intel_encoder_context *encoder_context)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
     struct intel_batchbuffer *batch = encoder_context->base.batch;
-    int i, size, offset = 0;
-    intel_batchbuffer_start_atomic(batch, 0x4000); 
-    gen6_gpe_pipeline_setup(ctx, &mfc_context->gpe_context, batch);
+    int i;
+
+    intel_batchbuffer_start_atomic(batch, 0x4000);
+
+    if (IS_GEN9(i965->intel.device_info))
+        gen9_gpe_pipeline_setup(ctx, &mfc_context->gpe_context, batch);
+    else
+        gen8_gpe_pipeline_setup(ctx, &mfc_context->gpe_context, batch);
 
     for ( i = 0; i < encode_state->num_slice_params_ext; i++) {
-        size = gen8_mfc_avc_batchbuffer_slice(ctx, encode_state, encoder_context, i, offset);
-        offset += size;
+        gen8_mfc_avc_batchbuffer_slice(ctx, encode_state, encoder_context, i);
+    }
+    {
+        struct intel_batchbuffer *slice_batch = mfc_context->aux_batchbuffer;
+
+        intel_batchbuffer_align(slice_batch, 8);
+        BEGIN_BCS_BATCH(slice_batch, 2);
+        OUT_BCS_BATCH(slice_batch, 0);
+        OUT_BCS_BATCH(slice_batch, MI_BATCH_BUFFER_END);
+        ADVANCE_BCS_BATCH(slice_batch);
+
+        BEGIN_BATCH(batch, 2);
+        OUT_BATCH(batch, CMD_MEDIA_STATE_FLUSH);
+        OUT_BATCH(batch, 0);
+        ADVANCE_BATCH(batch);
     }
 
     intel_batchbuffer_end_atomic(batch);
     intel_batchbuffer_flush(batch);
+
+    if (IS_GEN9(i965->intel.device_info))
+        gen9_gpe_pipeline_end(ctx, &mfc_context->gpe_context, batch);
 }
 
 static void
@@ -1613,7 +1601,7 @@ gen8_mfc_avc_pipeline_programing(VADriverContextP ctx,
         return; 
     }
 
-#ifdef MFC_SOFTWARE_HASWELL
+#if MFC_SOFTWARE_BATCH
     slice_batch_bo = gen8_mfc_avc_software_batchbuffer(ctx, encode_state, encoder_context);
 #else
     slice_batch_bo = gen8_mfc_avc_hardware_batchbuffer(ctx, encode_state, encoder_context);
@@ -3713,7 +3701,7 @@ static void gen8_mfc_vp8_init(VADriverContextP ctx,
     mfc_context->aux_batchbuffer_surface.num_blocks = mfc_context->aux_batchbuffer->size / 16;
     mfc_context->aux_batchbuffer_surface.size_block = 16;
 
-    i965_gpe_context_init(ctx, &mfc_context->gpe_context);
+    gen8_gpe_context_init(ctx, &mfc_context->gpe_context);
 
     /* alloc vp8 encoding buffers*/
     dri_bo_unreference(mfc_context->vp8_state.frame_header_bo);
@@ -4480,7 +4468,7 @@ gen8_mfc_context_destroy(void *context)
         mfc_context->reference_surfaces[i].bo = NULL;  
     }
 
-    i965_gpe_context_destroy(&mfc_context->gpe_context);
+    gen8_gpe_context_destroy(&mfc_context->gpe_context);
 
     dri_bo_unreference(mfc_context->mfc_batchbuffer_surface.bo);
     mfc_context->mfc_batchbuffer_surface.bo = NULL;
@@ -4558,14 +4546,15 @@ static VAStatus gen8_mfc_pipeline(VADriverContextP ctx,
 
 Bool gen8_mfc_context_init(VADriverContextP ctx, struct intel_encoder_context *encoder_context)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct gen6_mfc_context *mfc_context = calloc(1, sizeof(struct gen6_mfc_context));
+
     assert(mfc_context);
     mfc_context->gpe_context.surface_state_binding_table.length = (SURFACE_STATE_PADDED_SIZE + sizeof(unsigned int)) * MAX_MEDIA_SURFACES_GEN6;
 
-    mfc_context->gpe_context.idrt.max_entries = MAX_GPE_KERNELS;
-    mfc_context->gpe_context.idrt.entry_size = sizeof(struct gen6_interface_descriptor_data);
-
-    mfc_context->gpe_context.curbe.length = 32 * 4;
+    mfc_context->gpe_context.idrt_size = sizeof(struct gen8_interface_descriptor_data) * MAX_INTERFACE_DESC_GEN6;
+    mfc_context->gpe_context.curbe_size = 32 * 4;
+    mfc_context->gpe_context.sampler_size = 0;
 
     mfc_context->gpe_context.vfe_state.max_num_threads = 60 - 1;
     mfc_context->gpe_context.vfe_state.num_urb_entries = 16;
@@ -4573,10 +4562,17 @@ Bool gen8_mfc_context_init(VADriverContextP ctx, struct intel_encoder_context *e
     mfc_context->gpe_context.vfe_state.urb_entry_size = 59 - 1;
     mfc_context->gpe_context.vfe_state.curbe_allocation_size = 37 - 1;
 
-    i965_gpe_load_kernels(ctx,
+    if (IS_GEN9(i965->intel.device_info)) {
+        gen8_gpe_load_kernels(ctx,
+                          &mfc_context->gpe_context,
+                          gen9_mfc_kernels,
+                          1);
+    } else {
+        gen8_gpe_load_kernels(ctx,
                           &mfc_context->gpe_context,
                           gen8_mfc_kernels,
-                          NUM_MFC_KERNEL);
+                          1);
+    }
 
     mfc_context->pipe_mode_select = gen8_mfc_pipe_mode_select;
     mfc_context->set_surface_state = gen8_mfc_surface_state;
diff --git a/src/shaders/utils/Makefile.am b/src/shaders/utils/Makefile.am
index 4a5d89d..1bffbb8 100644
--- a/src/shaders/utils/Makefile.am
+++ b/src/shaders/utils/Makefile.am
@@ -24,9 +24,14 @@ INTEL_G75A	= mfc_batchbuffer_hsw.g75a
 INTEL_GEN75_INC	= mfc_batchbuffer_hsw.inc
 INTEL_GEN75_ASM	= $(INTEL_G75A:%.g75a=%.gen75.asm)
 
-INTEL_G9B	= mfc_batchbuffer_avc_intra.g9b mfc_batchbuffer_avc_inter.g9b
-INTEL_G9A	= mfc_batchbuffer_avc_intra.g9a mfc_batchbuffer_avc_inter.g9a
-INTEL_GEN9_INC	= mfc_batchbuffer.inc
+INTEL_G8B	= mfc_batchbuffer_hsw.g8b
+INTEL_G8A	= mfc_batchbuffer_hsw.g8a
+INTEL_GEN8_INC	= mfc_batchbuffer_hsw.inc
+INTEL_GEN8_ASM	= $(INTEL_G9A:%.g9a=%.gen8.asm)
+
+INTEL_G9B	= mfc_batchbuffer_hsw.g9b
+INTEL_G9A	= mfc_batchbuffer_hsw.g9a
+INTEL_GEN9_INC	= mfc_batchbuffer_hsw.inc
 INTEL_GEN9_ASM	= $(INTEL_G9A:%.g9a=%.gen9.asm)
 
 TARGETS  =
@@ -34,12 +39,13 @@ if HAVE_GEN4ASM
 TARGETS += $(INTEL_G6B)
 TARGETS += $(INTEL_G7B)
 TARGETS += $(INTEL_G75B)
+TARGETS += $(INTEL_G8B)
 TARGETS += $(INTEL_G9B)
 endif
 
 all-local: $(TARGETS)
 
-SUFFIXES = .g6a .g6b .g7a .g7b .gen6.asm .gen7.asm .g75a .g75b .gen75.asm .g9a .g9b .gen9.asm
+SUFFIXES = .g6a .g6b .g7a .g7b .gen6.asm .gen7.asm .g75a .g75b .gen75.asm .g9a .g9b .gen9.asm .g8a .g8b .gen8.asm
 
 if HAVE_GEN4ASM
 $(INTEL_GEN6_ASM): $(MFC_CORE) $(MFC_CORE_AVC) $(INTEL_GEN6_INC)
@@ -66,9 +72,17 @@ $(INTEL_GEN75_ASM): $(MFC_CORE_HSW) $(INTEL_GEN75_INC)
 .gen75.asm.g75b:
 	$(AM_V_GEN)$(GEN4ASM) -g 7.5 -o $@ $<
 
-$(INTEL_GEN9_ASM): $(MFC_CORE) $(MFC_CORE_AVC) $(INTEL_GEN9_INC)
+$(INTEL_GEN8_ASM): $(MFC_CORE_HSW) $(INTEL_GEN8_INC)
+.g8a.gen8.asm:
+	$(AM_V_GEN)cpp -P $< > _mfc0.$@			&& \
+	m4 _mfc0.$@ > $@				&& \
+	rm _mfc0.$@
+.gen8.asm.g8b:
+	$(AM_V_GEN)$(GEN4ASM) -g 8 -o $@ $<
+
+$(INTEL_GEN9_ASM): $(MFC_CORE_HSW) $(INTEL_GEN8_INC)
 .g9a.gen9.asm:
-	$(AM_V_GEN)cpp -P -DDEV_IVB $< > _mfc0.$@ 	&& \
+	$(AM_V_GEN)cpp -P $< > _mfc0.$@			&& \
 	m4 _mfc0.$@ > $@				&& \
 	rm _mfc0.$@
 .gen9.asm.g9b:
@@ -76,7 +90,7 @@ $(INTEL_GEN9_ASM): $(MFC_CORE) $(MFC_CORE_AVC) $(INTEL_GEN9_INC)
 
 endif
 
-CLEANFILES = $(INTEL_GEN6_ASM) $(INTEL_GEN7_ASM) $(INTEL_GEN75_ASM) $(INTEL_GEN9_ASM)
+CLEANFILES = $(INTEL_GEN6_ASM) $(INTEL_GEN7_ASM) $(INTEL_GEN75_ASM) $(INTEL_GEN9_ASM) $(INTEL_GEN8_ASM)
 
 EXTRA_DIST = \
 	$(INTEL_G6A)		\
@@ -88,6 +102,8 @@ EXTRA_DIST = \
 	$(INTEL_GEN6_INC)	\
 	$(INTEL_GEN7_INC)	\
 	$(INTEL_GEN75_INC)	\
+	$(INTEL_G8A)		\
+	$(INTEL_G8B)		\
 	$(INTEL_G9A)		\
 	$(INTEL_G9B)		\
 	$(INTEL_GEN9_INC)	\
diff --git a/src/shaders/utils/mfc_batchbuffer_hsw.g8a b/src/shaders/utils/mfc_batchbuffer_hsw.g8a
new file mode 100644
index 0000000..dc39253
--- /dev/null
+++ b/src/shaders/utils/mfc_batchbuffer_hsw.g8a
@@ -0,0 +1,28 @@
+/*
+ * Copyright © 2010-2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Zhao Yakui <yakui.zhao@intel.com>
+ */
+
+#include "mfc_batchbuffer_hsw.inc"
+#include "mfc_batchbuffer_hsw.asm"
diff --git a/src/shaders/utils/mfc_batchbuffer_hsw.g8b b/src/shaders/utils/mfc_batchbuffer_hsw.g8b
new file mode 100644
index 0000000..cca39f5
--- /dev/null
+++ b/src/shaders/utils/mfc_batchbuffer_hsw.g8b
@@ -0,0 +1,105 @@
+   { 0x00800001, 0x23400608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x21e00608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x2b000608, 0x00000000, 0x00000000 },
+   { 0x00800001, 0x2ac00608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x2ac02248, 0x000000a8, 0x00000000 },
+   { 0x00000001, 0x2ac22248, 0x000000a9, 0x00000000 },
+   { 0x00000001, 0x2ae02248, 0x000000b0, 0x00000000 },
+   { 0x00000001, 0x2ae22248, 0x000000b1, 0x00000000 },
+   { 0x00000001, 0x2ae41248, 0x000000ac, 0x00000000 },
+   { 0x00000001, 0x2ae80608, 0x00000000, 0x00000002 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010001, 0x2ae80608, 0x00000000, 0x00000018 },
+   { 0x00000001, 0x21e80208, 0x000000a0, 0x00000000 },
+   { 0x00000001, 0x21f42288, 0x00000014, 0x00000000 },
+   { 0x00000041, 0x2b081208, 0x120000aa, 0x00000ac2 },
+   { 0x00000040, 0x2b080208, 0x12000b08, 0x00000ac0 },
+   { 0x00000041, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000001, 0x2b142288, 0x00000014, 0x00000000 },
+   { 0x00000001, 0x23400608, 0x00000000, 0x7149000a },
+   { 0x00000001, 0x23540608, 0x00000000, 0x000f000f },
+   { 0x00000001, 0x23680608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23582288, 0x000000a6, 0x00000000 },
+   { 0x00600001, 0x2b400208, 0x008d0b00, 0x00000000 },
+   { 0x00000001, 0x23500608, 0x00000000, 0xffff0000 },
+   { 0x00000001, 0x21002288, 0x00000ac0, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000ac2, 0x00000000 },
+   { 0x00000001, 0x23501248, 0x00000100, 0x00000000 },
+   { 0x00000001, 0x235a1648, 0x10000000, 0x00000000 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x00000ae0 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x12000ac2, 0x00000ae2 },
+   { 0x00010001, 0x235a1648, 0x10000000, 0x04000400 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000040 },
+   { 0x0a800031, 0x2b600a08, 0x0e000b40, 0x02180200 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x00000240 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x0e000b40, 0x02280300 },
+   { 0x05000010, 0x20001260, 0x12000b70, 0x00000b88 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000001f0 },
+   { 0x00000005, 0x234c0208, 0x06000b80, 0x1f00ffff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e0000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x00000001, 0x23440608, 0x00000000, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00030003 },
+   { 0x00110040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000050 },
+   { 0x02000005, 0x20001200, 0x16000b84, 0xff00ff00 },
+   { 0x00010001, 0x23440608, 0x00000000, 0x00000080 },
+   { 0x00010040, 0x234c0208, 0x0600034c, 0x00600000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000000c0 },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00000000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000080 },
+   { 0x00000040, 0x2b480208, 0x06000b48, 0x00000003 },
+   { 0x0a800031, 0x2ba00a08, 0x0e000b40, 0x02480400 },
+   { 0x00200001, 0x2ba80208, 0x00450bc0, 0x00000000 },
+   { 0x00200001, 0x2bb00208, 0x00450be0, 0x00000000 },
+   { 0x00200001, 0x2bb80208, 0x00450c00, 0x00000000 },
+   { 0x00600001, 0x28000208, 0x008d0b40, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0ba0, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x0e000800, 0x040a0200 },
+   { 0x00000001, 0x23600208, 0x000000b4, 0x00000000 },
+   { 0x00000001, 0x23640208, 0x000000b8, 0x00000000 },
+   { 0x00000001, 0x235c0608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c2288, 0x00000b85, 0x00000000 },
+   { 0x00000001, 0x235d2288, 0x00000b86, 0x00000000 },
+   { 0x00000040, 0x21040208, 0x06000b08, 0x00000003 },
+   { 0x00000041, 0x23480208, 0x06000104, 0x00000010 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x000000b0 },
+   { 0x00200001, 0x23440608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c0208, 0x00000b64, 0x00000000 },
+   { 0x00000001, 0x23600208, 0x00000b68, 0x00000000 },
+   { 0x00000001, 0x23640608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23642288, 0x00000b6c, 0x00000000 },
+   { 0x00000005, 0x234c0208, 0x06000b60, 0x0000c0ff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e2000 },
+   { 0x00000001, 0x21000608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000b62, 0x00000000 },
+   { 0x00000005, 0x21001248, 0x16000100, 0x1f001f00 },
+   { 0x00000040, 0x234c0208, 0x0200034c, 0x00000100 },
+   { 0x00600001, 0x28000208, 0x008d01e0, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0340, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x0e000800, 0x040a0202 },
+   { 0x00000040, 0x28080208, 0x06000808, 0x00000002 },
+   { 0x00600001, 0x28200208, 0x008d0360, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x0e000800, 0x040a0002 },
+   { 0x00000040, 0x2ac41248, 0x16000ac4, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac4, 0x00000ae4 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000090 },
+   { 0x00000040, 0x21e80208, 0x160001e8, 0x00030003 },
+   { 0x00000040, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000040, 0x2ac01248, 0x16000ac0, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x000000aa },
+   { 0x00010040, 0x2ac21248, 0x16000ac2, 0x00010001 },
+   { 0x00010001, 0x2ac01648, 0x10000000, 0x00000000 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0xfffffb30 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x0e000800, 0x0219e002 },
+   { 0x00600001, 0x2e000208, 0x008d0000, 0x00000000 },
+   { 0x07000031, 0x24000a40, 0x0e000e00, 0x82000010 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
diff --git a/src/shaders/utils/mfc_batchbuffer_hsw.g9a b/src/shaders/utils/mfc_batchbuffer_hsw.g9a
new file mode 100644
index 0000000..dc39253
--- /dev/null
+++ b/src/shaders/utils/mfc_batchbuffer_hsw.g9a
@@ -0,0 +1,28 @@
+/*
+ * Copyright © 2010-2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Zhao Yakui <yakui.zhao@intel.com>
+ */
+
+#include "mfc_batchbuffer_hsw.inc"
+#include "mfc_batchbuffer_hsw.asm"
diff --git a/src/shaders/utils/mfc_batchbuffer_hsw.g9b b/src/shaders/utils/mfc_batchbuffer_hsw.g9b
new file mode 100644
index 0000000..40812fb
--- /dev/null
+++ b/src/shaders/utils/mfc_batchbuffer_hsw.g9b
@@ -0,0 +1,105 @@
+   { 0x00800001, 0x23400608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x21e00608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x2b000608, 0x00000000, 0x00000000 },
+   { 0x00800001, 0x2ac00608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x2ac02248, 0x000000a8, 0x00000000 },
+   { 0x00000001, 0x2ac22248, 0x000000a9, 0x00000000 },
+   { 0x00000001, 0x2ae02248, 0x000000b0, 0x00000000 },
+   { 0x00000001, 0x2ae22248, 0x000000b1, 0x00000000 },
+   { 0x00000001, 0x2ae41248, 0x000000ac, 0x00000000 },
+   { 0x00000001, 0x2ae80608, 0x00000000, 0x00000002 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010001, 0x2ae80608, 0x00000000, 0x00000018 },
+   { 0x00000001, 0x21e80208, 0x000000a0, 0x00000000 },
+   { 0x00000001, 0x21f42288, 0x00000014, 0x00000000 },
+   { 0x00000041, 0x2b081208, 0x120000aa, 0x00000ac2 },
+   { 0x00000040, 0x2b080208, 0x12000b08, 0x00000ac0 },
+   { 0x00000041, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000001, 0x2b142288, 0x00000014, 0x00000000 },
+   { 0x00000001, 0x23400608, 0x00000000, 0x7149000a },
+   { 0x00000001, 0x23540608, 0x00000000, 0x000f000f },
+   { 0x00000001, 0x23680608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23582288, 0x000000a6, 0x00000000 },
+   { 0x00600001, 0x2b400208, 0x008d0b00, 0x00000000 },
+   { 0x00000001, 0x23500608, 0x00000000, 0xffff0000 },
+   { 0x00000001, 0x21002288, 0x00000ac0, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000ac2, 0x00000000 },
+   { 0x00000001, 0x23501248, 0x00000100, 0x00000000 },
+   { 0x00000001, 0x235a1648, 0x10000000, 0x00000000 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x00000ae0 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x12000ac2, 0x00000ae2 },
+   { 0x00010001, 0x235a1648, 0x10000000, 0x04000400 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000040 },
+   { 0x0a800031, 0x2b600a08, 0x06000b40, 0x02180200 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x00000240 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x06000b40, 0x02280300 },
+   { 0x05000010, 0x20001260, 0x12000b70, 0x00000b88 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000001f0 },
+   { 0x00000005, 0x234c0208, 0x06000b80, 0x1f00ffff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e0000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x00000001, 0x23440608, 0x00000000, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00030003 },
+   { 0x00110040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000050 },
+   { 0x02000005, 0x20001200, 0x16000b84, 0xff00ff00 },
+   { 0x00010001, 0x23440608, 0x00000000, 0x00000080 },
+   { 0x00010040, 0x234c0208, 0x0600034c, 0x00600000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000000c0 },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00000000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000080 },
+   { 0x00000040, 0x2b480208, 0x06000b48, 0x00000003 },
+   { 0x0a800031, 0x2ba00a08, 0x06000b40, 0x02480400 },
+   { 0x00200001, 0x2ba80208, 0x00450bc0, 0x00000000 },
+   { 0x00200001, 0x2bb00208, 0x00450be0, 0x00000000 },
+   { 0x00200001, 0x2bb80208, 0x00450c00, 0x00000000 },
+   { 0x00600001, 0x28000208, 0x008d0b40, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0ba0, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x06000800, 0x040a0200 },
+   { 0x00000001, 0x23600208, 0x000000b4, 0x00000000 },
+   { 0x00000001, 0x23640208, 0x000000b8, 0x00000000 },
+   { 0x00000001, 0x235c0608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c2288, 0x00000b85, 0x00000000 },
+   { 0x00000001, 0x235d2288, 0x00000b86, 0x00000000 },
+   { 0x00000040, 0x21040208, 0x06000b08, 0x00000003 },
+   { 0x00000041, 0x23480208, 0x06000104, 0x00000010 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x000000b0 },
+   { 0x00200001, 0x23440608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c0208, 0x00000b64, 0x00000000 },
+   { 0x00000001, 0x23600208, 0x00000b68, 0x00000000 },
+   { 0x00000001, 0x23640608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23642288, 0x00000b6c, 0x00000000 },
+   { 0x00000005, 0x234c0208, 0x06000b60, 0x0000c0ff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e2000 },
+   { 0x00000001, 0x21000608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000b62, 0x00000000 },
+   { 0x00000005, 0x21001248, 0x16000100, 0x1f001f00 },
+   { 0x00000040, 0x234c0208, 0x0200034c, 0x00000100 },
+   { 0x00600001, 0x28000208, 0x008d01e0, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0340, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x06000800, 0x040a0202 },
+   { 0x00000040, 0x28080208, 0x06000808, 0x00000002 },
+   { 0x00600001, 0x28200208, 0x008d0360, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x06000800, 0x040a0002 },
+   { 0x00000040, 0x2ac41248, 0x16000ac4, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac4, 0x00000ae4 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000090 },
+   { 0x00000040, 0x21e80208, 0x160001e8, 0x00030003 },
+   { 0x00000040, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000040, 0x2ac01248, 0x16000ac0, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x000000aa },
+   { 0x00010040, 0x2ac21248, 0x16000ac2, 0x00010001 },
+   { 0x00010001, 0x2ac01648, 0x10000000, 0x00000000 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0xfffffb30 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x06000800, 0x0219e002 },
+   { 0x00600001, 0x2e000208, 0x008d0000, 0x00000000 },
+   { 0x07000031, 0x24000a40, 0x06000e00, 0x82000010 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
-- 
2.5.5

