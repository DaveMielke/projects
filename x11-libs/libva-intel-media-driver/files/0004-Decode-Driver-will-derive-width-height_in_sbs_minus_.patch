From ec5a5a95686536ff08e9d8b62530985ccd95fd7c Mon Sep 17 00:00:00 2001
From: LiZefu <zefu.li@intel.com>
Date: Thu, 15 Oct 2020 16:36:54 +0800
Subject: [PATCH] Driver will derive width/height_in_sbs_minus_1 when
 uniform_tile_spacing_flag=1 for AV1d

[Decode] Driver will derive width/height_in_sbs_minus_1 when uniform_tile_spacing_flag=1 for AV1d
Driver should derive these params per libva definition

Change-Id: I8023d7378bb61bba0b6821513f11a60ab2f9de9b
---
 .../codec/ddi/media_ddi_decode_av1_g12.cpp    | 49 ++++++++++++++++---
 1 file changed, 42 insertions(+), 7 deletions(-)

diff --git a/media_driver/linux/gen12/codec/ddi/media_ddi_decode_av1_g12.cpp b/media_driver/linux/gen12/codec/ddi/media_ddi_decode_av1_g12.cpp
index 6b9a5c4f3fe2..8244644a2e26 100644
--- a/media_driver/linux/gen12/codec/ddi/media_ddi_decode_av1_g12.cpp
+++ b/media_driver/linux/gen12/codec/ddi/media_ddi_decode_av1_g12.cpp
@@ -94,6 +94,12 @@ VAStatus DdiDecodeAV1::ParseTileParams(
     return VA_STATUS_SUCCESS;
 }
 
+static uint32_t CalcAv1TileLog2(uint32_t blockSize, uint32_t target)
+{
+    uint32_t k;
+    for (k = 0; (blockSize << k) < target; k++) {}
+    return k;
+}
 
 /**
  * @brief AV1 Picture paramter parser
@@ -337,12 +343,6 @@ VAStatus DdiDecodeAV1::ParsePicParams(
 
     //Frame level lossless flag is set to true when all segments are lossless
     picAV1Params->m_losslessMode = allLossless;
-    picAV1Params->m_tileCols     = picParam->tile_cols;
-    MOS_SecureMemcpy(picAV1Params->m_widthInSbsMinus1, 63 * sizeof(uint16_t),
-                     picParam->width_in_sbs_minus_1,   63 * sizeof(uint16_t));
-    picAV1Params->m_tileRows     = picParam->tile_rows;
-    MOS_SecureMemcpy(picAV1Params->m_heightInSbsMinus1, 63 * sizeof(uint16_t),
-                     picParam->height_in_sbs_minus_1,   63 * sizeof(uint16_t));
 
     picAV1Params->m_tileCountMinus1 = picParam->tile_count_minus_1;
     picAV1Params->m_contextUpdateTileId = picParam->context_update_tile_id;
@@ -407,10 +407,45 @@ VAStatus DdiDecodeAV1::ParsePicParams(
 
     picAV1Params->m_frameHeightMinus1 = picParam->frame_height_minus1;
 
+    picAV1Params->m_tileCols     = picParam->tile_cols;
+    picAV1Params->m_tileRows     = picParam->tile_rows;
+
+    if (picParam->pic_info_fields.bits.uniform_tile_spacing_flag)
+    {
+        const uint32_t maxMibSizeLog2   = 5;
+        const uint32_t minMibSizeLog2   = 4;
+        const uint32_t miSizeLog2       = 2;
+        int32_t mibSizeLog2 = picParam->seq_info_fields.fields.use_128x128_superblock ? maxMibSizeLog2 : minMibSizeLog2;
+        int32_t miCols = MOS_ALIGN_CEIL(MOS_ALIGN_CEIL(picAV1Params->m_frameWidthMinus1 + 1, 8) >> miSizeLog2, 1 << mibSizeLog2);
+        int32_t miRows = MOS_ALIGN_CEIL(MOS_ALIGN_CEIL(picAV1Params->m_frameHeightMinus1 + 1, 8) >> miSizeLog2, 1 << mibSizeLog2);
+        int32_t sbCols = miCols >> mibSizeLog2;
+        int32_t sbRows = miRows >> mibSizeLog2;
+
+        for (auto i = 0; i < picParam->tile_cols - 1; i++)
+        {
+            uint32_t tileColsLog2 = CalcAv1TileLog2(1, picParam->tile_cols);
+            uint32_t sizeSb = MOS_ALIGN_CEIL(sbCols, 1 << tileColsLog2);
+            sizeSb >>= tileColsLog2;
+            picParam->width_in_sbs_minus_1[i] = sizeSb - 1;
+        }
+
+        for (auto i = 0; i < picParam->tile_rows - 1; i++)
+        {
+            uint32_t tileRowsLog2 = CalcAv1TileLog2(1, picParam->tile_rows);
+            uint32_t sizeSb = MOS_ALIGN_CEIL(sbRows, 1 << tileRowsLog2);
+            sizeSb >>= tileRowsLog2;
+            picParam->height_in_sbs_minus_1[i] = sizeSb - 1;
+        }
+    }
+
+    MOS_SecureMemcpy(picAV1Params->m_widthInSbsMinus1, 63 * sizeof(uint16_t),
+                     picParam->width_in_sbs_minus_1,   63 * sizeof(uint16_t));
+    MOS_SecureMemcpy(picAV1Params->m_heightInSbsMinus1, 63 * sizeof(uint16_t),
+                     picParam->height_in_sbs_minus_1,   63 * sizeof(uint16_t));
+
     return VA_STATUS_SUCCESS;
 }
 
-
 VAStatus DdiDecodeAV1::SetDecodeParams()
 {
      DDI_CHK_RET(DdiMediaDecode::SetDecodeParams(),"SetDecodeParams failed!");
-- 
2.25.1

