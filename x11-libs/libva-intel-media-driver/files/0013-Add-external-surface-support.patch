From 587a8c38326d5526c1f61561c7ba5c47c1962c78 Mon Sep 17 00:00:00 2001
From: Sudarshan S <sudarshan.s@intel.com>
Date: Thu, 16 Apr 2020 16:57:21 +0530
Subject: [PATCH] Add external surface support for iHD-19.4.1

Add external surface support, optimize VAImage creation,
modify GetImage to copy with each plane

Backported to 19.4.1 from
https://github.com/intel/media-driver/commit/922195ddd0ac5fef96b7b6a9986b2958908c3eb6

From: Chen_JasonK <jason.k.chen@intel.com>
Date: Wed, 25 Mar 2020 10:08:19 +0800
Subject: [PATCH] [VP] Add external surface support
---
 media_driver/linux/common/ddi/media_libva.cpp | 653 ++++++++++--------
 .../linux/common/ddi/media_libva_util.cpp     |   2 +-
 .../linux/common/os/mos_os_specific.c         |   2 +-
 .../linux/common/os/mos_os_specific.h         |   1 +
 .../linux/common/vp/ddi/media_libva_vp.c      | 158 +++--
 5 files changed, 475 insertions(+), 341 deletions(-)

diff --git a/media_driver/linux/common/ddi/media_libva.cpp b/media_driver/linux/common/ddi/media_libva.cpp
index c80f0e70..ab051f91 100755
--- a/media_driver/linux/common/ddi/media_libva.cpp
+++ b/media_driver/linux/common/ddi/media_libva.cpp
@@ -3885,54 +3885,8 @@ VAStatus DdiMedia_CreateImage(
     GMM_RESOURCE_INFO          *gmmResourceInfo;
     MOS_ZeroMemory(&gmmParams, sizeof(gmmParams));
 
-    switch(format->fourcc)
-    {
-        case VA_FOURCC_RGBA:
-        case VA_FOURCC_BGRA:
-        case VA_FOURCC_ARGB:
-        case VA_FOURCC_ABGR:
-        case VA_FOURCC_BGRX:
-        case VA_FOURCC_RGBX:
-        case VA_FOURCC_XRGB:
-        case VA_FOURCC_XBGR:
-        case VA_FOURCC_R8G8B8:
-        case VA_FOURCC_RGB565:
-        case VA_FOURCC_RGBP:
-        case VA_FOURCC_BGRP:
-        case VA_FOURCC_YV12:
-        case VA_FOURCC_I420:
-        case VA_FOURCC_IYUV:
-        case VA_FOURCC_A2R10G10B10:
-        case VA_FOURCC_A2B10G10R10:
-            gmmParams.BaseHeight        = height;
-            gmmParams.Flags.Info.Linear = true;
-            break;
-        case VA_FOURCC_YUY2:
-        case VA_FOURCC_AYUV:
-        case VA_FOURCC_Y210:
-        case VA_FOURCC_Y410:
-        case VA_FOURCC_Y416:
-        case VA_FOURCC_NV12:
-        case VA_FOURCC_NV21:
-        case VA_FOURCC_P010:
-        case VA_FOURCC_P016:
-        case VA_FOURCC_411P:
-        case VA_FOURCC_422H:
-        case VA_FOURCC_444P:
-        case VA_FOURCC_422V:
-        case VA_FOURCC_IMC3:
-        case VA_FOURCC_Y800:
-        case VA_FOURCC_VYUY:
-        case VA_FOURCC_YVYU:
-        case VA_FOURCC_UYVY:
-            gmmParams.BaseHeight = MOS_ALIGN_CEIL(height, 32);
-            break;
-        default:
-            MOS_FreeMemory(vaimg);
-            return VA_STATUS_ERROR_UNIMPLEMENTED;
-    }
-
     gmmParams.BaseWidth       = width;
+    gmmParams.BaseHeight      = height;
     gmmParams.ArraySize       = 1;
     gmmParams.Type            = RESOURCE_2D;
     gmmParams.Flags.Gpu.Video = true;
@@ -3952,15 +3906,30 @@ VAStatus DdiMedia_CreateImage(
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
     }
 
-    uint32_t    gmmPitch  = (uint32_t)gmmResourceInfo->GetRenderPitch();
-    uint32_t    gmmHeight = (uint32_t)gmmResourceInfo->GetBaseHeight();
+    // Get offset from GMM
+    GMM_REQ_OFFSET_INFO reqInfo = {0};
+	reqInfo.Plane = GMM_PLANE_U;
 
-    vaimg->format                = *format;
-    vaimg->format.byte_order     = VA_LSB_FIRST;
-    vaimg->width                 = width;
-    vaimg->height                = height;
-    vaimg->data_size             = (uint32_t)gmmResourceInfo->GetSizeSurface();
-    vaimg->format.bits_per_pixel = gmmResourceInfo->GetBitsPerPixel();
+	reqInfo.ReqRender = 1;
+	gmmResourceInfo->GetOffset(reqInfo);
+
+	uint32_t offsetU = reqInfo.Render.Offset;
+
+	MOS_ZeroMemory(&reqInfo, sizeof(GMM_REQ_OFFSET_INFO));
+
+	reqInfo.Plane             = GMM_PLANE_V;
+	reqInfo.ReqRender         = 1;
+	gmmResourceInfo->GetOffset(reqInfo);
+
+	uint32_t offsetV          = reqInfo.Render.Offset;
+	uint32_t size             = (uint32_t)gmmResourceInfo->GetSizeSurface();
+	uint32_t pitch            = (uint32_t)gmmResourceInfo->GetRenderPitch();
+
+	vaimg->format             = *format;
+	vaimg->format.byte_order  = VA_LSB_FIRST;
+	vaimg->width              = width;
+	vaimg->height             = height;
+	vaimg->data_size          = size;
 
     switch(format->fourcc)
     {
@@ -3972,92 +3941,72 @@ VAStatus DdiMedia_CreateImage(
         case VA_FOURCC_RGBX:
         case VA_FOURCC_XRGB:
         case VA_FOURCC_XBGR:
-        case VA_FOURCC_R8G8B8:
-        case VA_FOURCC_RGB565:
         case VA_FOURCC_A2R10G10B10:
         case VA_FOURCC_A2B10G10R10:
-            vaimg->num_planes = 1;
-            vaimg->pitches[0] = gmmPitch;
-            vaimg->offsets[0] = 0;
-            break;
-        case VA_FOURCC_RGBP:
-        case VA_FOURCC_BGRP:
-            vaimg->num_planes = 3;
-            vaimg->pitches[0] = gmmPitch;
-            vaimg->pitches[1] = gmmPitch;
-            vaimg->pitches[2] = gmmPitch;
-            vaimg->offsets[0] = 0;
-            vaimg->offsets[1] = gmmPitch * gmmHeight;
-            vaimg->offsets[2] = gmmPitch * gmmHeight * 2;
-            break;
-        case VA_FOURCC_Y800:
+        case VA_FOURCC_R8G8B8:
+        case VA_FOURCC_RGB565:
         case VA_FOURCC_UYVY:
         case VA_FOURCC_YUY2:
+        case VA_FOURCC_VYUY:
+        case VA_FOURCC_YVYU:
         case VA_FOURCC_AYUV:
         case VA_FOURCC_Y210:
+        case VA_FOURCC_Y216:
         case VA_FOURCC_Y410:
         case VA_FOURCC_Y416:
+        case VA_FOURCC_Y800:
             vaimg->num_planes = 1;
-            vaimg->pitches[0] = gmmPitch;
+            vaimg->pitches[0] = pitch;
             vaimg->offsets[0] = 0;
             break;
         case VA_FOURCC_NV12:
         case VA_FOURCC_NV21:
-            vaimg->num_planes = 2;
-            vaimg->pitches[0] = gmmPitch;
-            vaimg->pitches[1] = gmmPitch;
-            vaimg->offsets[0] = 0;
-            vaimg->offsets[1] = gmmPitch * gmmHeight;
-            vaimg->offsets[2] = vaimg->offsets[1] + 1;
-            break;
         case VA_FOURCC_P010:
         case VA_FOURCC_P016:
             vaimg->num_planes = 2;
-            vaimg->pitches[0] = gmmPitch;
-            vaimg->pitches[1] = gmmPitch;
+            vaimg->pitches[0] = pitch;
+            vaimg->pitches[1] = pitch;
             vaimg->offsets[0] = 0;
-            vaimg->offsets[1] = gmmPitch * gmmHeight;
-            vaimg->offsets[2] = vaimg->offsets[1] + 2;
+            vaimg->offsets[1] = offsetU;
             break;
         case VA_FOURCC_YV12:
-        case VA_FOURCC_I420:
-        case VA_FOURCC_IYUV:
-            vaimg->num_planes = 3;
-            vaimg->pitches[0] = gmmPitch;
-            vaimg->pitches[1] = gmmPitch / 2;
-            vaimg->pitches[2] = gmmPitch / 2;
-            vaimg->offsets[0] = 0;
-            vaimg->offsets[1] = gmmPitch * gmmHeight;
-            vaimg->offsets[2] = vaimg->offsets[1] + gmmPitch * gmmHeight / 4;
-            break;
-        case VA_FOURCC_411P:
-        case VA_FOURCC_422H:
-        case VA_FOURCC_444P:
             vaimg->num_planes = 3;
-            vaimg->pitches[0] = gmmPitch;
-            vaimg->pitches[1] = gmmPitch;
-            vaimg->pitches[2] = gmmPitch;
+            vaimg->pitches[0] = pitch;
+            vaimg->pitches[1] = pitch / 2;
+            vaimg->pitches[2] = pitch / 2;
             vaimg->offsets[0] = 0;
-            vaimg->offsets[1] = gmmPitch * gmmHeight;
-            vaimg->offsets[2] = vaimg->offsets[1] + gmmPitch * gmmHeight;
+            vaimg->offsets[1] = offsetV;
+            vaimg->offsets[2] = offsetU;
             break;
-        case VA_FOURCC_422V:
+		case VA_FOURCC_I420:
+			vaimg->num_planes = 3;
+			vaimg->pitches[0] = pitch;
+			vaimg->pitches[1] = pitch / 2;
+			vaimg->pitches[2] = pitch / 2;
+			vaimg->offsets[0] = 0;
+			vaimg->offsets[1] = offsetU;
+			vaimg->offsets[2] = offsetV;
+			break;
         case VA_FOURCC_IMC3:
+		case VA_FOURCC_411P:
+		case VA_FOURCC_422V:
+		case VA_FOURCC_422H:
+		case VA_FOURCC_444P:
+		case VA_FOURCC_RGBP:
+		case VA_FOURCC_BGRP:
             vaimg->num_planes = 3;
-            vaimg->pitches[0] = gmmPitch;
-            vaimg->pitches[1] = gmmPitch;
-            vaimg->pitches[2] = gmmPitch;
+            vaimg->pitches[0] = pitch;
+            vaimg->pitches[1] = pitch;
+            vaimg->pitches[2] = pitch;
             vaimg->offsets[0] = 0;
-            vaimg->offsets[1] = gmmPitch * gmmHeight;
-            vaimg->offsets[2] = vaimg->offsets[1] + gmmPitch * gmmHeight / 2;
+            vaimg->offsets[1] = offsetU;
+            vaimg->offsets[2] = offsetV;
             break;
         default:
             MOS_FreeMemory(vaimg);
             return VA_STATUS_ERROR_UNIMPLEMENTED;
     }
 
-    mediaCtx->pGmmClientContext->DestroyResInfoObject(gmmResourceInfo);
-
     DDI_MEDIA_BUFFER *buf  = (DDI_MEDIA_BUFFER *)MOS_AllocAndZeroMemory(sizeof(DDI_MEDIA_BUFFER));
     if (nullptr == buf)
     {
@@ -4487,6 +4436,125 @@ VAStatus SwizzleSurface(PDDI_MEDIA_CONTEXT mediaCtx, PGMM_RESOURCE_INFO pGmmResI
     return vaStatus;
 }
 
+//!
+//! \brief  Copy plane from src to dst row by row when src and dst strides are different
+//!
+//! \param  [in] dst
+//!         Destination plane
+//! \param  [in] dstPitch
+//!         Destination plane pitch
+//! \param  [in] src
+//!         Source plane
+//! \param  [in] srcPitch
+//!         Source plane pitch
+//! \param  [in] height
+//!         Plane hight
+//!
+static void DdiMedia_CopyPlane(
+    uint8_t *dst,
+    uint32_t dstPitch,
+    uint8_t *src,
+    uint32_t srcPitch,
+    uint32_t height)
+{
+    uint32_t rowSize = std::min(dstPitch, srcPitch);
+    for (int y = 0; y < height; y += 1)
+    {
+        memcpy(dst, src, rowSize);
+        dst += dstPitch;
+        src += srcPitch;
+    }
+}
+
+static uint32_t DdiMedia_GetChromaPitchHeight(uint32_t fourcc, uint32_t pitch, uint32_t height, uint32_t *chromaPitch, uint32_t *chromaHeight);
+
+//!
+//! \brief  Copy data from surface to image
+//!
+//! \param  [in] ctx
+//!         Input driver context
+//! \param  [in] surface
+//!         Pointer to surface
+//! \param  [in] image
+//!         Pointer to image
+//!
+//! \return VAStatus
+//!     VA_STATUS_SUCCESS if success, else fail reason
+//!
+static VAStatus DdiMedia_CopySurfaceToImage(
+    VADriverContextP  ctx,
+    DDI_MEDIA_SURFACE *surface,
+    VAImage           *image)
+{
+    DDI_FUNCTION_ENTER();
+
+    DDI_CHK_NULL(ctx,       "nullptr ctx.",         VA_STATUS_ERROR_INVALID_CONTEXT);
+    PDDI_MEDIA_CONTEXT mediaCtx = DdiMedia_GetMediaContext(ctx);
+    DDI_CHK_NULL(mediaCtx,  "nullptr mediaCtx.",    VA_STATUS_ERROR_INVALID_CONTEXT);
+
+    VAStatus vaStatus = VA_STATUS_SUCCESS;
+    //Lock Surface
+    void *surfData = DdiMediaUtil_LockSurface(surface, MOS_LOCKFLAG_READONLY);
+    if (surfData == nullptr)
+    {
+        DDI_ASSERTMESSAGE("nullptr surfData.");
+        return vaStatus;
+    }
+
+    void *imageData = nullptr;
+    vaStatus = DdiMedia_MapBuffer(ctx, image->buf, &imageData);
+    if (vaStatus != VA_STATUS_SUCCESS)
+    {
+        DDI_ASSERTMESSAGE("Failed to map buffer.");
+        DdiMediaUtil_UnlockSurface(surface);
+        return vaStatus;
+    }
+
+    uint8_t *ySrc = (uint8_t*)surfData;
+    uint8_t *yDst = (uint8_t*)imageData;
+
+    if(surface->data_size == image->data_size)
+    {
+        MOS_SecureMemcpy(imageData, image->data_size, surfData, image->data_size);
+    }
+    else
+    {
+        DdiMedia_CopyPlane(yDst, image->pitches[0], ySrc, surface->iPitch, image->height);
+        if (image->num_planes > 1)
+        {
+            uint8_t *uSrc = ySrc + surface->iPitch * surface->iHeight;
+            uint8_t *uDst = yDst + image->offsets[1];
+            uint32_t chromaPitch;
+            uint32_t chromaHeight;
+            uint32_t imageChromaPitch;
+            uint32_t imageChromaHeight;
+            DdiMedia_GetChromaPitchHeight(DdiMedia_MediaFormatToOsFormat(surface->format), surface->iPitch, surface->iHeight, &chromaPitch, &chromaHeight);
+            DdiMedia_GetChromaPitchHeight(image->format.fourcc, image->pitches[0], image->height, &imageChromaPitch, &imageChromaHeight);
+            DdiMedia_CopyPlane(uDst, image->pitches[1], uSrc, chromaPitch, imageChromaHeight);
+
+            if(image->num_planes > 2)
+            {
+                uint8_t *vSrc = uSrc + chromaPitch * chromaHeight;
+                uint8_t *vDst = yDst + image->offsets[2];
+                DdiMedia_CopyPlane(vDst, image->pitches[2], vSrc, chromaPitch, imageChromaHeight);
+            }
+        }
+    }
+
+    vaStatus = DdiMedia_UnmapBuffer(ctx, image->buf);
+    if (vaStatus != VA_STATUS_SUCCESS)
+    {
+        DDI_ASSERTMESSAGE("Failed to unmap buffer.");
+        DdiMediaUtil_UnlockSurface(surface);
+        return vaStatus;
+    }
+
+    DdiMediaUtil_UnlockSurface(surface);
+
+    return vaStatus;
+}
+
+
 //!
 //! \brief  Retrive surface data into a VAImage
 //! \details    Image must be in a format supported by the implementation
@@ -4593,57 +4661,11 @@ VAStatus DdiMedia_GetImage(
     DDI_CHK_NULL(mediaSurface,     "nullptr mediaSurface.",      VA_STATUS_ERROR_INVALID_SURFACE);
     DDI_CHK_NULL(mediaSurface->bo, "nullptr mediaSurface->bo.",  VA_STATUS_ERROR_INVALID_SURFACE);
 
-    //Lock Surface
-    void *surfData = DdiMediaUtil_LockSurface(mediaSurface, (MOS_LOCKFLAG_READONLY | MOS_LOCKFLAG_NO_SWIZZLE));
-    if (surfData == nullptr)
-    {
-        DDI_ASSERTMESSAGE("nullptr surfData.");
-        if(target_surface != VA_INVALID_SURFACE)
-        {
-            DdiMedia_DestroySurfaces(ctx, &target_surface, 1);
-        }
-        return vaStatus;
-    }
-
-    void *imageData = nullptr;
-    vaStatus = DdiMedia_MapBuffer(ctx, vaimg->buf, &imageData);
-    if (vaStatus != VA_STATUS_SUCCESS)
-    {
-        DDI_ASSERTMESSAGE("Failed to map buffer.");
-        DdiMediaUtil_UnlockSurface(mediaSurface);
-        if(target_surface != VA_INVALID_SURFACE)
-        {
-            DdiMedia_DestroySurfaces(ctx, &target_surface, 1);
-        }
-        return vaStatus;
-    }
+	vaStatus = DdiMedia_CopySurfaceToImage(ctx, mediaSurface, vaimg);
 
-    //Copy data from surface to image
-    if(mediaSurface->TileType == I915_TILING_NONE)
-    {
-        vaStatus = MOS_SecureMemcpy(imageData, vaimg->data_size, surfData, vaimg->data_size);
-    }
-    else
-    {
-        //Mos_SwizzleData((uint8_t*)surfData, (uint8_t *)imageData, (MOS_TILE_TYPE)mediaSurface->TileType, MOS_TILE_LINEAR, vaimg->data_size / mediaSurface->iPitch, mediaSurface->iPitch, mediaSurface->uiMapFlag);
-        vaStatus = SwizzleSurface(mediaSurface->pMediaCtx,mediaSurface->pGmmResourceInfo, surfData, (MOS_TILE_TYPE)mediaSurface->TileType, (uint8_t *)imageData, false);
-    }
     if (vaStatus != MOS_STATUS_SUCCESS)
     {
         DDI_ASSERTMESSAGE("Failed to copy surface to image buffer data!");
-        DdiMediaUtil_UnlockSurface(mediaSurface);
-        if(target_surface != VA_INVALID_SURFACE)
-        {
-            DdiMedia_DestroySurfaces(ctx, &target_surface, 1);
-        }
-        return vaStatus;
-    }
-
-    vaStatus = DdiMedia_UnmapBuffer(ctx, vaimg->buf);
-    if (vaStatus != VA_STATUS_SUCCESS)
-    {
-        DDI_ASSERTMESSAGE("Failed to unmap buffer.");
-        DdiMediaUtil_UnlockSurface(mediaSurface);
         if(target_surface != VA_INVALID_SURFACE)
         {
             DdiMedia_DestroySurfaces(ctx, &target_surface, 1);
@@ -4651,8 +4673,6 @@ VAStatus DdiMedia_GetImage(
         return vaStatus;
     }
 
-    DdiMediaUtil_UnlockSurface(mediaSurface);
-
     //Destroy temp surface if created
     if(target_surface != VA_INVALID_SURFACE)
     {
@@ -4662,37 +4682,7 @@ VAStatus DdiMedia_GetImage(
     return VA_STATUS_SUCCESS;
 }
 
-//!
-//! \brief  Copy plane from src to dst row by row when src and dst strides are different
-//!
-//! \param  [in] dst
-//!         Destination plane
-//! \param  [in] dstPitch
-//!         Destination plane pitch
-//! \param  [in] src
-//!         Source plane
-//! \param  [in] srcPitch
-//!         Source plane pitch
-//! \param  [in] height
-//!         Plane hight
-//!
-static void DdiMedia_CopyPlane(
-    uint8_t *dst,
-    uint32_t dstPitch,
-    uint8_t *src,
-    uint32_t srcPitch,
-    uint32_t height)
-{
-    uint32_t rowSize = std::min(dstPitch, srcPitch);
-    for (int y = 0; y < height; y += 1)
-    {
-        memcpy(dst, src, rowSize);
-        dst += dstPitch;
-        src += srcPitch;
-    }
-}
 
-static uint32_t DdiMedia_GetChromaPitchHeight(PDDI_MEDIA_SURFACE mediaSurface, uint32_t *chromaWidth, uint32_t *chromaPitch, uint32_t *chromaHeight);
 
 //!
 //! \brief  Copy data from a VAImage to a surface
@@ -4885,11 +4875,9 @@ VAStatus DdiMedia_PutImage(
                 uPlane.iWidth              = src_width;
                 uPlane.iRealHeight         = src_height;
                 uPlane.iHeight             = src_height;
-                uint32_t chromaWidth       = 0;
                 uint32_t chromaHeight      = 0;
                 uint32_t chromaPitch       = 0;
-                uint32_t surfacePlaneCount = DdiMedia_GetChromaPitchHeight(&uPlane, &chromaWidth, &chromaPitch, &chromaHeight);
-                DDI_CHK_CONDITION((surfacePlaneCount != vaimg->num_planes), "DDI:Failed to copy image to surface buffer, diffrent number of planes.", VA_STATUS_ERROR_OPERATION_FAILED);
+				DdiMedia_GetChromaPitchHeight(DdiMedia_MediaFormatToOsFormat(uPlane.format), uPlane.iPitch, uPlane.iHeight, &chromaPitch, &chromaHeight);
 
                 uint8_t *uSrc = (uint8_t *)imageData + vaimg->offsets[1];
                 uint8_t *uDst = yDst + mediaSurface->iPitch * mediaSurface->iHeight;
@@ -5908,43 +5896,37 @@ VAStatus DdiMedia_ReleaseBufferHandle(
 #endif
 
 
-static uint32_t DdiMedia_GetChromaPitchHeight(PDDI_MEDIA_SURFACE mediaSurface, uint32_t *chromaWidth, uint32_t *chromaPitch, uint32_t *chromaHeight)
+static uint32_t DdiMedia_GetChromaPitchHeight(
+	uint32_t fourcc,
+	uint32_t pitch,
+	uint32_t height,
+	uint32_t *chromaPitch,
+	uint32_t *chromaHeight)
 {
-    DDI_CHK_NULL(mediaSurface, "nullptr mediaSurface", VA_STATUS_ERROR_INVALID_PARAMETER);
-    DDI_CHK_NULL(chromaWidth, "nullptr chromaWidth", VA_STATUS_ERROR_INVALID_PARAMETER);
     DDI_CHK_NULL(chromaPitch, "nullptr chromaPitch", VA_STATUS_ERROR_INVALID_PARAMETER);
     DDI_CHK_NULL(chromaHeight, "nullptr chromaHeight", VA_STATUS_ERROR_INVALID_PARAMETER);
 
-    uint32_t fourcc = DdiMedia_MediaFormatToOsFormat(mediaSurface->format);
     switch(fourcc)
     {
         case VA_FOURCC_NV12:
-            *chromaWidth = mediaSurface->iWidth;
-            *chromaHeight = mediaSurface->iHeight/2;
-            *chromaPitch = mediaSurface->iPitch;
-            return 2;
+		case VA_FOURCC_P010:
+		case VA_FOURCC_P016:
+            *chromaHeight = MOS_ALIGN_CEIL(height, 2) / 2;
+            *chromaPitch = pitch;
+            break;
         case VA_FOURCC_I420:
         case VA_FOURCC_YV12:
-            *chromaWidth = mediaSurface->iWidth / 2;
-            *chromaHeight = mediaSurface->iHeight/2;
-            *chromaPitch = mediaSurface->iPitch /2;
-            return 3;
+            *chromaHeight = MOS_ALIGN_CEIL(height, 2) / 2;
+            *chromaPitch = MOS_ALIGN_CEIL(pitch, 2) / 2;
+            break;
         case VA_FOURCC_YV16:
-            *chromaWidth = mediaSurface->iWidth / 2;
-            *chromaHeight = mediaSurface->iHeight;
-            *chromaPitch = mediaSurface->iPitch / 2;
-            return 3;
-        case VA_FOURCC_P010:
-        case VA_FOURCC_P016:
-            *chromaWidth = mediaSurface->iWidth ;
-            *chromaHeight = mediaSurface->iHeight/2;
-            *chromaPitch = mediaSurface->iPitch;
-            return 2;
+            *chromaHeight = height;
+            *chromaPitch = MOS_ALIGN_CEIL(pitch, 2) / 2;
+            break;
         case VA_FOURCC_I010:
-            *chromaWidth = mediaSurface->iWidth / 2;
-            *chromaHeight = mediaSurface->iHeight/2;
-            *chromaPitch = mediaSurface->iPitch / 2;
-            return 2;
+            *chromaHeight = MOS_ALIGN_CEIL(height, 2) / 2;
+            *chromaPitch = MOS_ALIGN_CEIL(pitch, 2) / 2;
+            break;
         case VA_FOURCC_YUY2:
         case VA_FOURCC_Y800:
         case VA_FOURCC_UYVY:
@@ -5955,11 +5937,10 @@ static uint32_t DdiMedia_GetChromaPitchHeight(PDDI_MEDIA_SURFACE mediaSurface, u
         case VA_FOURCC_ARGB:
         case VA_FOURCC_ABGR:
         default:
-            *chromaWidth = 0;
             *chromaPitch = 0;
             *chromaHeight = 0;
-            return 1;
     }
+	return VA_STATUS_SUCCESS;
 }
 
 static uint32_t DdiMedia_GetDrmFormatOfSeparatePlane(uint32_t fourcc, int plane)
@@ -6057,6 +6038,64 @@ static uint32_t DdiMedia_GetDrmFormatOfCompositeObject(uint32_t fourcc)
 }
 
 
+static uint32_t DdiMedia_GetPlaneNum(PDDI_MEDIA_SURFACE mediaSurface, bool hasAuxPlane)
+{
+    DDI_CHK_NULL(mediaSurface, "nullptr mediaSurface", VA_STATUS_ERROR_INVALID_PARAMETER);
+
+    uint32_t fourcc = DdiMedia_MediaFormatToOsFormat(mediaSurface->format);
+    uint32_t plane_num = 0;
+    switch(fourcc)
+    {
+        case VA_FOURCC_NV12:
+        case VA_FOURCC_NV21:
+        case VA_FOURCC_P010:
+        case VA_FOURCC_P016:
+            plane_num = hasAuxPlane ? 4 : 2;
+            break;
+            plane_num = hasAuxPlane ? 4 : 2;
+            break;
+        case VA_FOURCC_I420:
+        case VA_FOURCC_YV12:
+        case VA_FOURCC_411P:
+        case VA_FOURCC_422H:
+        case VA_FOURCC_422V:
+        case VA_FOURCC_444P:
+        case VA_FOURCC_IMC3:
+        case VA_FOURCC_RGBP:
+        case VA_FOURCC_BGRP:
+            plane_num = 3;
+            break;
+        case VA_FOURCC_YUY2:
+        case VA_FOURCC_UYVY:
+        case VA_FOURCC_YVYU:
+        case VA_FOURCC_VYUY:
+        case VA_FOURCC_Y800:
+        case VA_FOURCC_Y210:
+        case VA_FOURCC_Y216:
+        case VA_FOURCC_Y410:
+        case VA_FOURCC_Y416:
+        case VA_FOURCC_AYUV:
+        case VA_FOURCC_RGBA:
+        case VA_FOURCC_RGBX:
+        case VA_FOURCC_BGRA:
+        case VA_FOURCC_BGRX:
+        case VA_FOURCC_ARGB:
+        case VA_FOURCC_ABGR:
+        case VA_FOURCC_XRGB:
+        case VA_FOURCC_XBGR:
+        case VA_FOURCC_RGB565:
+        case VA_FOURCC_R8G8B8:
+        case VA_FOURCC_A2R10G10B10:
+        case VA_FOURCC_A2B10G10R10:
+            plane_num = hasAuxPlane ? 2 : 1;
+            break;
+        default:
+            DDI_ASSERTMESSAGE("Unsupported format.\n");
+    }
+    return plane_num;
+}
+
+
 //!
 //! \brief   API for export surface handle to other component
 //!
@@ -6075,6 +6114,7 @@ static uint32_t DdiMedia_GetDrmFormatOfCompositeObject(uint32_t fourcc)
 //! \return VAStatus
 //!     VA_STATUS_SUCCESS if success, else fail reason
 //!
+
 VAStatus DdiMedia_ExportSurfaceHandle(
     VADriverContextP ctx,
     VASurfaceID surface_id,
@@ -6095,16 +6135,15 @@ VAStatus DdiMedia_ExportSurfaceHandle(
     DDI_CHK_NULL(mediaSurface->bo,               "nullptr mediaSurface->bo",               VA_STATUS_ERROR_INVALID_SURFACE);
     DDI_CHK_NULL(mediaSurface->pGmmResourceInfo, "nullptr mediaSurface->pGmmResourceInfo", VA_STATUS_ERROR_INVALID_SURFACE);
 
-    int32_t ret = mos_bo_gem_export_to_prime(mediaSurface->bo, (int32_t*)&mediaSurface->name);
-    if (ret)
-    {
-        //LOGE("Failed drm_intel_gem_export_to_prime operation!!!\n");
-        return VA_STATUS_ERROR_OPERATION_FAILED;
+    if (mem_type != VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME_2) {
+        DDI_ASSERTMESSAGE("vaExportSurfaceHandle: memory type %08x is not supported.\n", mem_type);
+        return VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE;
     }
-    uint32_t tiling, swizzle;
-    if(mos_bo_get_tiling(mediaSurface->bo,&tiling, &swizzle))
+
+    if (mos_bo_gem_export_to_prime(mediaSurface->bo, (int32_t*)&mediaSurface->name))
     {
-        tiling = I915_TILING_NONE;
+        DDI_ASSERTMESSAGE("Failed drm_intel_gem_export_to_prime operation!!!\n");
+        return VA_STATUS_ERROR_OPERATION_FAILED;
     }
 
     VADRMPRIMESurfaceDescriptor *desc = (VADRMPRIMESurfaceDescriptor *)descriptor;
@@ -6113,35 +6152,37 @@ VAStatus DdiMedia_ExportSurfaceHandle(
     {
         return VA_STATUS_ERROR_UNSUPPORTED_RT_FORMAT;
     }
-    desc->width  = mediaSurface->iWidth;
-    desc->height = mediaSurface->iHeight;
-
+    desc->width           = mediaSurface->iWidth;
+    desc->height          = mediaSurface->iHeight;
     desc->num_objects     = 1;
     desc->objects[0].fd   = mediaSurface->name;
     desc->objects[0].size = mediaSurface->pGmmResourceInfo->GetSizeSurface();
-    switch (tiling) {
+    switch (mediaSurface->TileType) {
     case I915_TILING_X:
         desc->objects[0].drm_format_modifier = I915_FORMAT_MOD_X_TILED;
         break;
     case I915_TILING_Y:
-        desc->objects[0].drm_format_modifier = I915_FORMAT_MOD_Y_TILED;
+        if (mediaCtx->m_auxTableMgr)
+        {
+            desc->objects[0].drm_format_modifier = I915_FORMAT_MOD_Y_TILED;//I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS;
+        }else
+        {
+            desc->objects[0].drm_format_modifier = I915_FORMAT_MOD_Y_TILED;
+        }
         break;
     case I915_TILING_NONE:
     default:
         desc->objects[0].drm_format_modifier = DRM_FORMAT_MOD_NONE;
     }
+
     int composite_object = flags & VA_EXPORT_SURFACE_COMPOSED_LAYERS;
 
     uint32_t formats[4];
-    uint32_t chromaWidth;
-    uint32_t chromaPitch;
-    uint32_t chromaHeight;
-    uint32_t num_planes = DdiMedia_GetChromaPitchHeight(mediaSurface,&chromaWidth, &chromaPitch,&chromaHeight);
-
+    bool hasAuxPlane = (mediaCtx->m_auxTableMgr)? true: false;
+    uint32_t num_planes = DdiMedia_GetPlaneNum(mediaSurface, hasAuxPlane);
     if(composite_object)
     {
         formats[0] = DdiMedia_GetDrmFormatOfCompositeObject(desc->fourcc);
-
         if(!formats[0])
         {
             DDI_ASSERTMESSAGE("vaExportSurfaceHandle: fourcc %08x is not supported for export as a composite object.\n", desc->fourcc);
@@ -6155,76 +6196,132 @@ VAStatus DdiMedia_ExportSurfaceHandle(
             formats[i] = DdiMedia_GetDrmFormatOfSeparatePlane(desc->fourcc,i);
             if (!formats[i])
             {
-                DDI_ASSERTMESSAGE("vaExportSurfaceHandle: fourcc %08x "
-                              "is not supported for export as separate "
-                              "planes.\n", desc->fourcc);
+                DDI_ASSERTMESSAGE("vaExportSurfaceHandle: fourcc %08x is not supported for export as separate planes.\n", desc->fourcc);
                 return VA_STATUS_ERROR_INVALID_SURFACE;
             }
         }
     }
 
-    uint32_t offset = 0;
-    uint32_t pitch  = 0;
-    uint32_t height = 0;
+    // Get offset from GMM
+    GMM_REQ_OFFSET_INFO reqInfo = {0};
+    reqInfo.Plane = GMM_PLANE_Y;
+    reqInfo.ReqRender = 1;
+    mediaSurface->pGmmResourceInfo->GetOffset(reqInfo);
+    uint32_t offsetY = reqInfo.Render.Offset;
+    MOS_ZeroMemory(&reqInfo, sizeof(GMM_REQ_OFFSET_INFO));
+    reqInfo.Plane = GMM_PLANE_U;
+    reqInfo.ReqRender = 1;
+    mediaSurface->pGmmResourceInfo->GetOffset(reqInfo);
+    uint32_t offsetUV = reqInfo.Render.Offset;
+    uint32_t auxOffsetY = (uint32_t)mediaSurface->pGmmResourceInfo->GetPlanarAuxOffset(0, GMM_AUX_Y_CCS);
+    uint32_t auxOffsetUV = (uint32_t)mediaSurface->pGmmResourceInfo->GetPlanarAuxOffset(0, GMM_AUX_UV_CCS);
 
     if (composite_object) {
         desc->num_layers = 1;
-
         desc->layers[0].drm_format = formats[0];
         desc->layers[0].num_planes = num_planes;
-
-        for (int i = 0; i < num_planes; i++)
+        if (mediaCtx->m_auxTableMgr)
         {
-            desc->layers[0].object_index[i] = 0;
-            if (i == 0)
+            // For semi-planar formats like NV12, CCS planes follow the Y and UV planes,
+            // i.e. planes 0 and 1 are used for Y and UV surfaces, planes 2 and 3 for the respective CCS.
+            for (int i = 0; i < num_planes/2; i++)
             {
-                pitch  = mediaSurface->iPitch;
-                height = mediaSurface->iHeight;
+                desc->layers[0].object_index[2*i] = 0;
+                desc->layers[0].object_index[2*i+1] = 0;
+                if (i == 0)
+                {
+                    // Y plane
+                    desc->layers[0].offset[i] = offsetY;
+                    desc->layers[0].pitch[i]  = mediaSurface->iPitch;
+                    // Y aux plane
+                    desc->layers[0].offset[i + num_planes/2] = auxOffsetY;
+                    desc->layers[0].pitch[i + num_planes/2] = mediaSurface->iPitch/8;
+                }
+                else
+                {
+                    // UV plane
+                    desc->layers[0].offset[i] = offsetUV;
+                    desc->layers[0].pitch[i]  = mediaSurface->iPitch;
+                    // UV aux plane
+                    desc->layers[0].offset[i + num_planes/2] = auxOffsetUV;
+                    desc->layers[0].pitch[i + num_planes/2] = mediaSurface->iPitch/8;
+                }
             }
-            else
+        }else
+        {
+            for (int i = 0; i < num_planes; i++)
             {
-                pitch = chromaPitch;
-                height = chromaHeight;
+                desc->layers[0].object_index[i] = 0;
+                if (i == 0)
+                {
+                    desc->layers[0].offset[i] = offsetY;
+                    desc->layers[0].pitch[i]  = mediaSurface->iPitch;
+                }
+                else
+                {
+                    desc->layers[0].offset[i] = offsetUV;
+                    desc->layers[0].pitch[i]  = mediaSurface->iPitch;
+                }
             }
-
-            desc->layers[0].offset[i] = offset;
-            desc->layers[0].pitch[i]  = pitch;
-
-            offset += pitch * height;
         }
     }
     else
     {
-        desc->num_layers = num_planes;
-
-        offset = 0;
-        for (int i = 0; i < num_planes; i++)
+        if (mediaCtx->m_auxTableMgr)
         {
-            desc->layers[i].drm_format = formats[i];
-            desc->layers[i].num_planes = 1;
+            desc->num_layers = num_planes / 2;
 
-            desc->layers[i].object_index[0] = 0;
-
-            if (i == 0)
+            for (int i = 0; i < desc->num_layers; i++)
             {
-                pitch  = mediaSurface->iPitch;
-                height = mediaSurface->iHeight;
+                desc->layers[i].drm_format = formats[i];
+                desc->layers[i].num_planes = 2;
+
+                desc->layers[i].object_index[0] = 0;
+
+                if (i == 0)
+                {
+                    desc->layers[i].offset[0] = offsetY;
+                    desc->layers[i].offset[1] = auxOffsetY;
+                    desc->layers[i].pitch[0]  = mediaSurface->iPitch;
+                    desc->layers[i].pitch[1]  = mediaSurface->iPitch/8;
+                }
+                else
+                {
+                    desc->layers[i].offset[0] = offsetUV;
+                    desc->layers[i].offset[1] = auxOffsetUV;
+                    desc->layers[i].pitch[0]  = mediaSurface->iPitch;
+                    desc->layers[i].pitch[1]  = mediaSurface->iPitch/8;
+                }
             }
-            else
+        }else
+        {
+            desc->num_layers = num_planes;
+
+            for (int i = 0; i < num_planes; i++)
             {
-                pitch  =  chromaPitch;
-                height = chromaHeight;
-            }
+                desc->layers[i].drm_format = formats[i];
+                desc->layers[i].num_planes = 1;
 
-            desc->layers[i].offset[0] = offset;
-            desc->layers[i].pitch[0]  = pitch;
+                desc->layers[i].object_index[0] = 0;
 
-            offset += pitch * height;
+                if (i == 0)
+                {
+                    desc->layers[i].offset[0] = offsetY;
+                    desc->layers[i].pitch[0]  = mediaSurface->iPitch;
+                }
+                else
+                {
+                    desc->layers[i].offset[0] = offsetUV;
+                    desc->layers[i].pitch[0]  = mediaSurface->iPitch;
+                }
+            }
         }
     }
+
     return VA_STATUS_SUCCESS;
 }
 
+
 //!
 //! \brief  Init VA driver 0.31
 //! 
diff --git a/media_driver/linux/common/ddi/media_libva_util.cpp b/media_driver/linux/common/ddi/media_libva_util.cpp
index f4e58e7c..aef223a1 100644
--- a/media_driver/linux/common/ddi/media_libva_util.cpp
+++ b/media_driver/linux/common/ddi/media_libva_util.cpp
@@ -423,7 +423,7 @@ VAStatus DdiMediaUtil_AllocateSurface(
     uint32_t    gmmHeight;
 
     gmmPitch    = (uint32_t)gmmResourceInfo->GetRenderPitch();
-    if( DdiMediaUtil_IsExternalSurface(mediaSurface) && ( mediaSurface->pSurfDesc->uiVaMemType == VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR ) && mediaSurface->pSurfDesc->uiPitches[0])
+    if( DdiMediaUtil_IsExternalSurface(mediaSurface) && mediaSurface->pSurfDesc->uiPitches[0])
     {
         gmmResourceInfo->OverridePitch(mediaSurface->pSurfDesc->uiPitches[0]);
     }
diff --git a/media_driver/linux/common/os/mos_os_specific.c b/media_driver/linux/common/os/mos_os_specific.c
index 2213d24e..034997f8 100644
--- a/media_driver/linux/common/os/mos_os_specific.c
+++ b/media_driver/linux/common/os/mos_os_specific.c
@@ -2506,7 +2506,7 @@ MOS_STATUS Mos_Specific_GetResourceInfo(
     pResDetails->Format   = pOsResource->Format;
 
     // Get planes
-    if (pOsResource->b16UsrPtrMode)
+    if (pOsResource->b16UsrPtrMode || pOsResource->bExternalSurface)
     {
         // if usrptr surface, do not query those values from gmm, app will configure them.
         pResDetails->RenderOffset.YUV.Y.BaseOffset = pOsResource->YPlaneOffset.iSurfaceOffset;
diff --git a/media_driver/linux/common/os/mos_os_specific.h b/media_driver/linux/common/os/mos_os_specific.h
index 805be513..75dd0bb6 100644
--- a/media_driver/linux/common/os/mos_os_specific.h
+++ b/media_driver/linux/common/os/mos_os_specific.h
@@ -257,6 +257,7 @@ struct _MOS_SPECIFIC_RESOURCE
     GMM_RESOURCE_INFO   *pGmmResInfo;        //!< GMM resource descriptor
     MOS_MMAP_OPERATION  MmapOperation;
     uint8_t             *pSystemShadow;
+    bool                bExternalSurface;   //!< indicate the surface allocated by external
     bool                b16UsrPtrMode;      //!< indicate source info comes from app.
     MOS_PLANE_OFFSET    YPlaneOffset;       //!< Y surface plane offset
     MOS_PLANE_OFFSET    UPlaneOffset;       //!< U surface plane offset
diff --git a/media_driver/linux/common/vp/ddi/media_libva_vp.c b/media_driver/linux/common/vp/ddi/media_libva_vp.c
index 9df8c761..7f1a7b9d 100644
--- a/media_driver/linux/common/vp/ddi/media_libva_vp.c
+++ b/media_driver/linux/common/vp/ddi/media_libva_vp.c
@@ -148,6 +148,95 @@ bool VpIs16UsrPtrPitch(uint32_t pitch, DDI_MEDIA_FORMAT format)
     return status;
 }
 
+VAStatus VpGetExternalSurfaceInfo(
+    PDDI_MEDIA_SURFACE pMediaSurface,
+    PVPHAL_SURFACE pVphalSurface)
+{
+    if (pMediaSurface->pSurfDesc)
+    {
+        if (pMediaSurface->pSurfDesc->uiVaMemType == VA_SURFACE_ATTRIB_MEM_TYPE_KERNEL_DRM ||
+            pMediaSurface->pSurfDesc->uiVaMemType == VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME)
+        {
+            pVphalSurface->OsResource.bExternalSurface = true;
+
+            switch (pMediaSurface->pSurfDesc->uiPlanes)
+            {
+                case 1:
+                    pVphalSurface->OsResource.YPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[0];
+                    break;
+                case 2:
+                    pVphalSurface->OsResource.YPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[0];
+                    pVphalSurface->OsResource.UPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[1];
+                    pVphalSurface->OsResource.UPlaneOffset.iYOffset       = 0;
+                    pVphalSurface->OsResource.VPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[1];
+                    pVphalSurface->OsResource.VPlaneOffset.iYOffset       = 0;
+                    break;
+                case 3:
+                    pVphalSurface->OsResource.YPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[0];
+                    pVphalSurface->OsResource.UPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[1];
+                    pVphalSurface->OsResource.UPlaneOffset.iYOffset       = 0;
+                    pVphalSurface->OsResource.VPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[2];
+                    pVphalSurface->OsResource.VPlaneOffset.iYOffset       = 0;
+                    break;
+                default:
+                    DDI_ASSERTMESSAGE("Invalid plane number.");
+                    return VA_STATUS_ERROR_INVALID_PARAMETER;
+            }
+        }
+        // add 16aligned UsrPtr mode support
+        else if (pMediaSurface->pSurfDesc->uiVaMemType == VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR)
+        {
+            pVphalSurface->b16UsrPtr = VpIs16UsrPtrPitch(pMediaSurface->iPitch, pMediaSurface->format);
+            if (pVphalSurface->b16UsrPtr)
+            {
+                pVphalSurface->dwPitch                   = pMediaSurface->iPitch;
+                pVphalSurface->OsResource.iPitch         = pMediaSurface->iPitch;
+                pVphalSurface->OsResource.iWidth         = pMediaSurface->iWidth;
+                pVphalSurface->OsResource.iHeight        = pMediaSurface->iHeight;
+                pVphalSurface->OsResource.b16UsrPtrMode  = true;
+                switch (pMediaSurface->format)
+                {
+                    case Media_Format_NV12:
+                        pVphalSurface->OsResource.YPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[0];
+                        pVphalSurface->OsResource.UPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[1];
+                        pVphalSurface->OsResource.UPlaneOffset.iYOffset       = 0;
+                        pVphalSurface->OsResource.VPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[1];
+                        pVphalSurface->OsResource.VPlaneOffset.iYOffset       = 0;
+                        break;
+                    case Media_Format_YV12:
+                        pVphalSurface->OsResource.YPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[0];
+                        pVphalSurface->OsResource.VPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[1];
+                        pVphalSurface->OsResource.VPlaneOffset.iYOffset       = 0;
+                        pVphalSurface->OsResource.UPlaneOffset.iSurfaceOffset = pMediaSurface->pSurfDesc->uiOffsets[2];
+                        pVphalSurface->OsResource.UPlaneOffset.iYOffset       = 0;
+                        break;
+                    case Media_Format_A8R8G8B8:
+                        break;
+                    default:
+                        break;
+                }
+            }
+            else
+            {
+                pVphalSurface->OsResource.b16UsrPtrMode = false;
+            }
+        }
+        else
+        {
+            DDI_ASSERTMESSAGE("Unsupported memory type.");
+            return VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE;
+        }
+    }
+    else
+    {
+        pVphalSurface->b16UsrPtr                   = false;
+        pVphalSurface->OsResource.b16UsrPtrMode    = false;
+        pVphalSurface->OsResource.bExternalSurface = false;
+    }
+    return VA_STATUS_SUCCESS;
+}
+
+
 /////////////////////////////////////////////////////////////////////////////
 //! \purpose map from media format to vphal format
 //! \params
@@ -1431,49 +1520,10 @@ DdiVp_SetProcPipelineParams(
         DDI_CHK_RET(vaStatus, "Failed to update vphal target surface color space!");
     }
 
-    // add 16aligned UsrPtr mode support
-    if (pMediaSrcSurf->pSurfDesc && (pMediaSrcSurf->pSurfDesc->uiVaMemType == VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR))
-    {
-        pVpHalSrcSurf->b16UsrPtr = VpIs16UsrPtrPitch(pMediaSrcSurf->iPitch, pMediaSrcSurf->format);
-        if (pVpHalSrcSurf->b16UsrPtr)
-        {
-            pVpHalSrcSurf->dwPitch                   = pMediaSrcSurf->iPitch;
-            pVpHalSrcSurf->OsResource.iPitch         = pMediaSrcSurf->iPitch;
-            pVpHalSrcSurf->OsResource.iWidth         = pMediaSrcSurf->iWidth;
-            pVpHalSrcSurf->OsResource.iHeight        = pMediaSrcSurf->iHeight;
-            pVpHalSrcSurf->OsResource.b16UsrPtrMode  = true;
-            switch (pMediaSrcSurf->format)
-            {
-                case Media_Format_NV12:
-                    pVpHalSrcSurf->OsResource.YPlaneOffset.iSurfaceOffset = pMediaSrcSurf->pSurfDesc->uiOffsets[0];
-                    pVpHalSrcSurf->OsResource.UPlaneOffset.iSurfaceOffset = pMediaSrcSurf->pSurfDesc->uiOffsets[1];
-                    pVpHalSrcSurf->OsResource.UPlaneOffset.iYOffset       = 0;
-                    pVpHalSrcSurf->OsResource.VPlaneOffset.iSurfaceOffset = pMediaSrcSurf->pSurfDesc->uiOffsets[1];
-                    pVpHalSrcSurf->OsResource.VPlaneOffset.iYOffset       = 0;
-                    break;
-                case Media_Format_YV12:
-                    pVpHalSrcSurf->OsResource.YPlaneOffset.iSurfaceOffset = pMediaSrcSurf->pSurfDesc->uiOffsets[0];
-                    pVpHalSrcSurf->OsResource.VPlaneOffset.iSurfaceOffset = pMediaSrcSurf->pSurfDesc->uiOffsets[1];
-                    pVpHalSrcSurf->OsResource.VPlaneOffset.iYOffset       = 0;
-                    pVpHalSrcSurf->OsResource.UPlaneOffset.iSurfaceOffset = pMediaSrcSurf->pSurfDesc->uiOffsets[2];
-                    pVpHalSrcSurf->OsResource.UPlaneOffset.iYOffset       = 0;
-                    break;
-                case Media_Format_A8R8G8B8:
-                    break;
-                default:
-                    break;
-            }
-        }
-        else
-        {
-            pVpHalSrcSurf->OsResource.b16UsrPtrMode = false;
-        }
-    }
-    else
-    {
-        pVpHalSrcSurf->b16UsrPtr                 = false;
-        pVpHalSrcSurf->OsResource.b16UsrPtrMode  = false;
-    }
+    // Add external surface info
+    vaStatus = VpGetExternalSurfaceInfo(pMediaSrcSurf, pVpHalSrcSurf);
+    DDI_CHK_RET(vaStatus, "Failed to update external surface.");
+
     return VA_STATUS_SUCCESS;
 }
 
@@ -3214,24 +3264,10 @@ VAStatus DdiVp_BeginPicture(
 
     pVpHalRenderParams->bReportStatus    = true;
     pVpHalRenderParams->StatusFeedBackID = vaSurfID;
-    if (pMediaTgtSurf->pSurfDesc && (pMediaTgtSurf->pSurfDesc->uiVaMemType == VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR))
-    {
-        pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]->b16UsrPtr = VpIs16UsrPtrPitch(pMediaTgtSurf->iPitch, pMediaTgtSurf->format);
-        if (pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]->b16UsrPtr)
-        {
-            pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]->OsResource.iPitch = pMediaTgtSurf->iPitch;
-            pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]->OsResource.b16UsrPtrMode = true;
-        }
-        else
-        {
-            pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]->OsResource.b16UsrPtrMode = false;
-        }
-    }
-    else
-    {
-        pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]->b16UsrPtr = false;
-        pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]->OsResource.b16UsrPtrMode = false;
-    }
+
+    // Get external surface info
+    vaStatus = VpGetExternalSurfaceInfo(pMediaTgtSurf, pVpHalRenderParams->pTarget[pVpHalRenderParams->uDstCount]);
+
     // increase render target count
     pVpHalRenderParams->uDstCount++;
 
-- 
2.26.0.windows.1

