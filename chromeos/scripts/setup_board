#!/bin/bash

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This script sets up a the sysroot for a particular target board.

# Load common constants.  This should be the first executable line.
# The path to common.sh should be relative to your script's location.
. "$(dirname "$0")/common.sh"

# Script must be run inside the chroot
restart_in_chroot_if_needed $*

get_default_board

# Flags
DEFINE_string board "$DEFAULT_BOARD" \
  "The name of the board to set up."
DEFINE_string build_root "/build" \
  "The root location for board sysroots."
DEFINE_string board_overlay "" \
  "Location of the board overlay."
DEFINE_string variant "" \
  "Board variant."
DEFINE_string toolchain "" \
  "Toolchain.  For example: i686-pc-linux-gnu, armv7a-softfloat-linux-gnueabi"
DEFINE_boolean usepkg $FLAGS_TRUE \
  "Use binary packages to bootstrap."
DEFINE_boolean force $FLAGS_FALSE \
  "Force re-creating board root."
DEFINE_string binutils_version "2.19.1-r1" \
  "Version of binutils to use."
DEFINE_string gcc_version "4.4.1" \
  "Version of gcc to use."
DEFINE_string libc_version "2.10.1-r1" \
  "Version of libc to use."
DEFINE_string kernel_version "2.6.30-r1" \
  "Version of kernel headers to use."
DEFINE_boolean default $FLAGS_FALSE \
  "Set board to the default board in your chroot"
DEFINE_boolean fast ${DEFAULT_FAST} "Call many emerges in parallel"

# Parse command line flags
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

# Only now can we die on error.  shflags functions leak non-zero error codes,
# so will die prematurely if 'set -e' is specified before now.
set -e

if [ -z "$FLAGS_board" ] ; then
  error "--board required."
  exit 1
fi

BOARD=$(echo "$FLAGS_board" |cut -d '_' -f 1)
VARIANT=${FLAGS_variant:-$(echo "$FLAGS_board" |cut -s -d '_' -f 2)}

if [ -n "$VARIANT" ] ; then
  BOARD_VARIANT="${BOARD}_${VARIANT}"
else
  BOARD_VARIANT="${BOARD}"
fi

BOARD_ROOT="${FLAGS_build_root}/${BOARD_VARIANT}"
if [ -d "$BOARD_ROOT" ] ; then
  if [[ $FLAGS_force -eq $FLAGS_TRUE ]]; then
    echo "--force set.  Re-creating $BOARD_ROOT..."
    # Removal takes long. Make it asynchronous.
    TEMP_DIR=`mktemp -d`
    sudo mv $BOARD_ROOT $TEMP_DIR
    sudo rm -rf $TEMP_DIR &
  else
    error "Board output directory '$BOARD_ROOT' already exists."
    exit 1
  fi
fi

#
# Construct board overlay list.
#
BOARD_OVERLAY_LIST=""

#
# Check for chromeos-overlay and add it to the BOARD_OVERLAY_LIST.
#
CHROMEOS_OVERLAY="${SRC_ROOT}/private-overlays/chromeos-overlay"

if [ -d "${CHROMEOS_OVERLAY}" ]; then
  BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${CHROMEOS_OVERLAY}"
fi

#
# Check if there are any board overlays.  There should be at least a top
# level board specific overlay.
#
PRIMARY_BOARD_OVERLAY="${SRC_ROOT}/overlays/overlay-${BOARD}"
BOARD_MAKE_CONF_LIST=""

if [ ! -d "${PRIMARY_BOARD_OVERLAY}" ]; then
  warn "No board overlay found. [${PRIMARY_BOARD_OVERLAY}]"
else
  BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${PRIMARY_BOARD_OVERLAY}"

  #
  # Link make.conf.board to the board overlay's make.conf.  It must exist.
  #
  BOARD_MAKE_CONF="${PRIMARY_BOARD_OVERLAY}/make.conf"
  BOARD_MAKE_CONF_LIST="${PRIMARY_BOARD_MAKE_CONF}"

  if [ ! -f "${BOARD_MAKE_CONF}" ]; then
    error "No board make.conf found. [${BOARD_MAKE_CONF}]"
    exit 1
  fi

  #
  # Fetch the toolchain from the board overlay.
  #
  BOARD_TOOL_CHAIN="${PRIMARY_BOARD_OVERLAY}/toolchain.conf"

  if [ ! -f "${BOARD_TOOL_CHAIN}" ]; then
    error "No board toolchain.conf found. [${BOARD_TOOL_CHAIN}]"
    exit 1
  fi

  FLAGS_toolchain=${FLAGS_toolchain:-$(cat ${BOARD_TOOL_CHAIN})}

  #
  # Populate the BOARD_OVERLAY_LIST with the primary board overlay and any
  # additional overlays.
  #
  if [ -d "${SRC_ROOT}/private-overlays" ] ; then
    EXTRA_BOARD_OVERLAY_LIST=$(find \
      "${SRC_ROOT}/private-overlays" \
      -maxdepth 1 \
      -type d \
      -name "overlay-${BOARD}-*" | sort -r)
    BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${EXTRA_BOARD_OVERLAY_LIST}"
  fi

  if [ -n "$VARIANT" ] ; then
    VARIANT_OVERLAY="${SRC_ROOT}/overlays/overlay-variant-${BOARD}-${VARIANT}"
    if [ ! -d "$VARIANT_OVERLAY" ] ; then
      error "Can't find variant overlay directory $VARIANT_OVERLAY"
      exit 1
    fi
    BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${VARIANT_OVERLAY}"
  fi
fi

#
# Finally, add in any user requested board overlays.
#
BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${FLAGS_board_overlay}"

#
# Populate the BOARD_MAKE_CONF_LIST with any additional make.conf files.
#
for overlay in ${BOARD_OVERLAY_LIST} ; do
  if [ -f "${overlay}/make.conf" ]; then
    BOARD_MAKE_CONF_LIST="${BOARD_MAKE_CONF_LIST} ${overlay}/make.conf"
  fi
done

# Figure out ARCH from the given toolchain
# TODO: Move to common.sh as a function after scripts are switched over.
if [ -z "${FLAGS_toolchain}" ]; then
  error "No toolchain specified in board overlay or on command line."
  exit 1
fi

TC_ARCH=$(echo "$FLAGS_toolchain" | awk -F'-' '{ print $1 }')
case "$TC_ARCH" in
  arm*)
    ARCH="arm"
    ;;
  *86)
    ARCH="x86"
    ;;
  *)
    error "Unable to determine ARCH from toolchain: $FLAGS_toolcahin"
    exit 1
esac

HARDENED=0
if portageq envvar USE |grep -q hardened
then
  HARDENED=1
fi

CROSSTOOL=0
if emerge --info |grep crosstool > /dev/null
then
  # TODO: Remove this when crosstool work on for all target archs
  if [ "$ARCH" == "x86" ]; then
    CROSSTOOL=1
  fi
fi

# Hardened requires gcc 4.4.3 to get the proper specs files, etc. applied.
if [ "$HARDENED" -eq "1" ] ; then
   FLAGS_gcc_version="4.4.3-r4"
fi

if [ "$CROSSTOOL" -eq "1" ] ; then
  FLAGS_gcc_version="4.4.3"
fi

# If all 4 toolchain packages are not installed, then install them!
set +e
TC_INSTALL=false
for i in glibc gcc binutils linux-headers; do
  if ! equery l "cross-${FLAGS_toolchain}/$i*"; then
    TC_INSTALL=true
  fi
done
set -e
if $TC_INSTALL; then
  BINHOST=$(portageq envvar PORTAGE_BINHOST)
  CROSS_BINHOST="${BINHOST}../cross/$FLAGS_toolchain/"
  CROSS_BINUTILS="--binutils $FLAGS_binutils_version"
  CROSS_GCC="--gcc $FLAGS_gcc_version"
  CROSS_KERNEL="--kernel $FLAGS_kernel_version"
  CROSS_LIBC="--libc $FLAGS_libc_version"
  CROSS_USEPKG=""
  if [[ $FLAGS_usepkg -eq $FLAGS_TRUE ]]; then
    CROSS_USEPKG="--portage --getbinpkg --portage --usepkgonly"
  fi
  sudo PORTAGE_BINHOST="$CROSS_BINHOST" crossdev \
    --target "$FLAGS_toolchain" \
    $CROSS_BINUTILS \
    $CROSS_GCC      \
    $CROSS_KERNEL   \
    $CROSS_LIBC     \
    $CROSS_USEPKG
fi

sudo mkdir -p "$BOARD_ROOT"

# Set up toolchain wrappers to force $SYSROOT and perform sanity checks.
GCC_VERSION=`echo ${FLAGS_gcc_version} | sed -e 's/\-r[0-9]*$//g'`
GCC_PROFILE="${FLAGS_toolchain}-${GCC_VERSION}"
GCC_BIN_PATH=$(gcc-config --get-bin-path "$GCC_PROFILE")
CCACHE_BIN=$(which ccache || true)
for i in c++ cpp g++ gcc gfortran ; do
  GCC_BINARY="${GCC_BIN_PATH}/$FLAGS_toolchain-${i}"
  if [ ! -f "${GCC_BINARY}.real" ] ; then
    sudo mv "$GCC_BINARY" "${GCC_BINARY}.real"
    sudo ln -s "${SCRIPTS_DIR}/sysroot_wrapper" "$GCC_BINARY"
  fi
  if [ -f "${CCACHE_BIN}" ]; then
    sudo ln -sf "${CCACHE_BIN}" "/usr/lib/ccache/bin/${FLAGS_toolchain}-${i}"
  fi
done

# TODO(cmasone): Do this more cleanly, if we figure out what "cleanly" means.
# Set up wrapper for pkg-config.  Point a board-specific wrapper at the
# generic wrapper script created by crossdev-wrapper
sudo ln -sf "/usr/bin/cross-pkg-config" "/usr/bin/${FLAGS_toolchain}-pkg-config"

#
# Untar glibc to get most of the headers required to build.
#
PKGDIR=$(portageq envvar PKGDIR)
sudo tar jxpf \
  "${PKGDIR}/cross/${FLAGS_toolchain}/cross-${FLAGS_toolchain}"/glibc-${FLAGS_libc_version}.tbz2 \
  -C "${BOARD_ROOT}" --strip-components=3

# Symlink for libstdc++.la issues. It appears that when packages get merged
# the .la files will be updated, and for libstdc++ it will use the wrong
# location. This works around that issue.
sudo ln -sf /usr/lib64/gcc "${BOARD_ROOT}/usr/lib/gcc"

# Setup make.conf and make.profile as symlinks to ones in revision control
CHROMIUMOS_OVERLAY="/usr/local/portage/chromiumos/"
CHROMIUMOS_CONFIG="${CHROMIUMOS_OVERLAY}/chromeos/config"
CHROMIUMOS_PROFILES="${CHROMIUMOS_OVERLAY}/profiles"
BOARD_ETC="${BOARD_ROOT}/etc"
BOARD_PROFILE="${BOARD_ETC}/portage/profile"
sudo mkdir -p "${BOARD_ETC}" "${BOARD_PROFILE}"

# Start with the crossdev etc
# TODO(tedbo): The sed lines are hacks to fix an issue where the crossdev
# wrapper wants to assume that SYSROOT is /usr/${CHOST}. We should fix this
# in the crossdev code and try to upstream.
sudo cp -a /usr/share/crossdev/etc/* "${BOARD_ETC}"
sudo sed -i 's/${CHOST}/${SYSROOT}/g' "${BOARD_ETC}/portage/bashrc"
sudo sed -i 's/CROSS_ROOT=""/CROSS_ROOT="$1"/g' /usr/bin/cross-fix-root

# Tell portage that toolchain packages are already installed in the sysroot.
PROVIDED="${BOARD_PROFILE}/package.provided"
sudo sh -c \
  "echo \"sys-devel/binutils-${FLAGS_binutils_version}\" >> \"${PROVIDED}\""
sudo sh -c "echo \"sys-devel/gcc-${FLAGS_gcc_version}\" >> \"${PROVIDED}\""
sudo sh -c "echo \"sys-libs/glibc-${FLAGS_libc_version}\" >> \"${PROVIDED}\""

# Setup the make.confs. We use the following:
#    make.conf             <- Overall target make.conf [arm, x86, etc. version]
#    make.conf.board_setup <- Declares CHOST, ROOT, etc.
#    make.conf.common      <- Common settings across all targets
#    make.conf.board       <- Optional board-supplied make.conf
if [ "$HARDENED" -eq "1" ] ; then
  sudo ln -sf "${CHROMIUMOS_CONFIG}/make-hardened.conf.${ARCH}-target" \
    "${BOARD_ETC}/make.conf"
else
  sudo ln -sf "${CHROMIUMOS_CONFIG}/make.conf.${ARCH}-target" \
    "${BOARD_ETC}/make.conf"
fi
sudo ln -sf "${CHROMIUMOS_CONFIG}/make.conf.common-target" \
  "${BOARD_ETC}/make.conf.common"
cat <<EOF | sudo dd of="${BOARD_ETC}/make.conf.board_setup"
# Created by setup_board
CHOST="${FLAGS_toolchain}"
ROOT="${BOARD_ROOT}/"
BOARD_OVERLAY="${BOARD_OVERLAY_LIST}"
MAKEOPTS="-j${NUM_JOBS}"
LIBC_VERSION="$FLAGS_libc_version"
EOF

sudo touch "${BOARD_ETC}/make.conf.board"

for make_conf in ${BOARD_MAKE_CONF_LIST} ; do
  sudo bash -c "echo source ${make_conf} >> ${BOARD_ETC}/make.conf.board"
done

# Setup make.globals and the profile.
sudo touch /etc/make.conf.user
sudo ln -sf /etc/make.globals "${BOARD_ROOT}/etc/make.globals"
sudo ln -sf /etc/make.conf.user "${BOARD_ROOT}/etc/make.conf.user"
sudo rm "${BOARD_ROOT}/etc/make.profile"
sudo ln -sf \
  "${CHROMIUMOS_PROFILES}/default/linux/${ARCH}/10.0/chromeos/" \
  "${BOARD_ROOT}/etc/make.profile"

# Create emerge wrapper
EMERGE_WRAPPER="/usr/local/bin/emerge-${BOARD_VARIANT}"
EBUILD_WRAPPER="/usr/local/bin/ebuild-${BOARD_VARIANT}"
EQUERY_WRAPPER="/usr/local/bin/equery-${BOARD_VARIANT}"
PORTAGEQ_WRAPPER="/usr/local/bin/portageq-${BOARD_VARIANT}"
cat <<EOF | sudo dd of="$EMERGE_WRAPPER" > /dev/null 2>&1
#!/bin/bash

export CHROMEOS_ROOT="$GCLIENT_ROOT"
export CHOST="$FLAGS_toolchain"
export PORTAGE_CONFIGROOT="$BOARD_ROOT"
export SYSROOT="$BOARD_ROOT"
if [ -z "\$PORTAGE_USERNAME" ]; then
  export PORTAGE_USERNAME=\$(basename \$HOME)
fi
EOF

sudo chmod +x "$EMERGE_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$EBUILD_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$EQUERY_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$PORTAGEQ_WRAPPER"

cat <<EOF | sudo dd of="$EMERGE_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
exec sudo -E emerge --root-deps "\$@"
EOF

cat <<EOF | sudo dd of="$EBUILD_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E ebuild "\$@"
EOF

cat <<EOF | sudo dd of="$EQUERY_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E equery "\$@"
EOF

cat <<EOF | sudo dd of="$PORTAGEQ_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E portageq "\$@"
EOF

#
# Before we can emerge the kernel, we need to emerge hard-host-depends.
#
EMERGE_CMD="emerge"
if [ "$FLAGS_fast" -eq "${FLAGS_TRUE}" ]; then
  EMERGE_CMD="${SCRIPTS_DIR}/parallel_emerge"
fi
sudo ${EMERGE_CMD} -uDNvg chromeos-base/hard-host-depends world

#
# Emerge the kernel headers into the board build root.
#
sudo "${EMERGE_WRAPPER}" --quiet kernel

# We need to install libstdc++ manually from the cross toolchain.
# TODO: Figure out a better way of doing this?
sudo cp -a /usr/lib/gcc/"${FLAGS_toolchain}"/"${GCC_VERSION}"/libgcc_s.so* "${BOARD_ROOT}/lib"
sudo cp -a /usr/lib/gcc/"${FLAGS_toolchain}"/"${GCC_VERSION}"/libstdc++.so* \
  "${BOARD_ROOT}/usr/lib"

if [ $FLAGS_default -eq $FLAGS_TRUE ] ; then
  echo $BOARD_VARIANT > "$GCLIENT_ROOT/src/scripts/.default_board"
fi

echo "Done!"
echo "You can use the following wrappers:"
echo "  ${EMERGE_WRAPPER}"
echo "  ${EBUILD_WRAPPER}"
echo "  ${EQUERY_WRAPPER}"
echo "  ${PORTAGEQ_WRAPPER}"
echo "The SYSROOT is: ${BOARD_ROOT}"
