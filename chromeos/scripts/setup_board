#!/bin/bash

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This script sets up a the sysroot for a particular target board.

# Load common constants.  This should be the first executable line.
# The path to common.sh should be relative to your script's location.
. "$(dirname "$0")/common.sh"

# Script must be run inside the chroot
assert_inside_chroot

get_default_board

# Flags
DEFINE_string board "$DEFAULT_BOARD" \
  "The name of the board to set up."
DEFINE_string build_root "/build" \
  "The root location for board sysroots."
DEFINE_string board_overlay "" \
  "Location of the board overlay."
DEFINE_string toolchain "" \
  "Toolchain.  For example: i686-pc-linux-gnu, armv7a-softfloat-linux-gnueabi"
DEFINE_boolean usepkg $FLAGS_TRUE \
  "Use binary packages to bootstrap."
DEFINE_boolean force $FLAGS_FALSE \
  "Force re-creating board root."
DEFINE_string binutils_version "2.19.1-r1" \
  "Version of binutils to use."
DEFINE_string gcc_version "4.4.1" \
  "Version of gcc to use."
DEFINE_string libc_version "2.10.1-r1" \
  "Version of libc to use."
DEFINE_string kernel_version "2.6.30-r1" \
  "Version of kernel headers to use."
DEFINE_boolean default $FLAGS_FALSE \
  "Set board to the default board in your chroot"

# Parse command line flags
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

# Only now can we die on error.  shflags functions leak non-zero error codes,
# so will die prematurely if 'set -e' is specified before now.
set -e

if [ -z "$FLAGS_board" ] ; then
  error "--board required."
  exit 1
fi
BOARD="$FLAGS_board"
BOARD_ROOT="${FLAGS_build_root}/${BOARD}"
if [ -d "$BOARD_ROOT" ] ; then
  if [[ $FLAGS_force -eq $FLAGS_TRUE ]]; then
    echo "--force set.  Re-creating $BOARD_ROOT..."
    # Removal takes long. Make it asynchronous.
    TEMP_DIR=`mktemp -d`
    sudo mv $BOARD_ROOT $TEMP_DIR
    sudo rm -rf $TEMP_DIR &
  else
    error "Board output directory '$BOARD_ROOT' already exists."
    exit 1
  fi
fi

#
# Construct board overlay list.
#
BOARD_OVERLAY_LIST=""

#
# Check for chromeos-overlay and add it to the BOARD_OVERLAY_LIST.
#
CHROMEOS_OVERLAY="${SRC_ROOT}/overlays/chromeos-overlay"

if [ -d "${CHROMEOS_OVERLAY}" ]; then
  BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${CHROMEOS_OVERLAY}"
fi

#
# Check if there are any board overlays.  There should be at least a top
# level board specific overlay.
#
PRIMARY_BOARD_OVERLAY="${SRC_ROOT}/overlays/overlay-${BOARD}"
BOARD_MAKE_CONF=""

if [ ! -d "${PRIMARY_BOARD_OVERLAY}" ]; then
  warn "No board overlay found. [${PRIMARY_BOARD_OVERLAY}]"
else
  BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${PRIMARY_BOARD_OVERLAY}"

  #
  # Link make.conf.board to the board overlay's make.conf.  It must exist.
  #
  BOARD_MAKE_CONF="${PRIMARY_BOARD_OVERLAY}/make.conf"

  if [ ! -f "${BOARD_MAKE_CONF}" ]; then
    error "No board make.conf found. [${BOARD_MAKE_CONF}]"
    exit 1
  fi

  #
  # Fetch the toolchain from the board overlay.
  #
  BOARD_TOOL_CHAIN="${PRIMARY_BOARD_OVERLAY}/toolchain.conf"

  if [ ! -f "${BOARD_TOOL_CHAIN}" ]; then
    error "No board toolchain.conf found. [${BOARD_TOOL_CHAIN}]"
    exit 1
  fi

  FLAGS_toolchain=${FLAGS_toolchain:-$(cat ${BOARD_TOOL_CHAIN})}

  #
  # Populate the BOARD_OVERLAY_LIST with the primary board overlay and any
  # additional overlays.
  #

  EXTRA_BOARD_OVERLAY_LIST=$(find \
    "${SRC_ROOT}/overlays" \
    -maxdepth 1 \
    -type d \
    -name "overlay-${BOARD}-*" | sort -r)

  BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${EXTRA_BOARD_OVERLAY_LIST}"
fi

#
# Finally, add in any user requested board overlays.
#
BOARD_OVERLAY_LIST="${BOARD_OVERLAY_LIST} ${FLAGS_board_overlay}"

# Figure out ARCH from the given toolchain
# TODO: Move to common.sh as a function after scripts are switched over.
if [ -z "${FLAGS_toolchain}" ]; then
  error "No toolchain specified in board overlay or on command line."
  exit 1
fi

TC_ARCH=$(echo "$FLAGS_toolchain" | awk -F'-' '{ print $1 }')
case "$TC_ARCH" in
  arm*)
    ARCH="arm"
    ;;
  *86)
    ARCH="x86"
    ;;
  *)
    error "Unable to determine ARCH from toolchain: $FLAGS_toolcahin"
    exit 1
esac

# If the toolchain does not exist, then build it!
TOOLCHAIN_ROOT="/usr/${FLAGS_toolchain}"
if [ ! -d "$TOOLCHAIN_ROOT" ] ; then
  BINHOST=$(portageq envvar PORTAGE_BINHOST)
  CROSS_BINHOST="${BINHOST}/cross/$FLAGS_toolchain/"
  CROSS_BINUTILS="--binutils $FLAGS_binutils_version"
  CROSS_GCC="--gcc $FLAGS_gcc_version"
  CROSS_KERNEL="--kernel $FLAGS_kernel_version"
  CROSS_LIBC="--libc $FLAGS_libc_version"
  CROSS_USEPKG=""
  if [[ $FLAGS_usepkg -eq $FLAGS_TRUE ]]; then
    CROSS_USEPKG="--portage --getbinpkg --portage --usepkgonly"
  fi
  sudo PORTAGE_BINHOST="$CROSS_BINHOST" crossdev \
    --target "$FLAGS_toolchain" \
    $CROSS_BINUTILS \
    $CROSS_GCC      \
    $CROSS_KERNEL   \
    $CROSS_LIBC     \
    $CROSS_USEPKG
fi

sudo mkdir -p "$BOARD_ROOT"

# Set up toolchain wrappers to force $SYSROOT and perform sanity checks.
GCC_PROFILE="${FLAGS_toolchain}-${FLAGS_gcc_version}"
GCC_BIN_PATH=$(gcc-config --get-bin-path "$GCC_PROFILE")
for i in c++ cpp g++ gcc gfortran ; do
  GCC_BINARY="${GCC_BIN_PATH}/$FLAGS_toolchain-${i}"
  if [ ! -f "${GCC_BINARY}.real" ] ; then
    sudo mv "$GCC_BINARY" "${GCC_BINARY}.real"
    sudo ln -s "${SCRIPTS_DIR}/sysroot_wrapper" "$GCC_BINARY"
  fi
done

# TODO(cmasone): Do this more cleanly, if we figure out what "cleanly" means.
# Set up wrapper for pkg-config.  Point a board-specific wrapper at the
# generic wrapper script created by crossdev-wrapper
sudo ln -sf "/usr/bin/cross-pkg-config" "/usr/bin/${FLAGS_toolchain}-pkg-config"

#
# Untar glibc to get most of the headers required to build.
#
PKGDIR=$(portageq envvar PKGDIR)
sudo tar jxpf \
  "${PKGDIR}/cross/${FLAGS_toolchain}/cross-${FLAGS_toolchain}"/glibc-${FLAGS_libc_version}.tbz2 \
  -C "${BOARD_ROOT}" --strip-components=3

# Symlink for libstdc++.la issues. It appears that when packages get merged
# the .la files will be updated, and for libstdc++ it will use the wrong
# location. This works around that issue.
sudo ln -sf /usr/lib64/gcc "${BOARD_ROOT}/usr/lib/gcc"

# Setup make.conf and make.profile as symlinks to ones in revision control
CHROMIUMOS_OVERLAY="/usr/local/portage/chromiumos/"
CHROMIUMOS_CONFIG="${CHROMIUMOS_OVERLAY}/chromeos/config"
CHROMIUMOS_PROFILES="${CHROMIUMOS_OVERLAY}/profiles"
BOARD_ETC="${BOARD_ROOT}/etc"
BOARD_PROFILE="${BOARD_ETC}/portage/profile"
sudo mkdir -p "${BOARD_ETC}" "${BOARD_PROFILE}"

# Start with the crossdev etc
# TODO(tedbo): The sed lines are hacks to fix an issue where the crossdev
# wrapper wants to assume that SYSROOT is /usr/${CHOST}. We should fix this
# in the crossdev code and try to upstream.
sudo cp -a /usr/share/crossdev/etc/* "${BOARD_ETC}"
sudo sed -i 's/${CHOST}/${SYSROOT}/g' "${BOARD_ETC}/portage/bashrc"
sudo sed -i 's/CROSS_ROOT=""/CROSS_ROOT="$1"/g' /usr/bin/cross-fix-root

# Tell portage that toolchain packages are already installed in the sysroot.
PROVIDED="${BOARD_PROFILE}/package.provided"
sudo sh -c \
  "echo \"sys-devel/binutils-${FLAGS_binutils_version}\" >> \"${PROVIDED}\""
sudo sh -c "echo \"sys-devel/gcc-${FLAGS_gcc_version}\" >> \"${PROVIDED}\""
sudo sh -c "echo \"sys-libs/glibc-${FLAGS_libc_version}\" >> \"${PROVIDED}\""

# Setup the make.confs. We use the following:
#    make.conf             <- Overall target make.conf [arm, x86, etc. version]
#    make.conf.board_setup <- Declares CHOST, ROOT, etc.
#    make.conf.common      <- Common settings across all targets
#    make.conf.board       <- Optional board-supplied make.conf
sudo ln -sf "${CHROMIUMOS_CONFIG}/make.conf.${ARCH}-target" \
  "${BOARD_ETC}/make.conf"
sudo ln -sf "${CHROMIUMOS_CONFIG}/make.conf.common-target" \
  "${BOARD_ETC}/make.conf.common"
cat <<EOF | sudo dd of="${BOARD_ETC}/make.conf.board_setup"
# Created by setup_board
CHOST="${FLAGS_toolchain}"
ROOT="${BOARD_ROOT}/"
BOARD_OVERLAY="${BOARD_OVERLAY_LIST}"
MAKEOPTS="-j${NUM_JOBS}"
LIBC_VERSION="$FLAGS_libc_version"
EOF

if [ -f "${BOARD_MAKE_CONF}" ]; then
  sudo ln -sf "${BOARD_MAKE_CONF}" "${BOARD_ETC}/make.conf.board"
else
  sudo touch "${BOARD_ETC}/make.conf.board"
fi

# Setup make.globals and the profile.
sudo touch /etc/make.conf.user
sudo ln -sf /etc/make.globals "${BOARD_ROOT}/etc/make.globals"
sudo ln -sf /etc/make.conf.user "${BOARD_ROOT}/etc/make.conf.user"
sudo rm "${BOARD_ROOT}/etc/make.profile"
sudo ln -sf \
  "${CHROMIUMOS_PROFILES}/default/linux/${ARCH}/10.0/chromeos/" \
  "${BOARD_ROOT}/etc/make.profile"

# Create emerge wrapper
EMERGE_WRAPPER="/usr/local/bin/emerge-${BOARD}"
EBUILD_WRAPPER="/usr/local/bin/ebuild-${BOARD}"
EQUERY_WRAPPER="/usr/local/bin/equery-${BOARD}"
cat <<EOF | sudo dd of="$EMERGE_WRAPPER" > /dev/null 2>&1
#!/bin/bash

export CHROMEOS_ROOT="$GCLIENT_ROOT"
export CHOST="$FLAGS_toolchain"
export PORTAGE_CONFIGROOT="$BOARD_ROOT"
export SYSROOT="$BOARD_ROOT"
export PORTAGE_USERNAME="\$USER"
EOF

sudo chmod +x "$EMERGE_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$EBUILD_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$EQUERY_WRAPPER"

cat <<EOF | sudo dd of="$EMERGE_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
exec sudo -E emerge --root-deps "\$@"
EOF

cat <<EOF | sudo dd of="$EBUILD_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BUILD_ROOT"
exec sudo -E ebuild "\$@"
EOF

cat <<EOF | sudo dd of="$EQUERY_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E equery "\$@"
EOF

#
# Emerge the kernel headers into the board build root.
#
sudo "${EMERGE_WRAPPER}" --quiet kernel-headers

# We need to install libstdc++ manually from the cross toolchain.
# TODO: Figure out a better way of doing this?
sudo cp -a /usr/lib/gcc/"${FLAGS_toolchain}"/*/libgcc_s.so* "${BOARD_ROOT}/lib"
sudo cp -a /usr/lib/gcc/"${FLAGS_toolchain}"/*/libstdc++.so* \
  "${BOARD_ROOT}/usr/lib"

if [ $FLAGS_default -eq $FLAGS_TRUE ] ; then
  echo $FLAGS_board > "$GCLIENT_ROOT/src/scripts/.default_board"
fi

echo "Done!"
echo "You can use the emerge wrapper: ${EMERGE_WRAPPER}"
echo "The SYSROOT is: ${BOARD_ROOT}"
