#!/bin/bash

# Copyright (c) 2009 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Script to customize the root file system after packages have been installed.
#
# NOTE: This is currently a dumping ground for for a bunch of hacks, some of
# which are to work around the fact that we are trying not to modify the base
# Chrome OS source when experimenting with this build system. Eventually most
# of this file should go away.
#

# Load common constants.  This should be the first executable line.
# The path to common.sh should be relative to your script's location.
. "$(dirname "$0")/common.sh"

# Script must be run inside the chroot
assert_inside_chroot

# Flags
DEFINE_string target "x86" \
  "The target architecture to build for. One of { x86, arm }."
DEFINE_string board ""      \
  "The board to build an image for."
DEFINE_string root ""      \
  "The root file system to customize."
DEFINE_boolean withdev $FLAGS_TRUE \
  "Include useful developer friendly utilities in the image."
DEFINE_string factory_server $FLAGS_FALSE \
  "Build a factory install image pointing to given server."

# Parse command line
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

# Die on any errors.
set -e

. "${SCRIPTS_DIR}/chromeos_version.sh"

ROOT_FS_DIR="$FLAGS_root"
if [[ -z "$ROOT_FS_DIR" ]]; then
  echo "Error: --root is required."
  exit 1
fi
if [[ ! -d "$ROOT_FS_DIR" ]]; then
  echo "Error: Root FS does not exist? ($ROOT_FS_DIR)"
  exit 1
fi

# TODO: Is this still necessary?
sudo chmod 0755 "${ROOT_FS_DIR}/."

# TODO: Temporarily pre-seed the devices in /dev for debugging purposes.
sudo cp -a "${ROOT_FS_DIR}/lib/chromiumos/devices/"* "${ROOT_FS_DIR}/dev"

# Create getty on tty2
# TODO: Move this into platform/init and fix "start on" clause.
if [ ! -f "$ROOT_FS_DIR"/etc/init/tty2.conf ]; then
  cat <<EOF | sudo dd of="$ROOT_FS_DIR"/etc/init/tty2.conf
start on startup
stop on starting halt or starting reboot

respawn
exec /sbin/agetty 38400 tty2 linux
EOF
fi

# Set up a default dev user, update the password entry, and add to sudo.
# TODO: Make the default user conditional on building a dev image.
DEV_USER="chronos"
DEV_UID="1000"  # NOTE: Some scripts expect the system user id to be 1000.
SHELL="/bin/sh"
if [[ -x "${ROOT_FS_DIR}/bin/bash" ]] ; then
  SHELL="/bin/bash"
fi
# Determine what password to use for the default user.
CRYPTED_PASSWD_FILE="${SCRIPTS_DIR}/shared_user_passwd.txt"
if [ -f $CRYPTED_PASSWD_FILE ]; then
  echo "Using password from $CRYPTED_PASSWD_FILE"
  CRYPTED_PASSWD=$(cat $CRYPTED_PASSWD_FILE)
else
  # Use a random password.  unix_md5_crypt will generate a random salt.
  echo "Using random password."
  PASSWORD="$(base64 /dev/urandom | head -1)"
  CRYPTED_PASSWD="$(echo "$PASSWORD" | openssl passwd -1 -stdin)"
  PASSWORD="gone now"
fi
# Replace the DEV_USER passwd entry with one that sets the proper shell and
# specifies that the passwd should come from /etc/shadow.
sudo sed -i "{ s|${DEV_USER}:\*:\(.*\):.*|${DEV_USER}:x:\1:${SHELL}| }" \
  "${ROOT_FS_DIR}/etc/passwd"
echo "${DEV_USER}:${CRYPTED_PASSWD}:14500:0:99999::::" \
  | sudo dd of="${ROOT_FS_DIR}/etc/shadow" conv=notrunc oflag=append
sudo mkdir -p "${ROOT_FS_DIR}/home/${DEV_USER}"
sudo chown "${DEV_UID}.${DEV_UID}" "${ROOT_FS_DIR}/home/${DEV_USER}"
cat <<EOF | sudo dd of="${ROOT_FS_DIR}/etc/sudoers" conv=notrunc oflag=append
%adm ALL=(ALL) ALL
$DEV_USER ALL=NOPASSWD: ALL
EOF
sudo chmod 0440 "${ROOT_FS_DIR}/etc/sudoers"

echo "# Allow chronos user to renice processes so that chrome will adjust tab priorities" | \
  sudo dd of="${ROOT_FS_DIR}/etc/security/limits.conf" conv=notrunc oflag=append
echo "chronos hard nice 0" | \
  sudo dd of="${ROOT_FS_DIR}/etc/security/limits.conf" conv=notrunc oflag=append

# TODO: Since the stateful partition may not have a chronos home directory
# on it, we create one here if necessary.
cat <<EOF | sudo dd of="$ROOT_FS_DIR"/etc/init/homedir.conf
start on stopped startup

task
script

if [ ! -d "/home/$DEV_USER" ]; then
  mkdir "/home/$DEV_USER"
  chown $DEV_USER.$DEV_USER "/home/$DEV_USER"
fi

end script
EOF

# Clobber stock rsyslog.conf with our own
RSYSLOG_CONF="$ROOT_FS_DIR"/etc/rsyslog.conf
test -f "${RSYSLOG_CONF}" && sudo mv "${RSYSLOG_CONF}" "${RSYSLOG_CONF}".orig
cat <<'EOF' | sudo dd of="${RSYSLOG_CONF}"
# NB: auto-generated by customize_rootfs

$ModLoad immark.so # provides --MARK-- message capability
$ModLoad imuxsock.so # provides support for local system logging (e.g. via logger command)
$ModLoad imklog.so # kernel logging (formerly provided by rklogd)

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.*;mail.none;authpriv.none;cron.none                  -/var/log/messages

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log cron stuff
cron.*                                                  -/var/log/cron

# Everybody gets emergency messages
*.emerg                                                 *

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log

# wpa_supplicant/hostapd can be configured to log to local6
local6.*                                                /var/log/hostap.log
EOF

# Add mtab
sudo ln -s /proc/mounts "${ROOT_FS_DIR}/etc/mtab"

# The above initscripts expect some binaries to be in a different location
# TODO: Remove after this is fixed in the initscripts.
sudo ln -s /usr/bin/dbus-uuidgen "${ROOT_FS_DIR}/bin/dbus-uuidgen"
sudo ln -s /usr/bin/dbus-daemon "${ROOT_FS_DIR}/bin/dbus-daemon"

# TODO: Remove this after we are building our own wpa_supplicant. Also, on
# the ARM build for some reason this symlink is already there?
! sudo ln -s /usr/sbin/wpa_supplicant "${ROOT_FS_DIR}/sbin/wpa_supplicant"

# The gtk++ library has the wrong path when it dlopens some modules
sudo ln -s /usr/lib "${ROOT_FS_DIR}/usr/lib64"

# TODO: Temporarily create fake xterm symlink until we do proper xinitrc
ATERM="${ROOT_FS_DIR}/usr/bin/aterm"
if [[ -f "${ATERM}" ]]; then
  sudo chmod 0755 "${ROOT_FS_DIR}/usr/bin/aterm"
  sudo ln -s aterm "${ROOT_FS_DIR}/usr/bin/xterm"
fi

# TODO: Until libGL.so is fixed, create symlink libGL.so.1 -> libGL.so
sudo ln -s libGL.so "${ROOT_FS_DIR}/usr/lib/libGL.so.1"

# TODO: If slim is not installed, we fake it out so that our init script
# will return a success result.
if [[ ! -f "${ROOT_FS_DIR}/usr/bin/slim" ]]; then
  sudo ln -s /bin/true "${ROOT_FS_DIR}/usr/bin/slim"
fi

# TODO: until we switch away from the old build altogether
sudo mkdir -p  "${ROOT_FS_DIR}/usr/bin/X11"
sudo ln -s  /usr/bin/Xorg  "${ROOT_FS_DIR}/usr/bin/X11/X"

POLICY_CONFIG="${ROOT_FS_DIR}/usr/share/polkit-1/actions/org.freedesktop.devicekit.disks.policy"
if [ -f "$POLICY_CONFIG" ]; then
  POLICY_TMP="$(mktemp)"
  cat "$POLICY_CONFIG" | awk '
{ PRINTED = 0 }

/<action id="/ {
  IN_STANZA = 0;
  PRINTED = 1;
  print $0;
}

/<action id="org\.freedesktop.devicekit.disks.filesystem-mount">/ {
  IN_STANZA = 1;
  if (PRINTED == 0) {
    PRINTED = 1;
    print $0;
  }
}

/<allow_any>no/ {
  PRINTED = 1;
  if (IN_STANZA) {
    print "      <allow_any>yes</allow_any>";
  } else {
    print $0;
  }
}

{ if (PRINTED == 0) print $0 }

' > "$POLICY_TMP"
  sudo mv "$POLICY_TMP" "$POLICY_CONFIG"
fi

# If dash is installed then we want to use that as our default /bin/sh
if [[ -x "${ROOT_FS_DIR}/bin/dash" ]] ; then
  sudo ln -sf dash "${ROOT_FS_DIR}/bin/sh"
fi

# If vim is installed, then a vi symlink would probably help
if [[ -x "${ROOT_FS_DIR}/usr/bin/vim" ]] ; then
  sudo ln -sf vim "${ROOT_FS_DIR}/usr/bin/vi"
fi

# If mawk is installed, awk should symlink to that.
# TODO: Maybe fix this by using a virtual/awk?
if [[ -x "${ROOT_FS_DIR}/usr/bin/mawk" ]] ; then
  sudo ln -sf mawk "${ROOT_FS_DIR}/usr/bin/awk"
fi

# TODO(msb): Ugly Hack fix for pango-querymodules
# pango-querymodules needs to be run on the target so we ran it on the target
# and stored the result which we copy here
CHROMIUMOS_OVERLAY="/usr/local/portage/chromiumos"
sudo cp "${CHROMIUMOS_OVERLAY}/chromeos/files/pango.modules" \
  "${ROOT_FS_DIR}"/etc/pango/
sudo chmod 0644 "${ROOT_FS_DIR}"/etc/pango/pango.modules

# TODO: This is a temporary script to start chromeos chrome.
cat <<"EOF" | sudo dd of="$ROOT_FS_DIR"/usr/bin/chromeos-chrome
#!/bin/sh

exec /opt/google/chrome/chrome
EOF
sudo chmod +x "$ROOT_FS_DIR"/usr/bin/chromeos-chrome

# Write stock lsb-release file
# Set CHROMEOS_VERSION_DESCRIPTION here (uses vars set in chromeos_version.sh)# Was removed from chromeos_version.sh which can also be run outside of chroot
# where CHROMEOS_REVISION is set
# We have to set (in build_image.sh) and use REAL_USER due to many nested
# chroots which lose $USER state.. "${SCRIPTS_DIR}/chromeos_version.sh"
if [ ${CHROMEOS_OFFICIAL:-0} = 1 ]; then
  export CHROMEOS_VERSION_DESCRIPTION="${CHROMEOS_VERSION_STRING} (Official Build ${CHROMEOS_REVISION:?})"
elif [ "$REAL_USER" = "chrome-bot" ]
then
  export CHROMEOS_VERSION_DESCRIPTION="${CHROMEOS_VERSION_STRING} (Continuous Build ${CHROMEOS_REVISION:?} - Builder: ${BUILDBOT_BUILD:-"N/A"})"
else
  # Use the $USER passthru via $CHROMEOS_RELEASE_CODENAME
  export CHROMEOS_VERSION_DESCRIPTION="${CHROMEOS_VERSION_STRING} (Developer Build ${CHROMEOS_REVISION:?} - $(date) - $CHROMEOS_RELEASE_CODENAME)"
fi

if [ -n "$FLAGS_factory_server" ]; then
  CHROMEOS_VERSION_AUSERVER="$FLAGS_factory_server"
  CHROMEOS_VERSION_DEVSERVER=""
fi

# Set google-specific version numbers:
# CHROMEOS_RELEASE_BOARD is the target board identifier.
# CHROMEOS_RELEASE_CODENAME is the codename of the release.
# CHROMEOS_RELEASE_DESCRIPTION is the version displayed by Chrome; see
#   chrome/browser/chromeos/chromeos_version_loader.cc.
# CHROMEOS_RELEASE_NAME is a human readable name for the build.
# CHROMEOS_RELEASE_TRACK and CHROMEOS_RELEASE_VERSION are used by the software
#   update service.
# TODO(skrul):  Remove GOOGLE_RELEASE once Chromium is updated to look at
#   CHROMEOS_RELEASE_VERSION for UserAgent data.
cat <<EOF | sudo dd of="${ROOT_FS_DIR}/etc/lsb-release"
CHROMEOS_RELEASE_BOARD=$FLAGS_board
CHROMEOS_RELEASE_CODENAME=$CHROMEOS_VERSION_CODENAME
CHROMEOS_RELEASE_DESCRIPTION=$CHROMEOS_VERSION_DESCRIPTION
CHROMEOS_RELEASE_NAME=$CHROMEOS_VERSION_NAME
CHROMEOS_RELEASE_TRACK=$CHROMEOS_VERSION_TRACK
CHROMEOS_RELEASE_VERSION=$CHROMEOS_VERSION_STRING
GOOGLE_RELEASE=$CHROMEOS_VERSION_STRING
CHROMEOS_AUSERVER=$CHROMEOS_VERSION_AUSERVER
CHROMEOS_DEVSERVER=$CHROMEOS_VERSION_DEVSERVER
EOF

if [ -n "$FLAGS_factory_server" ]; then
  cat <<EOF | sudo dd of="${ROOT_FS_DIR}/etc/lsb-release" \
              oflag=append conv=notrunc
FACTORY_INSTALL=1
HTTP_SERVER_OVERRIDE=true
EOF
  sudo sed -i '/CHROMEOS_DEVSERVER=/d' "${ROOT_FS_DIR}/etc/lsb-release"
fi

# We need to replace /etc/pulse/client.conf and /etc/pulse/default.pa with our
# own versions.
#
# TODO(ajwong): Find a way to override the default pulseaudio config files,
# ideally in an ebuild.
sudo mv "${ROOT_FS_DIR}/etc/pulse/client-cros.conf" \
  "${ROOT_FS_DIR}/etc/pulse/client.conf"
sudo mv "${ROOT_FS_DIR}/etc/pulse/default-cros.pa" \
  "${ROOT_FS_DIR}/etc/pulse/default.pa"

# We need to replace udev rules file for gps devices.
sudo cp "${CHROMIUMOS_OVERLAY}/chromeos/files/99-gpsd-usb.rules" \
  "${ROOT_FS_DIR}/etc/udev/rules.d/99-gpsd-usb.rules"
