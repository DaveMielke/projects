#!/bin/bash

# Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Script to customize the root file system after packages have been installed.
#
# NOTE: This is currently a dumping ground for for a bunch of hacks, some of
# which are to work around the fact that we are trying not to modify the base
# Chrome OS source when experimenting with this build system. Eventually most
# of this file should go away.

# --- BEGIN COMMON.SH BOILERPLATE ---
# Load common CrOS utilities.  Inside the chroot this file is installed in
# /usr/lib/crosutils.  Outside the chroot we find it relative to the script's
# location.
find_common_sh() {
  local common_paths=(/usr/lib/crosutils $(dirname "$0"))
  local path

  SCRIPT_ROOT=
  for path in "${common_paths[@]}"; do
    if [ -r "${path}/common.sh" ]; then
      SCRIPT_ROOT=${path}
      break
    fi
  done
}

find_common_sh
. "${SCRIPT_ROOT}/common.sh" || (echo "Unable to load common.sh" && exit 1)
# --- END COMMON.SH BOILERPLATE ---

# Script must be run inside the chroot
restart_in_chroot_if_needed "$@"

# Flags
DEFINE_string target "x86" \
  "The target architecture to build for. One of { x86, arm }."
DEFINE_string board ""      \
  "The board to build an image for."
DEFINE_string root ""      \
  "The root file system to customize."

# Parse command line
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

# Die on any errors.
set -e

. ${SRC_ROOT}/third_party/chromiumos-overlay/chromeos/config/chromeos_version.sh

ROOT_FS_DIR="$FLAGS_root"
if [[ -z "$ROOT_FS_DIR" ]]; then
  echo "Error: --root is required."
  exit 1
fi
if [[ ! -d "$ROOT_FS_DIR" ]]; then
  echo "Error: Root FS does not exist? ($ROOT_FS_DIR)"
  exit 1
fi

# TODO: Is this still necessary?
sudo chmod 0755 "${ROOT_FS_DIR}/."

# Set up a default dev user, update the password entry, and add to sudo.
# TODO: Make the default user conditional on building a dev image.
DEV_USER="chronos"
SHELL="/bin/sh"
[[ -x "${ROOT_FS_DIR}/usr/local/bin/bash" ]] && SHELL="/usr/local/bin/bash"
[[ -x "${ROOT_FS_DIR}/bin/bash" ]] && SHELL="/bin/bash"

# Determine what password to use for the default user.
CRYPTED_PASSWD_FILE="${SCRIPTS_DIR}/shared_user_passwd.txt"
if [ -f $CRYPTED_PASSWD_FILE ]; then
  echo "Using password from $CRYPTED_PASSWD_FILE"
  CRYPTED_PASSWD=$(cat $CRYPTED_PASSWD_FILE)
else
  # Use an invalid password so ensure pam_unix failure.
  echo "Using invalid password."
  CRYPTED_PASSWD='*'
fi
# Replace the DEV_USER passwd entry with one that sets the proper shell and
# specifies that the passwd should come from /etc/shadow.
sudo sed -i "{ s|${DEV_USER}:\*:\(.*\):.*|${DEV_USER}:x:\1:${SHELL}| }" \
  "${ROOT_FS_DIR}/etc/passwd"
echo "${DEV_USER}:${CRYPTED_PASSWD}:14500:0:99999::::" \
  | sudo dd of="${ROOT_FS_DIR}/etc/shadow" conv=notrunc oflag=append

# sudo and vt2 are important for system debugging both in developer mode
# and during development.  These two stanzas allow sudo and login auth
# as user chronos under the following conditions:
#
# 1. password-less access:
# - system in developer mode
# - there is no passwd.devmode file
# - there is no system-wide password set above.
# 2. System-wide (/etc/shadow) password access set above:
# - image has a baked in password above
# 3. Developer mode password access
# - user creates a passwd.devmode file with "chronos:CRYPTED_PASSWORD"
# 4. System-wide (/etc/shadow) password access set by modifying /etc/shadow:
# - Cases #1 and #2 will apply but failure will fall through to the
#   inserted password.
#
# TODO(wad) move into ebuilds.
if [ "${CRYPTED_PASSWD}" = '*' ]; then
  # Create a shared auth prefix for the devmode auth case.
  PAM_PREFIX=$(mktemp)
  cat <<EOF > ${PAM_PREFIX}
# If we're not in dev-mode, skip to the system password stack.
auth		[success=ignore default=3] pam_exec.so quiet \\
			/bin/cros_boot_mode -s -m developer
# Check if a custom devmode password file exists and prefer it.
auth		[success=ignore default=1] pam_exec.so quiet \\
			/usr/bin/test -f \\
			  /mnt/stateful_partition/etc/devmode.passwd
# If we get to pwdfile, use it or bypass the password-less login.
auth		[success=done default=1] pam_pwdfile.so \\
			pwdfile /mnt/stateful_partition/etc/devmode.passwd
# If we get here, allow password-less access
auth		sufficient pam_exec.so quiet \\
			/bin/cros_boot_mode -s -m developer
# Fallback to a system password if one was stamped in after initial build.
EOF
  # Prepend the shared code to the sudo and login pam files.
  sudo mv "$ROOT_FS_DIR/etc/pam.d/sudo" "$ROOT_FS_DIR/etc/pam.d/sudo.orig"
  sudo mv "$ROOT_FS_DIR/etc/pam.d/login" "$ROOT_FS_DIR/etc/pam.d/login.orig"
  cat ${PAM_PREFIX} "$ROOT_FS_DIR/etc/pam.d/sudo.orig" |
    sudo dd of="$ROOT_FS_DIR/etc/pam.d/sudo" oflag=append conv=notrunc
  cat ${PAM_PREFIX} "$ROOT_FS_DIR/etc/pam.d/login.orig" |
    sudo dd of="$ROOT_FS_DIR/etc/pam.d/login" oflag=append conv=notrunc
  sudo rm "$ROOT_FS_DIR/etc/pam.d/sudo.orig" \
          "$ROOT_FS_DIR/etc/pam.d/login.orig" \
          ${PAM_PREFIX}
fi

# Symlink /etc/localtime to something on the stateful partition, which we can
# then change around at runtime.
sudo ln -sf /var/lib/timezone/localtime "${ROOT_FS_DIR}/etc/localtime"

# If dash is installed then we want to use that as our default /bin/sh
if [[ -x "${ROOT_FS_DIR}/bin/dash" ]] ; then
  sudo ln -sf dash "${ROOT_FS_DIR}/bin/sh"
fi

# If mawk is installed, awk should symlink to that.
# TODO: Maybe fix this by using a virtual/awk?
if [[ -x "${ROOT_FS_DIR}/usr/bin/mawk" ]] ; then
  sudo ln -sf mawk "${ROOT_FS_DIR}/usr/bin/awk"
fi

# TODO(msb): Ugly Hack fix for pango-querymodules
# pango-querymodules needs to be run on the target so we ran it on the target
# and stored the result which we copy here
CHROMIUMOS_OVERLAY="/usr/local/portage/chromiumos"
sudo cp "${CHROMIUMOS_OVERLAY}/chromeos/files/pango.modules" \
  "${ROOT_FS_DIR}"/etc/pango/
sudo chmod 0644 "${ROOT_FS_DIR}"/etc/pango/pango.modules

# Write stock lsb-release file
# Set CHROMEOS_VERSION_DESCRIPTION here (uses vars set in chromeos_version.sh)
# Was removed from chromeos_version.sh which can also be run outside of chroot
# where CHROMEOS_REVISION is set
if [ ${CHROMEOS_OFFICIAL:-0} = 1 ]; then
  export CHROMEOS_VERSION_DESCRIPTION="${CHROMEOS_VERSION_STRING} (Official Build ${CHROMEOS_REVISION:?}) ${CHROMEOS_VERSION_TRACK%-*} $FLAGS_board test"
elif [ "$USER" = "chrome-bot" ]; then
  export CHROMEOS_VERSION_DESCRIPTION="${CHROMEOS_VERSION_STRING} (Continuous Build ${CHROMEOS_REVISION:?} - Builder: ${BUILDBOT_BUILD:-"N/A"}) $FLAGS_board"
else
  export CHROMEOS_VERSION_DESCRIPTION="${CHROMEOS_VERSION_STRING} (Developer Build ${CHROMEOS_REVISION:?} - $(date) - $USER) ${CHROMEOS_VERSION_TRACK%-*} $FLAGS_board"
fi

# Set google-specific version numbers:
# CHROMEOS_RELEASE_BOARD is the target board identifier.
# CHROMEOS_RELEASE_CODENAME is the codename of the release.
# CHROMEOS_RELEASE_DESCRIPTION is the version displayed by Chrome; see
#   chrome/browser/chromeos/chromeos_version_loader.cc.
# CHROMEOS_RELEASE_NAME is a human readable name for the build.
# CHROMEOS_RELEASE_TRACK and CHROMEOS_RELEASE_VERSION are used by the software
#   update service.
# TODO(skrul):  Remove GOOGLE_RELEASE once Chromium is updated to look at
#   CHROMEOS_RELEASE_VERSION for UserAgent data.
cat <<EOF | sudo dd of="${ROOT_FS_DIR}/etc/lsb-release"
CHROMEOS_RELEASE_APPID=$CHROMEOS_RELEASE_APPID
CHROMEOS_RELEASE_BOARD=$FLAGS_board
CHROMEOS_RELEASE_CODENAME=$CHROMEOS_VERSION_CODENAME
CHROMEOS_RELEASE_DESCRIPTION=$CHROMEOS_VERSION_DESCRIPTION
CHROMEOS_RELEASE_NAME=$CHROMEOS_VERSION_NAME
CHROMEOS_RELEASE_TRACK=$CHROMEOS_VERSION_TRACK
CHROMEOS_RELEASE_VERSION=$CHROMEOS_VERSION_STRING
GOOGLE_RELEASE=$CHROMEOS_VERSION_STRING
CHROMEOS_AUSERVER=$CHROMEOS_VERSION_AUSERVER
CHROMEOS_DEVSERVER=$CHROMEOS_VERSION_DEVSERVER
EOF

# We need to replace /etc/pulse/client.conf and /etc/pulse/default.pa with our
# own versions.
#
# TODO(ajwong): Find a way to override the default pulseaudio config files,
# ideally in an ebuild.
sudo mv "${ROOT_FS_DIR}/etc/pulse/client-cros.conf" \
  "${ROOT_FS_DIR}/etc/pulse/client.conf"
sudo mv "${ROOT_FS_DIR}/etc/pulse/default-cros.pa" \
  "${ROOT_FS_DIR}/etc/pulse/default.pa"

# Run the emulator to generate the font cache. It needs to be copied
# temporarily into the sysroot because we chroot to it. fc-cache
# needs the font files to be located in their final resting place.
case "$FLAGS_target" in
  arm*)
    QEMU="qemu-arm"
    ;;
  *86)
    QEMU="qemu-i386"
    ;;
  *)
    error "Unable to determine ARCH from toolchain: $CHOST"
    exit 1
esac
cp "/usr/bin/${QEMU}" "${ROOT_FS_DIR}/tmp"
sudo mkdir -p "${ROOT_FS_DIR}/usr/share/fontconfig"
sudo chroot "${ROOT_FS_DIR}" "/tmp/${QEMU}" /usr/bin/fc-cache -f
rm "${ROOT_FS_DIR}/tmp/${QEMU}"
