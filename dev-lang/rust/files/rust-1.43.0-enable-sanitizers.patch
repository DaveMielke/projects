Sanitizer runtimes are currently behind the `-Z` flag, which is only available
on nightly builds of the compiler.  We would like to enable fuzzing on chrome
os anyway so move the sanitizer option under `-C` instead since we don't build
the toolchain in nightly mode.

diff --git a/src/librustc_codegen_llvm/attributes.rs b/src/librustc_codegen_llvm/attributes.rs
index a9e4fdba030..df78eaa7a75 100644
--- a/src/librustc_codegen_llvm/attributes.rs
+++ b/src/librustc_codegen_llvm/attributes.rs
@@ -49,7 +49,7 @@ fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {
 /// Apply LLVM sanitize attributes.
 #[inline]
 pub fn sanitize(cx: &CodegenCx<'ll, '_>, codegen_fn_flags: CodegenFnAttrFlags, llfn: &'ll Value) {
-    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {
+    if let Some(ref sanitizer) = cx.tcx.sess.opts.cg.sanitizer {
         match *sanitizer {
             Sanitizer::Address => {
                 if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {
@@ -141,7 +141,7 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {
     // Currently stack probes seem somewhat incompatible with the address
     // sanitizer and thread sanitizer. With asan we're already protected from
     // stack overflow anyway so we don't really need stack probes regardless.
-    match cx.sess().opts.debugging_opts.sanitizer {
+    match cx.sess().opts.cg.sanitizer {
         Some(Sanitizer::Address) | Some(Sanitizer::Thread) => return,
         _ => {}
     }
diff --git a/src/librustc_codegen_llvm/builder.rs b/src/librustc_codegen_llvm/builder.rs
index 32604d5601d..fd6176ed061 100644
--- a/src/librustc_codegen_llvm/builder.rs
+++ b/src/librustc_codegen_llvm/builder.rs
@@ -1244,7 +1244,7 @@ impl Builder<'a, 'll, 'tcx> {
         }
 
         let opts = &self.cx.sess().opts;
-        let emit = match opts.debugging_opts.sanitizer {
+        let emit = match opts.cg.sanitizer {
             // Some sanitizer use lifetime intrinsics. When they are in use,
             // emit lifetime intrinsics regardless of optimization level.
             Some(Sanitizer::Address) | Some(Sanitizer::Memory) => true,
diff --git a/src/librustc_codegen_ssa/back/link.rs b/src/librustc_codegen_ssa/back/link.rs
index 0dd2f029e8d..2ada4518cc7 100644
--- a/src/librustc_codegen_ssa/back/link.rs
+++ b/src/librustc_codegen_ssa/back/link.rs
@@ -507,7 +507,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(
     cmd.args(&sess.opts.debugging_opts.pre_link_arg);
 
     if sess.target.target.options.is_like_fuchsia {
-        let prefix = match sess.opts.debugging_opts.sanitizer {
+        let prefix = match sess.opts.cg.sanitizer {
             Some(Sanitizer::Address) => "asan/",
             _ => "",
         };
@@ -746,7 +746,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(
 }
 
 fn link_sanitizer_runtime(sess: &Session, crate_type: config::CrateType, linker: &mut dyn Linker) {
-    let sanitizer = match &sess.opts.debugging_opts.sanitizer {
+    let sanitizer = match &sess.opts.cg.sanitizer {
         Some(s) => s,
         None => return,
     };
@@ -780,7 +780,11 @@ fn link_sanitizer_runtime(sess: &Session, crate_type: config::CrateType, linker:
             linker.args(&["-Wl,-rpath".into(), "-Xlinker".into(), rpath.into()]);
             linker.link_dylib(Symbol::intern(&libname));
         }
-        "x86_64-unknown-linux-gnu" | "x86_64-fuchsia" | "aarch64-fuchsia" => {
+        "x86_64-unknown-linux-gnu"
+        | "x86_64-fuchsia"
+        | "aarch64-fuchsia"
+        | "x86_64-cros-linux-gnu"
+        | "x86_64-pc-linux-gnu" => {
             let filename = format!("librustc{}_rt.{}.a", channel, name);
             let path = default_tlib.join(&filename);
             linker.link_whole_rlib(&path);
diff --git a/src/librustc_codegen_ssa/back/symbol_export.rs b/src/librustc_codegen_ssa/back/symbol_export.rs
index 3fe256ce25b..1604704ce6d 100644
--- a/src/librustc_codegen_ssa/back/symbol_export.rs
+++ b/src/librustc_codegen_ssa/back/symbol_export.rs
@@ -204,7 +204,7 @@ fn exported_symbols_provider_local(
         }));
     }
 
-    if let Some(Sanitizer::Memory) = tcx.sess.opts.debugging_opts.sanitizer {
+    if let Some(Sanitizer::Memory) = tcx.sess.opts.cg.sanitizer {
         // Similar to profiling, preserve weak msan symbol during LTO.
         const MSAN_WEAK_SYMBOLS: [&str; 2] = ["__msan_track_origins", "__msan_keep_going"];
 
diff --git a/src/librustc_codegen_ssa/back/write.rs b/src/librustc_codegen_ssa/back/write.rs
index 3afa4758253..5d0f7435374 100644
--- a/src/librustc_codegen_ssa/back/write.rs
+++ b/src/librustc_codegen_ssa/back/write.rs
@@ -369,7 +369,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(
 
     modules_config.pgo_gen = sess.opts.cg.profile_generate.clone();
     modules_config.pgo_use = sess.opts.cg.profile_use.clone();
-    modules_config.sanitizer = sess.opts.debugging_opts.sanitizer.clone();
+    modules_config.sanitizer = sess.opts.cg.sanitizer.clone();
     modules_config.sanitizer_recover = sess.opts.debugging_opts.sanitizer_recover.clone();
     modules_config.sanitizer_memory_track_origins =
         sess.opts.debugging_opts.sanitizer_memory_track_origins;
diff --git a/src/librustc_mir/transform/inline.rs b/src/librustc_mir/transform/inline.rs
index b6802505df7..40608fd94ff 100644
--- a/src/librustc_mir/transform/inline.rs
+++ b/src/librustc_mir/transform/inline.rs
@@ -231,7 +231,7 @@ impl Inliner<'tcx> {
 
         // Avoid inlining functions marked as no_sanitize if sanitizer is enabled,
         // since instrumentation might be enabled and performed on the caller.
-        match self.tcx.sess.opts.debugging_opts.sanitizer {
+        match self.tcx.sess.opts.cg.sanitizer {
             Some(Sanitizer::Address) => {
                 if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {
                     return false;
diff --git a/src/librustc_session/config.rs b/src/librustc_session/config.rs
index c273e7fdbf9..1e0f80d9e83 100644
--- a/src/librustc_session/config.rs
+++ b/src/librustc_session/config.rs
@@ -716,7 +716,7 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {
             }
         }
     }
-    if let Some(s) = &sess.opts.debugging_opts.sanitizer {
+    if let Some(s) = &sess.opts.cg.sanitizer {
         let symbol = Symbol::intern(&s.to_string());
         ret.insert((sym::sanitize, Some(symbol)));
     }
diff --git a/src/librustc_session/options.rs b/src/librustc_session/options.rs
index a1ecf4e8528..9cfc99b8ae2 100644
--- a/src/librustc_session/options.rs
+++ b/src/librustc_session/options.rs
@@ -699,6 +699,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,
         "allow the linker to link its default libraries"),
     linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],
                                            "linker flavor"),
+    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],
+                                    "use a sanitizer"),
     linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,
         parse_linker_plugin_lto, [TRACKED],
         "generate build artifacts that are compatible with linker-based LTO."),
@@ -860,8 +862,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,
         "take the breaks off const evaluation. NOTE: this is unsound"),
     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],
         "pass `-install_name @rpath/...` to the macOS linker"),
-    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],
-                                    "use a sanitizer"),
     sanitizer_recover: Vec<Sanitizer> = (vec![], parse_sanitizer_list, [TRACKED],
         "Enable recovery for selected sanitizers"),
     sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],
diff --git a/src/librustc_session/session.rs b/src/librustc_session/session.rs
index 173b120e1f6..62a4389f167 100644
--- a/src/librustc_session/session.rs
+++ b/src/librustc_session/session.rs
@@ -520,7 +520,7 @@ impl Session {
             || self.opts.output_types.contains_key(&OutputType::Bitcode);
 
         // Address sanitizer and memory sanitizer use alloca name when reporting an issue.
-        let more_names = match self.opts.debugging_opts.sanitizer {
+        let more_names = match self.opts.cg.sanitizer {
             Some(Sanitizer::Address) => true,
             Some(Sanitizer::Memory) => true,
             _ => more_names,
@@ -1136,18 +1136,32 @@ fn validate_commandline_args_with_session_available(sess: &Session) {
     }
 
     // Sanitizers can only be used on some tested platforms.
-    if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {
+    if let Some(ref sanitizer) = sess.opts.cg.sanitizer {
         const ASAN_SUPPORTED_TARGETS: &[&str] = &[
             "x86_64-unknown-linux-gnu",
+            "x86_64-cros-linux-gnu",
+            "x86_64-pc-linux-gnu",
             "x86_64-apple-darwin",
             "x86_64-fuchsia",
             "aarch64-fuchsia",
         ];
-        const TSAN_SUPPORTED_TARGETS: &[&str] =
-            &["x86_64-unknown-linux-gnu", "x86_64-apple-darwin"];
-        const LSAN_SUPPORTED_TARGETS: &[&str] =
-            &["x86_64-unknown-linux-gnu", "x86_64-apple-darwin"];
-        const MSAN_SUPPORTED_TARGETS: &[&str] = &["x86_64-unknown-linux-gnu"];
+        const TSAN_SUPPORTED_TARGETS: &[&str] = &[
+            "x86_64-unknown-linux-gnu",
+            "x86_64-cros-linux-gnu",
+            "x86_64-pc-linux-gnu",
+            "x86_64-apple-darwin",
+        ];
+        const LSAN_SUPPORTED_TARGETS: &[&str] = &[
+            "x86_64-unknown-linux-gnu",
+            "x86_64-cros-linux-gnu",
+            "x86_64-pc-linux-gnu",
+            "x86_64-apple-darwin",
+        ];
+        const MSAN_SUPPORTED_TARGETS: &[&str] = &[
+            "x86_64-unknown-linux-gnu",
+            "x86_64-cros-linux-gnu",
+            "x86_64-pc-linux-gnu",
+        ];
 
         let supported_targets = match *sanitizer {
             Sanitizer::Address => ASAN_SUPPORTED_TARGETS,
