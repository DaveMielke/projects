From 4273dccb686b75cd07a0cc07fea4470a6523f462 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Degros?= <fdegros@chromium.org>
Date: Sat, 11 Jul 2020 19:19:54 +1000
Subject: [PATCH] Take password by environment variable

If no password is provided through the PASSWORD environment variable and
the ZIP contains encrypted files, then the ZIP is not mounted.

If a non-empty password is provided, it is used to decrypt encrypted
files. The password itself is checked for validity when the ZIP is
mounted. If the password does not allow to decrypt the first encrypted
file encountered in the ZIP, then the ZIP is not mounted. Multipassword
ZIPs containing files encrypted with different passwords are thus not
supported.

If an empty password is provided, no validation is performed and the ZIP
is mounted even if it contains encrypted files. Consequently, trying to
open encrypted files in the mounted ZIP will report an error.
---
 lib/fuseZipData.cpp | 43 +++++++++++++++++++++++++++++++++++++++----
 1 file changed, 39 insertions(+), 4 deletions(-)

diff --git a/lib/fuseZipData.cpp b/lib/fuseZipData.cpp
index 52acdff..79ba292 100644
--- a/lib/fuseZipData.cpp
+++ b/lib/fuseZipData.cpp
@@ -65,30 +65,65 @@ void FuseZipData::build_tree(bool readonly) {
     }
     m_root->parent = NULL;
     files[m_root->full_name.c_str()] = m_root;
-    zip_int64_t n = zip_get_num_entries(m_zip, 0);
+
+    // Skip password check if it is an empty string.
+    // See https://github.com/nih-at/libzip/issues/204
+    const char *const password = getenv("PASSWORD");
+    bool checked_password = password && password[0] == '\0';
+    if (!checked_password && zip_set_default_password(m_zip, password) < 0)
+        throw ZipError("Cannot set default password", m_zip);
+
+    const zip_int64_t n = zip_get_num_entries(m_zip, 0);
+
     // search for absolute or parent-relative paths
     bool needPrefix = false;
     if (readonly) {
         for (zip_int64_t i = 0; i < n; ++i) {
-            const char *name = zip_get_name(m_zip, static_cast<zip_uint64_t>(i), ZIP_FL_ENC_GUESS);
+            const char * const name = zip_get_name(m_zip, static_cast<zip_uint64_t>(i), ZIP_FL_ENC_GUESS);
+            if (!name)
+                throw ZipError("Cannot get file name", m_zip);
+
             if ((name[0] == '/') || (strncmp(name, "../", 3) == 0)) {
                 needPrefix = true;
+                break;
             }
         }
     }
+
+    zip_stat_t sb;
+
     // add zip entries for all items except hardlinks
     filemap_t origNames;
     for (zip_int64_t i = 0; i < n; ++i) {
         zip_uint64_t id = static_cast<zip_uint64_t>(i);
+        if (zip_stat_index(m_zip, id, ZIP_FL_ENC_GUESS, &sb) < 0)
+            throw ZipError("Cannot read file entry", m_zip);
+
+        if ((sb.valid & ZIP_STAT_NAME) == 0)
+            continue;
+
+        const char *const name = sb.name;
+
         bool isHardlink;
-        const char *name = zip_get_name(m_zip, id, ZIP_FL_ENC_GUESS);
         mode_t mode = getEntryAttributes(id, name, isHardlink);
-        
+
         if (isHardlink)
             continue;
 
+        // Try to open the first encrypted file in order to check the password.
+        if (!checked_password && (sb.valid & ZIP_STAT_ENCRYPTION_METHOD) != 0 &&
+            sb.encryption_method != ZIP_EM_NONE) {
+            const ZipFile file(zip_fopen_index(m_zip, id, 0));
+            if (!file)
+                throw ZipError("Cannot decrypt file", m_zip);
+
+            // Password is Ok.
+            checked_password = true;
+        }
+
         attachNode(i, name, mode, readonly, needPrefix, origNames);
     }
+
     // add hardlinks
     for (zip_int64_t i = 0; i < n; ++i) {
         zip_uint64_t id = static_cast<zip_uint64_t>(i);
-- 
2.28.0.236.gb10cc79966-goog

