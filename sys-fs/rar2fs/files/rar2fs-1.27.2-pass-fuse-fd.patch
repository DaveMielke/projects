From 59eaa58f8d005f5e7cf4c82f3a04fcb84f710d60 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Degros?= <fdegros@chromium.org>
Date: Mon, 21 Oct 2019 10:40:30 +1100
Subject: [PATCH] Accept pre-mounted FUSE descriptor

---
 rar2fs.c | 69 ++++++++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 55 insertions(+), 14 deletions(-)

diff --git a/rar2fs.c b/rar2fs.c
index 0831a3d..3355e28 100644
--- a/rar2fs.c
+++ b/rar2fs.c
@@ -4834,6 +4834,22 @@ static int64_t get_blkdev_size(struct stat *st)
 #endif
 }
 
+/*!
+ *****************************************************************************
+ *
+ ****************************************************************************/
+static int parse_fuse_fd(const char *mountpoint)
+{
+        int fd = -1;
+        unsigned int len = 0;
+
+        if (sscanf(mountpoint, "/dev/fd/%u%n", &fd, &len) == 1 && len == strlen(mountpoint)) {
+                return fd;
+        }
+
+        return -1;
+}
+
 /*!
  *****************************************************************************
  *
@@ -4841,19 +4857,54 @@ static int64_t get_blkdev_size(struct stat *st)
 static int check_paths(const char *prog, char *src_path_in, char *dst_path_in,
                 char **src_path_out, char **dst_path_out, int verbose)
 {
+        struct stat st;
+
         char *a1 = realpath(src_path_in, NULL);
+
+        if (!a1) {
+                if (verbose)
+                        printf("%s: invalid source: %s\n", prog, src_path_in);
+                return -1;
+        }
+
 #ifdef __CYGWIN__
         char *a2 = dst_path_in;
 #else
-        char *a2 = realpath(dst_path_in, NULL);
+        char *a2;
+
+        /* Check if destination path is a pre-mounted FUSE descriptor. */
+        const int fuse_fd = parse_fuse_fd(dst_path_in);
+        if (fuse_fd >= 0) {
+                if (verbose)
+                        printf("%s: using pre-mounted FUSE descriptor %u\n", prog, fuse_fd);
+                a2 = strdup(dst_path_in);
+        } else {
+                a2 = realpath(dst_path_in, NULL);
+
+                if (!a2) {
+                        if (verbose)
+                                printf("%s: invalid mount point: %s\n", prog, dst_path_in);
+                        return -1;
+                }
+
+                /* Check if destination path is a folder. */
+                (void)stat(a2, &st);
+                if (!S_ISDIR(st.st_mode)) {
+                        if (verbose)
+                                printf("%s: mount point '%s' should be a directory but has mode %o\n", prog, a2,
+                                       st.st_mode);
+                        return -1;
+                }
+        }
 #endif
-        if (!a1 || !a2 || !strcmp(a1, a2)) {
+
+        if (!strcmp(a1, a2)) {
                 if (verbose)
-                        printf("%s: invalid source and/or mount point\n", prog);
+                        printf("%s: source and mount point are the same: %s\n", prog, a1);
                 return -1;
         }
+
         dir_list_open(arch_list);
-        struct stat st;
         (void)stat(a1, &st);
         mount_type = S_ISDIR(st.st_mode) ? MOUNT_FOLDER : MOUNT_ARCHIVE;
 
@@ -4861,16 +4912,6 @@ static int check_paths(const char *prog, char *src_path_in, char *dst_path_in,
         if (mount_type == MOUNT_ARCHIVE && S_ISBLK(st.st_mode))
                 blkdev_size = get_blkdev_size(&st);
 
-#ifndef __CYGWIN__
-        /* Check path type(s), destination path *must* be a folder */
-        (void)stat(a2, &st);
-        if (!S_ISDIR(st.st_mode)) {
-                if (verbose)
-                        printf("%s: invalid source and/or mount point\n", prog);
-                return -1;
-        }
-#endif
-
         /* Check file collection at archive mount */
         if (mount_type == MOUNT_ARCHIVE) {
                 int ret = collect_files(a1, arch_list);
-- 
2.24.0.rc1.363.gb1bccd3e3d-goog

