From c27389d39d47907c0e3eb77c996c95496d6ec844 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Degros?= <fdegros@chromium.org>
Date: Mon, 21 Oct 2019 10:40:30 +1100
Subject: [PATCH] Improve error reporting

Errors generated in collect_files() are correctly logged and reported all the
way up. This facilitates debugging and error diagnostic.
---
 rar2fs.c | 76 +++++++++++++++++++++++++++++++++++++++++++-------------
 1 file changed, 59 insertions(+), 17 deletions(-)

diff --git a/rar2fs.c b/rar2fs.c
index 873fd6c..8c515fc 100644
--- a/rar2fs.c
+++ b/rar2fs.c
@@ -1782,7 +1782,13 @@ static void dump_stat(struct stat *stbuf)
 
 /*!
  *****************************************************************************
+ * Checks if archive file |arch| is part of a multipart archive.
+ * Identifies all the files that are part of the same multipart archive and
+ * located in the same directory as |arch| and stores their paths in |*list|.
  *
+ * Returns the number of files making the multipart archive.
+ * Returns 1 if |arch| is not part of a multipart archive.
+ * Returns a negative ERAR error code in case of error.
  ****************************************************************************/
 static int collect_files(const char *arch, struct dir_entry_list *list)
 {
@@ -1798,12 +1804,12 @@ static int collect_files(const char *arch, struct dir_entry_list *list)
         h = RAROpenArchiveEx(&d);
 
         /* Check for fault */
-        if (d.OpenResult) {
+        const int err = d.OpenResult;
+        if (err != ERAR_SUCCESS) {
                 if (h)
                         RARCloseArchive(h);
-                if (d.OpenResult == ERAR_MISSING_PASSWORD)
-			files = -EPERM;
-                goto out;
+
+                return -err;
         }
 
         if (d.Flags & ROADF_VOLUME) {
@@ -1825,7 +1831,6 @@ static int collect_files(const char *arch, struct dir_entry_list *list)
                 files = 1;
         }
 
-out:
         return files;
 }
 
@@ -4850,6 +4855,39 @@ static int parse_fuse_fd(const char *mountpoint)
         return -1;
 }
 
+/*!
+ *****************************************************************************
+ * Converts the given ERAR error code into a matching string.
+ * The returned string is statically allocated and does not need to be freed.
+ ****************************************************************************/
+static const char *error_to_string(int err)
+{
+        switch (err) {
+#define ERROR_TO_STRING_ENTRY(s) \
+        case s:                  \
+                return #s;
+                ERROR_TO_STRING_ENTRY(ERAR_SUCCESS);
+                ERROR_TO_STRING_ENTRY(ERAR_END_ARCHIVE);
+                ERROR_TO_STRING_ENTRY(ERAR_NO_MEMORY);
+                ERROR_TO_STRING_ENTRY(ERAR_BAD_DATA);
+                ERROR_TO_STRING_ENTRY(ERAR_BAD_ARCHIVE);
+                ERROR_TO_STRING_ENTRY(ERAR_UNKNOWN_FORMAT);
+                ERROR_TO_STRING_ENTRY(ERAR_EOPEN);
+                ERROR_TO_STRING_ENTRY(ERAR_ECREATE);
+                ERROR_TO_STRING_ENTRY(ERAR_ECLOSE);
+                ERROR_TO_STRING_ENTRY(ERAR_EREAD);
+                ERROR_TO_STRING_ENTRY(ERAR_EWRITE);
+                ERROR_TO_STRING_ENTRY(ERAR_SMALL_BUF);
+                ERROR_TO_STRING_ENTRY(ERAR_UNKNOWN);
+                ERROR_TO_STRING_ENTRY(ERAR_MISSING_PASSWORD);
+                ERROR_TO_STRING_ENTRY(ERAR_EREFERENCE);
+                ERROR_TO_STRING_ENTRY(ERAR_BAD_PASSWORD);
+#undef ERROR_TO_STRING_ENTRY
+        }
+
+        return "Unexpected ERAR code";
+}
+
 /*!
  *****************************************************************************
  *
@@ -4915,15 +4953,18 @@ static int check_paths(const char *prog, char *src_path_in, char *dst_path_in,
         /* Check file collection at archive mount */
         if (mount_type == MOUNT_ARCHIVE) {
                 int ret = collect_files(a1, arch_list);
-                if (ret == -EPERM) {
+                if (ret < 0) {
+                        const int err = -ret;
                         if (verbose)
-                                printf("%s: bad or missing password\n", prog);
-                        return -1;
-                } else if (ret <= 0) {
+                                printf("%s: cannot open '%s': %s\n", prog, a1,
+                                       error_to_string(err));
+                        return err;
+                } else if (ret == 0) {
                         if (verbose)
-                                printf("%s: invalid source and/or mount point\n",
-                                                prog);
-                        return -1;
+                                printf(
+                                    "%s: cannot find primary file for multipart archive '%s'\n",
+                                    prog, a1);
+                        return 1;
                 }
         }
 
@@ -5501,11 +5542,12 @@ int main(int argc, char *argv[])
         if (OPT_SET(OPT_KEY_SRC) && OPT_SET(OPT_KEY_DST)) {
                 char *dst_path = NULL;
                 char *src_path = NULL;
-                if (check_paths(argv[0],
-                                OPT_STR(OPT_KEY_SRC, 0),
-                                OPT_STR(OPT_KEY_DST, 0),
-                                &src_path, &dst_path, 1))
-                        return -1;
+                const int err = check_paths(argv[0],
+                                            OPT_STR(OPT_KEY_SRC, 0),
+                                            OPT_STR(OPT_KEY_DST, 0),
+                                            &src_path, &dst_path, 1);
+                if (err)
+                        return err;
 
                 optdb_save(OPT_KEY_SRC, src_path);
                 optdb_save(OPT_KEY_DST, dst_path);
-- 
2.25.0.265.gbab2e86ba0-goog

