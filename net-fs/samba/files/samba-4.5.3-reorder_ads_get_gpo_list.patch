Changes order to match GPO application order.

The order of GPOs in a gpo_list generated by ads_get_gpo_list did not
match the order of application. Since GPOs are pushed to the FRONT of
gpo_list, GPOs have to be pushed in the opposite order of application.
(Pushing to front is useful to get inheritance blocking right).

crbug.com/710434.

jra@ has reviewed the content of the patches for sanity.
We will remove these patches once they are upstream.

diff --git a/libgpo/gpo_ldap.c b/libgpo/gpo_ldap.c
index 4533d61a1e3..adc578b7d0e 100644
--- a/libgpo/gpo_ldap.c
+++ b/libgpo/gpo_ldap.c
@@ -563,7 +563,9 @@ static ADS_STATUS add_gplink_to_gpo_list(ADS_STRUCT *ads,
 	ADS_STATUS status;
 	int i;

-	for (i = 0; i < gp_link->num_links; i++) {
+  /* Note: DLIST_ADD pushes front, so loop from last to first to get the
+     order right. */
+	for (i = (int)gp_link->num_links - 1; i >= 0; i--) {

 		struct GROUP_POLICY_OBJECT *new_gpo = NULL;

@@ -726,7 +728,13 @@ ADS_STATUS ads_get_gpo_list(ADS_STRUCT *ads,
 			    const struct security_token *token,
 			    struct GROUP_POLICY_OBJECT **gpo_list)
 {
-	/* (L)ocal (S)ite (D)omain (O)rganizational(U)nit */
+  /* Push GPOs to gpo_list so that the traversal order of the list matches
+     the order of application:
+       (L)ocal (S)ite (D)omain (O)rganizational(U)nit
+       Within domains and OUs: parent-to-child.
+     Since GPOs are pushed to the front of gpo_list, GPOs have to be pushed
+     in the opposite order of application (OUs first, local last,
+     child-to-parent). */

 	ADS_STATUS status;
 	struct GP_LINK gp_link;
@@ -745,63 +753,18 @@ ADS_STATUS ads_get_gpo_list(ADS_STRUCT *ads,

 	DEBUG(10,("ads_get_gpo_list: getting GPO list for [%s]\n", dn));

-	/* (L)ocal */
-	status = add_local_policy_to_gpo_list(mem_ctx, gpo_list,
-					      GP_LINK_LOCAL);
-	if (!ADS_ERR_OK(status)) {
-		return status;
-	}
-
-	/* (S)ite */
-
-	/* are site GPOs valid for users as well ??? */
-	if (flags & GPO_LIST_FLAG_MACHINE) {
-
-		status = ads_site_dn_for_machine(ads, mem_ctx,
-						 ads->config.ldap_server_name,
-						 &site_dn);
-		if (!ADS_ERR_OK(status)) {
-			return status;
-		}
-
-		DEBUG(10,("ads_get_gpo_list: query SITE: [%s] for GPOs\n",
-			site_dn));
-
-		status = ads_get_gpo_link(ads, mem_ctx, site_dn, &gp_link);
-		if (ADS_ERR_OK(status)) {
-
-			if (DEBUGLEVEL >= 100) {
-				dump_gplink(&gp_link);
-			}
-
-			status = add_gplink_to_gpo_list(ads, mem_ctx, gpo_list,
-							site_dn, &gp_link,
-							GP_LINK_SITE,
-							add_only_forced_gpos,
-							token);
-			if (!ADS_ERR_OK(status)) {
-				return status;
-			}
-
-			if (flags & GPO_LIST_FLAG_SITEONLY) {
-				return ADS_ERROR(LDAP_SUCCESS);
-			}
-
-			/* inheritance can't be blocked at the site level */
-		}
-	}
-
 	tmp_dn = dn;

 	while ((parent_dn = ads_parent_dn(tmp_dn)) &&
 	       (!strequal(parent_dn, ads_parent_dn(ads->config.bind_path)))) {

-		/* (D)omain */

-		/* An account can just be a member of one domain */
-		if (strncmp(parent_dn, "DC=", strlen("DC=")) == 0) {
+		/* (O)rganizational(U)nit */

-			DEBUG(10,("ads_get_gpo_list: query DC: [%s] for GPOs\n",
+		/* An account can be a member of more OUs */
+		if (strncmp(parent_dn, "OU=", strlen("OU=")) == 0) {
+
+			DEBUG(10,("ads_get_gpo_list: query OU: [%s] for GPOs\n",
 				parent_dn));

 			status = ads_get_gpo_link(ads, mem_ctx, parent_dn,
@@ -823,7 +786,7 @@ ADS_STATUS ads_get_gpo_list(ADS_STRUCT *ads,
 							gpo_list,
 							parent_dn,
 							&gp_link,
-							GP_LINK_DOMAIN,
+							GP_LINK_OU,
 							add_only_forced_gpos,
 							token);
 				if (!ADS_ERR_OK(status)) {
@@ -833,7 +796,8 @@ ADS_STATUS ads_get_gpo_list(ADS_STRUCT *ads,
 		}

 		tmp_dn = parent_dn;
-	}
+
+	};

 	/* reset dn again */
 	tmp_dn = dn;
@@ -841,13 +805,12 @@ ADS_STATUS ads_get_gpo_list(ADS_STRUCT *ads,
 	while ((parent_dn = ads_parent_dn(tmp_dn)) &&
 	       (!strequal(parent_dn, ads_parent_dn(ads->config.bind_path)))) {

+		/* (D)omain */

-		/* (O)rganizational(U)nit */
-
-		/* An account can be a member of more OUs */
-		if (strncmp(parent_dn, "OU=", strlen("OU=")) == 0) {
+		/* An account can just be a member of one domain */
+		if (strncmp(parent_dn, "DC=", strlen("DC=")) == 0) {

-			DEBUG(10,("ads_get_gpo_list: query OU: [%s] for GPOs\n",
+			DEBUG(10,("ads_get_gpo_list: query DC: [%s] for GPOs\n",
 				parent_dn));

 			status = ads_get_gpo_link(ads, mem_ctx, parent_dn,
@@ -869,7 +832,7 @@ ADS_STATUS ads_get_gpo_list(ADS_STRUCT *ads,
 							gpo_list,
 							parent_dn,
 							&gp_link,
-							GP_LINK_OU,
+							GP_LINK_DOMAIN,
 							add_only_forced_gpos,
 							token);
 				if (!ADS_ERR_OK(status)) {
@@ -879,8 +842,53 @@ ADS_STATUS ads_get_gpo_list(ADS_STRUCT *ads,
 		}

 		tmp_dn = parent_dn;
+	}

-	};
+	/* (S)ite */
+
+	/* are site GPOs valid for users as well ??? */
+	if (flags & GPO_LIST_FLAG_MACHINE) {
+
+		status = ads_site_dn_for_machine(ads, mem_ctx,
+						 ads->config.ldap_server_name,
+						 &site_dn);
+		if (!ADS_ERR_OK(status)) {
+			return status;
+		}
+
+		DEBUG(10,("ads_get_gpo_list: query SITE: [%s] for GPOs\n",
+			site_dn));
+
+		status = ads_get_gpo_link(ads, mem_ctx, site_dn, &gp_link);
+		if (ADS_ERR_OK(status)) {
+
+			if (DEBUGLEVEL >= 100) {
+				dump_gplink(&gp_link);
+			}
+
+			status = add_gplink_to_gpo_list(ads, mem_ctx, gpo_list,
+							site_dn, &gp_link,
+							GP_LINK_SITE,
+							add_only_forced_gpos,
+							token);
+			if (!ADS_ERR_OK(status)) {
+				return status;
+			}
+
+			if (flags & GPO_LIST_FLAG_SITEONLY) {
+				return ADS_ERROR(LDAP_SUCCESS);
+			}
+
+			/* inheritance can't be blocked at the site level */
+		}
+	}
+
+	/* (L)ocal */
+	status = add_local_policy_to_gpo_list(mem_ctx, gpo_list,
+					      GP_LINK_LOCAL);
+	if (!ADS_ERR_OK(status)) {
+		return status;
+	}

 	return ADS_ERROR(LDAP_SUCCESS);
 }
