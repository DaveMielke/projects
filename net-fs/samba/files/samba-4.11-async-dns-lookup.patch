From 8e68939e8c637cd1e8276e02b8e9df8954c86a72 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 10 Jul 2020 15:09:33 -0700
Subject: [PATCH 01/60] s4: torture: Add smb2.notify.handle-permissions test.

Add knownfail entry.

CVE-2020-14318

BUG: https://bugzilla.samba.org/show_bug.cgi?id=14434

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 .../smb2_notify_handle_permissions            |  2 +
 source4/torture/smb2/notify.c                 | 80 +++++++++++++++++++
 2 files changed, 82 insertions(+)
 create mode 100644 selftest/knownfail.d/smb2_notify_handle_permissions

diff --git a/selftest/knownfail.d/smb2_notify_handle_permissions b/selftest/knownfail.d/smb2_notify_handle_permissions
new file mode 100644
index 00000000000..c0ec8fc8153
--- /dev/null
+++ b/selftest/knownfail.d/smb2_notify_handle_permissions
@@ -0,0 +1,2 @@
+^samba3.smb2.notify.handle-permissions
+
diff --git a/source4/torture/smb2/notify.c b/source4/torture/smb2/notify.c
index d8aa44f5d4c..8894ed94c5c 100644
--- a/source4/torture/smb2/notify.c
+++ b/source4/torture/smb2/notify.c
@@ -2649,6 +2649,83 @@ done:
 	return ok;
 }
 
+/*
+  Test asking for a change notify on a handle without permissions.
+*/
+
+#define BASEDIR_HPERM BASEDIR "_HPERM"
+
+static bool torture_smb2_notify_handle_permissions(
+		struct torture_context *torture,
+		struct smb2_tree *tree)
+{
+	bool ret = true;
+	NTSTATUS status;
+	union smb_notify notify;
+	union smb_open io;
+	struct smb2_handle h1 = {{0}};
+	struct smb2_request *req;
+
+	smb2_deltree(tree, BASEDIR_HPERM);
+	smb2_util_rmdir(tree, BASEDIR_HPERM);
+
+	torture_comment(torture,
+		"TESTING CHANGE NOTIFY "
+		"ON A HANDLE WITHOUT PERMISSIONS\n");
+
+	/*
+	  get a handle on the directory
+	*/
+	ZERO_STRUCT(io.smb2);
+	io.generic.level = RAW_OPEN_SMB2;
+	io.smb2.in.create_flags = 0;
+	io.smb2.in.desired_access = SEC_FILE_READ_ATTRIBUTE;
+	io.smb2.in.create_options = NTCREATEX_OPTIONS_DIRECTORY;
+	io.smb2.in.file_attributes = FILE_ATTRIBUTE_NORMAL;
+	io.smb2.in.share_access = NTCREATEX_SHARE_ACCESS_READ |
+				NTCREATEX_SHARE_ACCESS_WRITE;
+	io.smb2.in.alloc_size = 0;
+	io.smb2.in.create_disposition = NTCREATEX_DISP_CREATE;
+	io.smb2.in.impersonation_level = SMB2_IMPERSONATION_ANONYMOUS;
+	io.smb2.in.security_flags = 0;
+	io.smb2.in.fname = BASEDIR_HPERM;
+
+	status = smb2_create(tree, torture, &io.smb2);
+	CHECK_STATUS(status, NT_STATUS_OK);
+	h1 = io.smb2.out.file.handle;
+
+	/* ask for a change notify,
+	   on file or directory name changes */
+	ZERO_STRUCT(notify.smb2);
+	notify.smb2.level = RAW_NOTIFY_SMB2;
+	notify.smb2.in.buffer_size = 1000;
+	notify.smb2.in.completion_filter = FILE_NOTIFY_CHANGE_NAME;
+	notify.smb2.in.file.handle = h1;
+	notify.smb2.in.recursive = true;
+
+	req = smb2_notify_send(tree, &notify.smb2);
+	torture_assert_goto(torture,
+			req != NULL,
+			ret,
+			done,
+			"smb2_notify_send failed\n");
+
+	/*
+	 * Cancel it, we don't really want to wait.
+	 */
+	smb2_cancel(req);
+	status = smb2_notify_recv(req, torture, &notify.smb2);
+	/* Handle h1 doesn't have permissions for ChangeNotify. */
+	CHECK_STATUS(status, NT_STATUS_ACCESS_DENIED);
+
+done:
+	if (!smb2_util_handle_empty(h1)) {
+		smb2_util_close(tree, h1);
+	}
+	smb2_deltree(tree, BASEDIR_TD);
+	return ret;
+}
+
 /*
    basic testing of SMB2 change notify
 */
@@ -2682,6 +2759,9 @@ struct torture_suite *torture_smb2_notify_init(TALLOC_CTX *ctx)
 				     torture_smb2_notify_rmdir3);
 	torture_suite_add_2smb2_test(suite, "rmdir4",
 				     torture_smb2_notify_rmdir4);
+	torture_suite_add_1smb2_test(suite,
+				    "handle-permissions",
+				    torture_smb2_notify_handle_permissions);
 
 	suite->description = talloc_strdup(suite, "SMB2-NOTIFY tests");
 
-- 
2.20.1


From e567a1230cb5126655f7f42dfa5113df0da94f06 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 7 Jul 2020 18:25:23 -0700
Subject: [PATCH 02/60] s3: smbd: Ensure change notifies can't get set unless
 the directory handle is open for SEC_DIR_LIST.

Remove knownfail entry.

CVE-2020-14318

BUG: https://bugzilla.samba.org/show_bug.cgi?id=14434

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 selftest/knownfail.d/smb2_notify_handle_permissions | 2 --
 source3/smbd/notify.c                               | 8 ++++++++
 2 files changed, 8 insertions(+), 2 deletions(-)
 delete mode 100644 selftest/knownfail.d/smb2_notify_handle_permissions

diff --git a/selftest/knownfail.d/smb2_notify_handle_permissions b/selftest/knownfail.d/smb2_notify_handle_permissions
deleted file mode 100644
index c0ec8fc8153..00000000000
--- a/selftest/knownfail.d/smb2_notify_handle_permissions
+++ /dev/null
@@ -1,2 +0,0 @@
-^samba3.smb2.notify.handle-permissions
-
diff --git a/source3/smbd/notify.c b/source3/smbd/notify.c
index b36a4c0003a..68553686fa2 100644
--- a/source3/smbd/notify.c
+++ b/source3/smbd/notify.c
@@ -289,6 +289,14 @@ NTSTATUS change_notify_create(struct files_struct *fsp,
 	char fullpath[len+1];
 	NTSTATUS status = NT_STATUS_NOT_IMPLEMENTED;
 
+	/*
+	 * Setting a changenotify needs READ/LIST access
+	 * on the directory handle.
+	 */
+	if (!(fsp->access_mask & SEC_DIR_LIST)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	if (fsp->notify != NULL) {
 		DEBUG(1, ("change_notify_create: fsp->notify != NULL, "
 			  "fname = %s\n", fsp->fsp_name->base_name));
-- 
2.20.1


From 9cb2ade634d67533e388547fff2af00a25396dd1 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 11:43:03 -0700
Subject: [PATCH 03/60] s3: lib: Cleanup - all the ipstr_XXX() functions are
 only used in namecache.c.

Move them there. Will remove from the global namespace next.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/lib/util_str.c     | 166 -------------------------------------
 source3/libsmb/namecache.c | 164 ++++++++++++++++++++++++++++++++++++
 2 files changed, 164 insertions(+), 166 deletions(-)

diff --git a/source3/lib/util_str.c b/source3/lib/util_str.c
index e660e295c33..e43f178af29 100644
--- a/source3/lib/util_str.c
+++ b/source3/lib/util_str.c
@@ -643,172 +643,6 @@ bool str_list_substitute(char **list, const char *pattern, const char *insert)
 	return true;
 }
 
-
-#define IPSTR_LIST_SEP	","
-#define IPSTR_LIST_CHAR	','
-
-/**
- * Add ip string representation to ipstr list. Used also
- * as part of @function ipstr_list_make
- *
- * @param ipstr_list pointer to string containing ip list;
- *        MUST BE already allocated and IS reallocated if necessary
- * @param ipstr_size pointer to current size of ipstr_list (might be changed
- *        as a result of reallocation)
- * @param ip IP address which is to be added to list
- * @return pointer to string appended with new ip and possibly
- *         reallocated to new length
- **/
-
-static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
-{
-	char *new_ipstr = NULL;
-	char addr_buf[INET6_ADDRSTRLEN];
-	int ret;
-
-	/* arguments checking */
-	if (!ipstr_list || !service) {
-		return NULL;
-	}
-
-	print_sockaddr(addr_buf,
-			sizeof(addr_buf),
-			&service->ss);
-
-	/* attempt to convert ip to a string and append colon separator to it */
-	if (*ipstr_list) {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s%s%s:%d",	*ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "%s%s[%s]:%d", *ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		}
-		SAFE_FREE(*ipstr_list);
-	} else {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s:%d", addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "[%s]:%d", addr_buf,
-				       service->port);
-		}
-	}
-	if (ret == -1) {
-		return NULL;
-	}
-	*ipstr_list = new_ipstr;
-	return *ipstr_list;
-}
-
-/**
- * Allocate and initialise an ipstr list using ip adresses
- * passed as arguments.
- *
- * @param ipstr_list pointer to string meant to be allocated and set
- * @param ip_list array of ip addresses to place in the list
- * @param ip_count number of addresses stored in ip_list
- * @return pointer to allocated ip string
- **/
-
-char *ipstr_list_make(char **ipstr_list,
-			const struct ip_service *ip_list,
-			int ip_count)
-{
-	int i;
-
-	/* arguments checking */
-	if (!ip_list || !ipstr_list) {
-		return 0;
-	}
-
-	*ipstr_list = NULL;
-
-	/* process ip addresses given as arguments */
-	for (i = 0; i < ip_count; i++) {
-		*ipstr_list = ipstr_list_add(ipstr_list, &ip_list[i]);
-	}
-
-	return (*ipstr_list);
-}
-
-
-/**
- * Parse given ip string list into array of ip addresses
- * (as ip_service structures)
- *    e.g. [IPv6]:port,192.168.1.100:389,192.168.1.78, ...
- *
- * @param ipstr ip string list to be parsed
- * @param ip_list pointer to array of ip addresses which is
- *        allocated by this function and must be freed by caller
- * @return number of successfully parsed addresses
- **/
-
-int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
-{
-	TALLOC_CTX *frame;
-	char *token_str = NULL;
-	size_t count;
-	int i;
-
-	if (!ipstr_list || !ip_list)
-		return 0;
-
-	count = count_chars(ipstr_list, IPSTR_LIST_CHAR) + 1;
-	if ( (*ip_list = SMB_MALLOC_ARRAY(struct ip_service, count)) == NULL ) {
-		DEBUG(0,("ipstr_list_parse: malloc failed for %lu entries\n",
-					(unsigned long)count));
-		return 0;
-	}
-
-	frame = talloc_stackframe();
-	for ( i=0; next_token_talloc(frame, &ipstr_list, &token_str,
-				IPSTR_LIST_SEP) && i<count; i++ ) {
-		char *s = token_str;
-		char *p = strrchr(token_str, ':');
-
-		if (p) {
-			*p = 0;
-			(*ip_list)[i].port = atoi(p+1);
-		}
-
-		/* convert single token to ip address */
-		if (token_str[0] == '[') {
-			/* IPv6 address. */
-			s++;
-			p = strchr(token_str, ']');
-			if (!p) {
-				continue;
-			}
-			*p = '\0';
-		}
-		if (!interpret_string_addr(&(*ip_list)[i].ss,
-					s,
-					AI_NUMERICHOST)) {
-			continue;
-		}
-	}
-	TALLOC_FREE(frame);
-	return count;
-}
-
-/**
- * Safely free ip string list
- *
- * @param ipstr_list ip string list to be freed
- **/
-
-void ipstr_list_free(char* ipstr_list)
-{
-	SAFE_FREE(ipstr_list);
-}
-
 /* read a SMB_BIG_UINT from a string */
 uint64_t STR_TO_SMB_BIG_UINT(const char *nptr, const char **entptr)
 {
diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 082f256bc02..8fc65675db9 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -24,6 +24,170 @@
 #include "includes.h"
 #include "lib/gencache.h"
 
+#define IPSTR_LIST_SEP	","
+#define IPSTR_LIST_CHAR	','
+
+/**
+ * Add ip string representation to ipstr list. Used also
+ * as part of @function ipstr_list_make
+ *
+ * @param ipstr_list pointer to string containing ip list;
+ *        MUST BE already allocated and IS reallocated if necessary
+ * @param ipstr_size pointer to current size of ipstr_list (might be changed
+ *        as a result of reallocation)
+ * @param ip IP address which is to be added to list
+ * @return pointer to string appended with new ip and possibly
+ *         reallocated to new length
+ **/
+
+static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
+{
+	char *new_ipstr = NULL;
+	char addr_buf[INET6_ADDRSTRLEN];
+	int ret;
+
+	/* arguments checking */
+	if (!ipstr_list || !service) {
+		return NULL;
+	}
+
+	print_sockaddr(addr_buf,
+			sizeof(addr_buf),
+			&service->ss);
+
+	/* attempt to convert ip to a string and append colon separator to it */
+	if (*ipstr_list) {
+		if (service->ss.ss_family == AF_INET) {
+			/* IPv4 */
+			ret = asprintf(&new_ipstr, "%s%s%s:%d",	*ipstr_list,
+				       IPSTR_LIST_SEP, addr_buf,
+				       service->port);
+		} else {
+			/* IPv6 */
+			ret = asprintf(&new_ipstr, "%s%s[%s]:%d", *ipstr_list,
+				       IPSTR_LIST_SEP, addr_buf,
+				       service->port);
+		}
+		SAFE_FREE(*ipstr_list);
+	} else {
+		if (service->ss.ss_family == AF_INET) {
+			/* IPv4 */
+			ret = asprintf(&new_ipstr, "%s:%d", addr_buf,
+				       service->port);
+		} else {
+			/* IPv6 */
+			ret = asprintf(&new_ipstr, "[%s]:%d", addr_buf,
+				       service->port);
+		}
+	}
+	if (ret == -1) {
+		return NULL;
+	}
+	*ipstr_list = new_ipstr;
+	return *ipstr_list;
+}
+
+/**
+ * Allocate and initialise an ipstr list using ip adresses
+ * passed as arguments.
+ *
+ * @param ipstr_list pointer to string meant to be allocated and set
+ * @param ip_list array of ip addresses to place in the list
+ * @param ip_count number of addresses stored in ip_list
+ * @return pointer to allocated ip string
+ **/
+
+char *ipstr_list_make(char **ipstr_list,
+			const struct ip_service *ip_list,
+			int ip_count)
+{
+	int i;
+
+	/* arguments checking */
+	if (!ip_list || !ipstr_list) {
+		return 0;
+	}
+
+	*ipstr_list = NULL;
+
+	/* process ip addresses given as arguments */
+	for (i = 0; i < ip_count; i++) {
+		*ipstr_list = ipstr_list_add(ipstr_list, &ip_list[i]);
+	}
+
+	return (*ipstr_list);
+}
+
+
+/**
+ * Parse given ip string list into array of ip addresses
+ * (as ip_service structures)
+ *    e.g. [IPv6]:port,192.168.1.100:389,192.168.1.78, ...
+ *
+ * @param ipstr ip string list to be parsed
+ * @param ip_list pointer to array of ip addresses which is
+ *        allocated by this function and must be freed by caller
+ * @return number of successfully parsed addresses
+ **/
+
+int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
+{
+	TALLOC_CTX *frame;
+	char *token_str = NULL;
+	size_t i, count;
+
+	if (!ipstr_list || !ip_list)
+		return 0;
+
+	count = count_chars(ipstr_list, IPSTR_LIST_CHAR) + 1;
+	if ( (*ip_list = SMB_MALLOC_ARRAY(struct ip_service, count)) == NULL ) {
+		DEBUG(0,("ipstr_list_parse: malloc failed for %lu entries\n",
+					(unsigned long)count));
+		return 0;
+	}
+
+	frame = talloc_stackframe();
+	for ( i=0; next_token_talloc(frame, &ipstr_list, &token_str,
+				IPSTR_LIST_SEP) && i<count; i++ ) {
+		char *s = token_str;
+		char *p = strrchr(token_str, ':');
+
+		if (p) {
+			*p = 0;
+			(*ip_list)[i].port = atoi(p+1);
+		}
+
+		/* convert single token to ip address */
+		if (token_str[0] == '[') {
+			/* IPv6 address. */
+			s++;
+			p = strchr(token_str, ']');
+			if (!p) {
+				continue;
+			}
+			*p = '\0';
+		}
+		if (!interpret_string_addr(&(*ip_list)[i].ss,
+					s,
+					AI_NUMERICHOST)) {
+			continue;
+		}
+	}
+	TALLOC_FREE(frame);
+	return count;
+}
+
+/**
+ * Safely free ip string list
+ *
+ * @param ipstr_list ip string list to be freed
+ **/
+
+void ipstr_list_free(char* ipstr_list)
+{
+	SAFE_FREE(ipstr_list);
+}
+
 #define NBTKEY_FMT  "NBT/%s#%02X"
 
 /**
-- 
2.20.1


From 1a2cbf953e36ee5116621b78973c3f3becaaa130 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 11:48:30 -0700
Subject: [PATCH 04/60] s3: lib: Cleanup - nothing uses ipstr_list_free().
 Remove it.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/include/proto.h    |  1 -
 source3/libsmb/namecache.c | 11 -----------
 2 files changed, 12 deletions(-)

diff --git a/source3/include/proto.h b/source3/include/proto.h
index 0c0ffc4f3ff..75d6f30249e 100644
--- a/source3/include/proto.h
+++ b/source3/include/proto.h
@@ -627,7 +627,6 @@ char *ipstr_list_make(char **ipstr_list,
 			const struct ip_service *ip_list,
 			int ip_count);
 int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list);
-void ipstr_list_free(char* ipstr_list);
 uint64_t STR_TO_SMB_BIG_UINT(const char *nptr, const char **entptr);
 uint64_t conv_str_size(const char * str);
 int asprintf_strupper_m(char **strp, const char *fmt, ...)
diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 8fc65675db9..6a4bbc7216f 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -177,17 +177,6 @@ int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
 	return count;
 }
 
-/**
- * Safely free ip string list
- *
- * @param ipstr_list ip string list to be freed
- **/
-
-void ipstr_list_free(char* ipstr_list)
-{
-	SAFE_FREE(ipstr_list);
-}
-
 #define NBTKEY_FMT  "NBT/%s#%02X"
 
 /**
-- 
2.20.1


From 8691ec0b35713dfd72e741a07f81e705ec95f6b3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 11:58:45 -0700
Subject: [PATCH 05/60] s3: lib: Cleanup - make ipstr_list_make() and
 ipstr_list_parse() private to the only user.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/include/proto.h    | 4 ----
 source3/libsmb/namecache.c | 4 ++--
 2 files changed, 2 insertions(+), 6 deletions(-)

diff --git a/source3/include/proto.h b/source3/include/proto.h
index 75d6f30249e..8562317553c 100644
--- a/source3/include/proto.h
+++ b/source3/include/proto.h
@@ -623,10 +623,6 @@ bool str_list_sub_basic( char **list, const char *smb_name,
 			 const char *domain_name );
 bool str_list_substitute(char **list, const char *pattern, const char *insert);
 
-char *ipstr_list_make(char **ipstr_list,
-			const struct ip_service *ip_list,
-			int ip_count);
-int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list);
 uint64_t STR_TO_SMB_BIG_UINT(const char *nptr, const char **entptr);
 uint64_t conv_str_size(const char * str);
 int asprintf_strupper_m(char **strp, const char *fmt, ...)
diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 6a4bbc7216f..3b77c748527 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -97,7 +97,7 @@ static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
  * @return pointer to allocated ip string
  **/
 
-char *ipstr_list_make(char **ipstr_list,
+static char *ipstr_list_make(char **ipstr_list,
 			const struct ip_service *ip_list,
 			int ip_count)
 {
@@ -130,7 +130,7 @@ char *ipstr_list_make(char **ipstr_list,
  * @return number of successfully parsed addresses
  **/
 
-int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
+static int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
 {
 	TALLOC_CTX *frame;
 	char *token_str = NULL;
-- 
2.20.1


From 7fea1669e07f7510e503e606a45a3a0cdb9ce7c6 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 12:12:23 -0700
Subject: [PATCH 06/60] s3: libsmb: Cleanup modern coding standards.
 'True/False' -> 'true/false'.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 24 ++++++++++++------------
 1 file changed, 12 insertions(+), 12 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 3b77c748527..832daea1e01 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -221,7 +221,7 @@ bool namecache_store(const char *name,
 	bool ret;
 
 	if (name_type > 255) {
-		return False; /* Don't store non-real name types. */
+		return false; /* Don't store non-real name types. */
 	}
 
 	if ( DEBUGLEVEL >= 5 ) {
@@ -247,7 +247,7 @@ bool namecache_store(const char *name,
 
 	key = namecache_key(name, name_type);
 	if (!key) {
-		return False;
+		return false;
 	}
 
 	expiry = time(NULL) + lp_name_cache_timeout();
@@ -293,11 +293,11 @@ bool namecache_fetch(const char *name,
 
 	/* exit now if null pointers were passed as they're required further */
 	if (!ip_list || !num_names) {
-		return False;
+		return false;
 	}
 
 	if (name_type > 255) {
-		return False; /* Don't fetch non-real name types. */
+		return false; /* Don't fetch non-real name types. */
 	}
 
 	*num_names = 0;
@@ -307,13 +307,13 @@ bool namecache_fetch(const char *name,
 	 */
 	key = namecache_key(name, name_type);
 	if (!key) {
-		return False;
+		return false;
 	}
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("no entry for %s#%02X found.\n", name, name_type));
 		SAFE_FREE(key);
-		return False;
+		return false;
 	}
 
 	DEBUG(5, ("name %s#%02X found.\n", name, name_type));
@@ -340,12 +340,12 @@ bool namecache_delete(const char *name, int name_type)
 	char *key;
 
 	if (name_type > 255) {
-		return False; /* Don't fetch non-real name types. */
+		return false; /* Don't fetch non-real name types. */
 	}
 
 	key = namecache_key(name, name_type);
 	if (!key) {
-		return False;
+		return false;
 	}
 	ret = gencache_del(key);
 	SAFE_FREE(key);
@@ -414,7 +414,7 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 	key = namecache_status_record_key(keyname, keyname_type,
 			name_type, keyip);
 	if (!key)
-		return False;
+		return false;
 
 	expiry = time(NULL) + lp_name_cache_timeout();
 	ret = gencache_set(key, srvname, expiry);
@@ -446,13 +446,13 @@ bool namecache_status_fetch(const char *keyname,
 	key = namecache_status_record_key(keyname, keyname_type,
 			name_type, keyip);
 	if (!key)
-		return False;
+		return false;
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("namecache_status_fetch: no entry for %s found.\n",
 					key));
 		SAFE_FREE(key);
-		return False;
+		return false;
 	} else {
 		DEBUG(5, ("namecache_status_fetch: key %s -> %s\n",
 					key, value ));
@@ -461,5 +461,5 @@ bool namecache_status_fetch(const char *keyname,
 	strlcpy(srvname_out, value, 16);
 	SAFE_FREE(key);
 	TALLOC_FREE(value);
-	return True;
+	return true;
 }
-- 
2.20.1


From 554b7195607054b861589879df6ae279c063abbb Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:28:33 -0700
Subject: [PATCH 07/60] s3: libsmb: Cleanup - move talloc frame out of inner
 scope.

Make it available thoughout the function. Prepare to use
talloc for namecache_key().

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 832daea1e01..76d411e87d1 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -219,20 +219,21 @@ bool namecache_store(const char *name,
 	char *key, *value_string;
 	int i;
 	bool ret;
+	TALLOC_CTX *frame = talloc_stackframe();
 
 	if (name_type > 255) {
+		TALLOC_FREE(frame);
 		return false; /* Don't store non-real name types. */
 	}
 
 	if ( DEBUGLEVEL >= 5 ) {
-		TALLOC_CTX *ctx = talloc_stackframe();
 		char *addr = NULL;
 
 		DEBUG(5, ("namecache_store: storing %d address%s for %s#%02x: ",
 			num_names, num_names == 1 ? "": "es", name, name_type));
 
 		for (i = 0; i < num_names; i++) {
-			addr = print_canonical_sockaddr(ctx,
+			addr = print_canonical_sockaddr(frame,
 							&ip_list[i].ss);
 			if (!addr) {
 				continue;
@@ -242,11 +243,11 @@ bool namecache_store(const char *name,
 
 		}
 		DEBUGADD(5, ("\n"));
-		TALLOC_FREE(ctx);
 	}
 
 	key = namecache_key(name, name_type);
 	if (!key) {
+		TALLOC_FREE(frame);
 		return false;
 	}
 
@@ -260,6 +261,7 @@ bool namecache_store(const char *name,
 	if (!ipstr_list_make(&value_string, ip_list, num_names)) {
 		SAFE_FREE(key);
 		SAFE_FREE(value_string);
+		TALLOC_FREE(frame);
 		return false;
 	}
 
@@ -267,6 +269,7 @@ bool namecache_store(const char *name,
 	ret = gencache_set(key, value_string, expiry);
 	SAFE_FREE(key);
 	SAFE_FREE(value_string);
+	TALLOC_FREE(frame);
 	return ret;
 }
 
-- 
2.20.1


From 0d47b6a4a362c369dc7a2c4faae02d92136edf66 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:31:38 -0700
Subject: [PATCH 08/60] s3: libsmb: Cleanup - namecache_store() initialize
 stack variables.

Preparing for common out: exit.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 76d411e87d1..1127874c375 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -216,9 +216,10 @@ bool namecache_store(const char *name,
 			struct ip_service *ip_list)
 {
 	time_t expiry;
-	char *key, *value_string;
+	char *key = NULL;
+	char *value_string = NULL;
 	int i;
-	bool ret;
+	bool ret = false;
 	TALLOC_CTX *frame = talloc_stackframe();
 
 	if (name_type > 255) {
-- 
2.20.1


From e214f1842ed0919c37b84d642945f90f456295e3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:33:27 -0700
Subject: [PATCH 09/60] s3: libsmb: Cleanup - namecache_store() - use common
 out.

Prepare for moving malloc values to talloc.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 1127874c375..a4de493b08e 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -223,8 +223,8 @@ bool namecache_store(const char *name,
 	TALLOC_CTX *frame = talloc_stackframe();
 
 	if (name_type > 255) {
-		TALLOC_FREE(frame);
-		return false; /* Don't store non-real name types. */
+		/* Don't store non-real name types. */
+		goto out;
 	}
 
 	if ( DEBUGLEVEL >= 5 ) {
@@ -248,8 +248,7 @@ bool namecache_store(const char *name,
 
 	key = namecache_key(name, name_type);
 	if (!key) {
-		TALLOC_FREE(frame);
-		return false;
+		goto out;
 	}
 
 	expiry = time(NULL) + lp_name_cache_timeout();
@@ -260,14 +259,14 @@ bool namecache_store(const char *name,
 	 * place each single ip
 	 */
 	if (!ipstr_list_make(&value_string, ip_list, num_names)) {
-		SAFE_FREE(key);
-		SAFE_FREE(value_string);
-		TALLOC_FREE(frame);
-		return false;
+		goto out;
 	}
 
 	/* set the entry */
 	ret = gencache_set(key, value_string, expiry);
+
+  out:
+
 	SAFE_FREE(key);
 	SAFE_FREE(value_string);
 	TALLOC_FREE(frame);
-- 
2.20.1


From 2bf1e9d318a6f9fdefcd79909ced4f2d6120631e Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 13:37:59 -0700
Subject: [PATCH 10/60] s3: libsmb: Cleanup - make namecache_key() use talloc.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 27 ++++++++++++++-------------
 1 file changed, 14 insertions(+), 13 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index a4de493b08e..5457a9d47cc 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -191,13 +191,14 @@ static int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
  *         type number
  */
 
-static char *namecache_key(const char *name,
-				int name_type)
+static char *namecache_key(TALLOC_CTX *ctx,
+			   const char *name,
+			   int name_type)
 {
-	char *keystr = NULL;
-	asprintf_strupper_m(&keystr, NBTKEY_FMT, name, name_type);
-
-	return keystr;
+	return talloc_asprintf_strupper_m(ctx,
+					  NBTKEY_FMT,
+					  name,
+					  name_type);
 }
 
 /**
@@ -246,7 +247,7 @@ bool namecache_store(const char *name,
 		DEBUGADD(5, ("\n"));
 	}
 
-	key = namecache_key(name, name_type);
+	key = namecache_key(frame, name, name_type);
 	if (!key) {
 		goto out;
 	}
@@ -267,7 +268,7 @@ bool namecache_store(const char *name,
 
   out:
 
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	SAFE_FREE(value_string);
 	TALLOC_FREE(frame);
 	return ret;
@@ -308,14 +309,14 @@ bool namecache_fetch(const char *name,
 	/*
 	 * Use gencache interface - lookup the key
 	 */
-	key = namecache_key(name, name_type);
+	key = namecache_key(talloc_tos(), name, name_type);
 	if (!key) {
 		return false;
 	}
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("no entry for %s#%02X found.\n", name, name_type));
-		SAFE_FREE(key);
+		TALLOC_FREE(key);
 		return false;
 	}
 
@@ -326,7 +327,7 @@ bool namecache_fetch(const char *name,
 	 */
 	*num_names = ipstr_list_parse(value, ip_list);
 
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	TALLOC_FREE(value);
 
 	return *num_names > 0; /* true only if some ip has been fetched */
@@ -346,12 +347,12 @@ bool namecache_delete(const char *name, int name_type)
 		return false; /* Don't fetch non-real name types. */
 	}
 
-	key = namecache_key(name, name_type);
+	key = namecache_key(talloc_tos(), name, name_type);
 	if (!key) {
 		return false;
 	}
 	ret = gencache_del(key);
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	return ret;
 }
 
-- 
2.20.1


From b1af71e4b87bbb31f90c8c22457663d9931d7de3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 14:38:23 -0700
Subject: [PATCH 11/60] s3: libsmb: Cleanup - make
 namecache_status_record_key() use talloc.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 33 +++++++++++++++++++++------------
 1 file changed, 21 insertions(+), 12 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 5457a9d47cc..ed0d116e3bb 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -391,18 +391,21 @@ void namecache_flush(void)
 
 /* Construct a name status record key. */
 
-static char *namecache_status_record_key(const char *name,
+static char *namecache_status_record_key(TALLOC_CTX *ctx,
+				const char *name,
 				int name_type1,
 				int name_type2,
 				const struct sockaddr_storage *keyip)
 {
 	char addr[INET6_ADDRSTRLEN];
-	char *keystr = NULL;
 
 	print_sockaddr(addr, sizeof(addr), keyip);
-	asprintf_strupper_m(&keystr, "NBT/%s#%02X.%02X.%s", name,
-			    name_type1, name_type2, addr);
-	return keystr;
+	return talloc_asprintf_strupper_m(ctx,
+					  "NBT/%s#%02X.%02X.%s",
+					  name,
+					  name_type1,
+					  name_type2,
+					  addr);
 }
 
 /* Store a name status record. */
@@ -415,8 +418,11 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 	time_t expiry;
 	bool ret;
 
-	key = namecache_status_record_key(keyname, keyname_type,
-			name_type, keyip);
+	key = namecache_status_record_key(talloc_tos(),
+					  keyname,
+					  keyname_type,
+					  name_type,
+					  keyip);
 	if (!key)
 		return false;
 
@@ -431,7 +437,7 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 					key ));
 	}
 
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	return ret;
 }
 
@@ -447,15 +453,18 @@ bool namecache_status_fetch(const char *keyname,
 	char *value = NULL;
 	time_t timeout;
 
-	key = namecache_status_record_key(keyname, keyname_type,
-			name_type, keyip);
+	key = namecache_status_record_key(talloc_tos(),
+					  keyname,
+					  keyname_type,
+					  name_type,
+					  keyip);
 	if (!key)
 		return false;
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
 		DEBUG(5, ("namecache_status_fetch: no entry for %s found.\n",
 					key));
-		SAFE_FREE(key);
+		TALLOC_FREE(key);
 		return false;
 	} else {
 		DEBUG(5, ("namecache_status_fetch: key %s -> %s\n",
@@ -463,7 +472,7 @@ bool namecache_status_fetch(const char *keyname,
 	}
 
 	strlcpy(srvname_out, value, 16);
-	SAFE_FREE(key);
+	TALLOC_FREE(key);
 	TALLOC_FREE(value);
 	return true;
 }
-- 
2.20.1


From 2ae055940b82d574ce665fc80c04032c095bc4a7 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 14:41:45 -0700
Subject: [PATCH 12/60] s3: libsmb: Cleanup - Move DEBUG -> DBG_XXX() macros.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>
---
 source3/libsmb/namecache.c | 28 ++++++++++++----------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index ed0d116e3bb..3c1a376b35b 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -141,8 +141,8 @@ static int ipstr_list_parse(const char *ipstr_list, struct ip_service **ip_list)
 
 	count = count_chars(ipstr_list, IPSTR_LIST_CHAR) + 1;
 	if ( (*ip_list = SMB_MALLOC_ARRAY(struct ip_service, count)) == NULL ) {
-		DEBUG(0,("ipstr_list_parse: malloc failed for %lu entries\n",
-					(unsigned long)count));
+		DBG_ERR("malloc failed for %lu entries\n",
+					(unsigned long)count);
 		return 0;
 	}
 
@@ -231,8 +231,8 @@ bool namecache_store(const char *name,
 	if ( DEBUGLEVEL >= 5 ) {
 		char *addr = NULL;
 
-		DEBUG(5, ("namecache_store: storing %d address%s for %s#%02x: ",
-			num_names, num_names == 1 ? "": "es", name, name_type));
+		DBG_INFO("storing %d address%s for %s#%02x: ",
+			num_names, num_names == 1 ? "": "es", name, name_type);
 
 		for (i = 0; i < num_names; i++) {
 			addr = print_canonical_sockaddr(frame,
@@ -315,12 +315,12 @@ bool namecache_fetch(const char *name,
 	}
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
-		DEBUG(5, ("no entry for %s#%02X found.\n", name, name_type));
+		DBG_INFO("no entry for %s#%02X found.\n", name, name_type);
 		TALLOC_FREE(key);
 		return false;
 	}
 
-	DEBUG(5, ("name %s#%02X found.\n", name, name_type));
+	DBG_INFO("name %s#%02X found.\n", name, name_type);
 
 	/*
 	 * Split up the stored value into the list of IP adresses
@@ -368,7 +368,7 @@ static void flush_netbios_name(const char *key,
 			void *dptr)
 {
 	gencache_del(key);
-	DEBUG(5, ("Deleting entry %s\n", key));
+	DBG_INFO("Deleting entry %s\n", key);
 }
 
 /**
@@ -386,7 +386,7 @@ void namecache_flush(void)
 	 * by flush_netbios_name function
 	 */
 	gencache_iterate(flush_netbios_name, NULL, "NBT/*");
-	DEBUG(5, ("Namecache flushed\n"));
+	DBG_INFO("Namecache flushed\n");
 }
 
 /* Construct a name status record key. */
@@ -430,11 +430,9 @@ bool namecache_status_store(const char *keyname, int keyname_type,
 	ret = gencache_set(key, srvname, expiry);
 
 	if (ret) {
-		DEBUG(5, ("namecache_status_store: entry %s -> %s\n",
-					key, srvname ));
+		DBG_INFO("entry %s -> %s\n", key, srvname);
 	} else {
-		DEBUG(5, ("namecache_status_store: entry %s store failed.\n",
-					key ));
+		DBG_INFO("entry %s store failed.\n", key);
 	}
 
 	TALLOC_FREE(key);
@@ -462,13 +460,11 @@ bool namecache_status_fetch(const char *keyname,
 		return false;
 
 	if (!gencache_get(key, talloc_tos(), &value, &timeout)) {
-		DEBUG(5, ("namecache_status_fetch: no entry for %s found.\n",
-					key));
+		DBG_INFO("no entry for %s found.\n", key);
 		TALLOC_FREE(key);
 		return false;
 	} else {
-		DEBUG(5, ("namecache_status_fetch: key %s -> %s\n",
-					key, value ));
+		DBG_INFO("key %s -> %s\n", key, value);
 	}
 
 	strlcpy(srvname_out, value, 16);
-- 
2.20.1


From 608a4b57e1ed69850d837f296443011db7457af8 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 15 Jul 2020 15:02:02 -0700
Subject: [PATCH 13/60] s3: libsmb: Cleanup - Make ipstr_list_make() talloc
 rather than malloc.

Remove the excessive and unneeded ipstr_list_add() function,
fold it into ipstr_list_make() to make it much clearer what
we're doing.

The only use of MALLOC now is in ipstr_list_parse() returned
by namecache_fetch(). We need to fix the caller before
we can move that to talloc. As that is used inside internal_resolve_name()
which is designed to return a MALLOC'ed ip list from all
name resolution mechanisms leave that fix for another day.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>

Autobuild-User(master): Volker Lendecke <vl@samba.org>
Autobuild-Date(master): Thu Jul 16 08:16:31 UTC 2020 on sn-devel-184
---
 source3/libsmb/namecache.c | 133 +++++++++++++++++--------------------
 1 file changed, 60 insertions(+), 73 deletions(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 3c1a376b35b..7f534587263 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -27,98 +27,86 @@
 #define IPSTR_LIST_SEP	","
 #define IPSTR_LIST_CHAR	','
 
-/**
- * Add ip string representation to ipstr list. Used also
- * as part of @function ipstr_list_make
- *
- * @param ipstr_list pointer to string containing ip list;
- *        MUST BE already allocated and IS reallocated if necessary
- * @param ipstr_size pointer to current size of ipstr_list (might be changed
- *        as a result of reallocation)
- * @param ip IP address which is to be added to list
- * @return pointer to string appended with new ip and possibly
- *         reallocated to new length
- **/
-
-static char *ipstr_list_add(char **ipstr_list, const struct ip_service *service)
-{
-	char *new_ipstr = NULL;
-	char addr_buf[INET6_ADDRSTRLEN];
-	int ret;
-
-	/* arguments checking */
-	if (!ipstr_list || !service) {
-		return NULL;
-	}
-
-	print_sockaddr(addr_buf,
-			sizeof(addr_buf),
-			&service->ss);
-
-	/* attempt to convert ip to a string and append colon separator to it */
-	if (*ipstr_list) {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s%s%s:%d",	*ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "%s%s[%s]:%d", *ipstr_list,
-				       IPSTR_LIST_SEP, addr_buf,
-				       service->port);
-		}
-		SAFE_FREE(*ipstr_list);
-	} else {
-		if (service->ss.ss_family == AF_INET) {
-			/* IPv4 */
-			ret = asprintf(&new_ipstr, "%s:%d", addr_buf,
-				       service->port);
-		} else {
-			/* IPv6 */
-			ret = asprintf(&new_ipstr, "[%s]:%d", addr_buf,
-				       service->port);
-		}
-	}
-	if (ret == -1) {
-		return NULL;
-	}
-	*ipstr_list = new_ipstr;
-	return *ipstr_list;
-}
-
 /**
  * Allocate and initialise an ipstr list using ip adresses
  * passed as arguments.
  *
- * @param ipstr_list pointer to string meant to be allocated and set
+ * @param ctx TALLOC_CTX to use
  * @param ip_list array of ip addresses to place in the list
  * @param ip_count number of addresses stored in ip_list
  * @return pointer to allocated ip string
  **/
 
-static char *ipstr_list_make(char **ipstr_list,
+static char *ipstr_list_make(TALLOC_CTX *ctx,
 			const struct ip_service *ip_list,
 			int ip_count)
 {
+	char *ipstr_list = NULL;
 	int i;
 
 	/* arguments checking */
-	if (!ip_list || !ipstr_list) {
-		return 0;
+	if (ip_list == NULL) {
+		return NULL;
 	}
 
-	*ipstr_list = NULL;
-
 	/* process ip addresses given as arguments */
 	for (i = 0; i < ip_count; i++) {
-		*ipstr_list = ipstr_list_add(ipstr_list, &ip_list[i]);
+		char addr_buf[INET6_ADDRSTRLEN];
+		char *new_str = NULL;
+
+		print_sockaddr(addr_buf,
+			       sizeof(addr_buf),
+			       &ip_list[i].ss);
+
+		if (ip_list->ss.ss_family == AF_INET) {
+			/* IPv4 */
+			new_str = talloc_asprintf(ctx,
+						  "%s:%d",
+						  addr_buf,
+						  ip_list[i].port);
+		} else {
+			/* IPv6 */
+			new_str = talloc_asprintf(ctx,
+						  "[%s]:%d",
+						  addr_buf,
+						  ip_list[i].port);
+		}
+		if (new_str == NULL) {
+			TALLOC_FREE(ipstr_list);
+			return NULL;
+		}
+
+		if (ipstr_list == NULL) {
+			/* First ip address. */
+			ipstr_list = new_str;
+		} else {
+			/*
+			 * Append the separator "," and then the new
+			 * ip address to the existing list.
+			 *
+			 * The efficiency here is horrible, but
+			 * ip_count should be small enough we can
+			 * live with it.
+			 */
+			char *tmp = talloc_asprintf(ctx,
+						    "%s%s%s",
+						    ipstr_list,
+						    IPSTR_LIST_SEP,
+						    new_str);
+			if (tmp == NULL) {
+				TALLOC_FREE(new_str);
+				TALLOC_FREE(ipstr_list);
+				return NULL;
+			}
+			TALLOC_FREE(new_str);
+			TALLOC_FREE(ipstr_list);
+			ipstr_list = tmp;
+		}
 	}
 
-	return (*ipstr_list);
+	return ipstr_list;
 }
 
-
 /**
  * Parse given ip string list into array of ip addresses
  * (as ip_service structures)
@@ -256,10 +244,9 @@ bool namecache_store(const char *name,
 
 	/*
 	 * Generate string representation of ip addresses list
-	 * First, store the number of ip addresses and then
-	 * place each single ip
 	 */
-	if (!ipstr_list_make(&value_string, ip_list, num_names)) {
+	value_string = ipstr_list_make(frame, ip_list, num_names);
+	if (value_string == NULL) {
 		goto out;
 	}
 
@@ -269,7 +256,7 @@ bool namecache_store(const char *name,
   out:
 
 	TALLOC_FREE(key);
-	SAFE_FREE(value_string);
+	TALLOC_FREE(value_string);
 	TALLOC_FREE(frame);
 	return ret;
 }
-- 
2.20.1


From c5ad0867738f1db28ed62eb8b345dbb979aa0246 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Thu, 16 Jul 2020 15:47:04 -0700
Subject: [PATCH 14/60] s3: libsmb: Namecache. Fix bug missed by me in previous
 cleanup.

In ipstr_list_make() we need to look at the correct array entry
to determine the ss_family for the sockaddr_storage.

Otherwise we are always storing the type of the first entry.

Signed-off-by: Jeremy Allison <jra@samba.org>
Reviewed-by: Volker Lendecke <vl@samba.org>

Autobuild-User(master): Volker Lendecke <vl@samba.org>
Autobuild-Date(master): Fri Jul 17 05:54:31 UTC 2020 on sn-devel-184
---
 source3/libsmb/namecache.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/source3/libsmb/namecache.c b/source3/libsmb/namecache.c
index 7f534587263..fb4a4aac8c8 100644
--- a/source3/libsmb/namecache.c
+++ b/source3/libsmb/namecache.c
@@ -58,7 +58,7 @@ static char *ipstr_list_make(TALLOC_CTX *ctx,
 			       sizeof(addr_buf),
 			       &ip_list[i].ss);
 
-		if (ip_list->ss.ss_family == AF_INET) {
+		if (ip_list[i].ss.ss_family == AF_INET) {
 			/* IPv4 */
 			new_str = talloc_asprintf(ctx,
 						  "%s:%d",
-- 
2.20.1


From f441967d537e935c452ecd86aaca35f090086793 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:57:44 -0700
Subject: [PATCH 15/60] s3: libsmb: Cleanup - ensure we don't try and continue
 resolving names on failure of convert_ss2service().

Logic change, but correct error cleanup - jump to new 'fail:' label.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index f61e2507cce..eba696b621d 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2672,6 +2672,7 @@ NTSTATUS internal_resolve_name(const char *name,
 							ss_list,
 							return_count)) {
 					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
 				goto done;
 			}
@@ -2704,6 +2705,7 @@ NTSTATUS internal_resolve_name(const char *name,
 							ss_list,
 							return_count)) {
 					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
 				goto done;
 			}
@@ -2720,6 +2722,7 @@ NTSTATUS internal_resolve_name(const char *name,
 								ss_list,
 								return_count)) {
 						status = NT_STATUS_NO_MEMORY;
+						goto fail;
 					}
 					goto done;
 				}
@@ -2734,6 +2737,7 @@ NTSTATUS internal_resolve_name(const char *name,
 							ss_list,
 							return_count)) {
 					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
 				goto done;
 			}
@@ -2745,6 +2749,8 @@ NTSTATUS internal_resolve_name(const char *name,
 
 	/* All of the resolve_* functions above have returned false. */
 
+  fail:
+
 	TALLOC_FREE(frame);
 	SAFE_FREE(*return_iplist);
 	*return_count = 0;
-- 
2.20.1


From 3bb783262b6b89a9dce6e4c6b0d993d6ac31a1a2 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:54:45 -0700
Subject: [PATCH 16/60] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_hosts().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index eba696b621d..1af78218bb2 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2667,15 +2667,16 @@ NTSTATUS internal_resolve_name(const char *name,
 			status = resolve_hosts(name, name_type,
 					       talloc_tos(), &ss_list,
 					       return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
+			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
 			}
+			goto done;
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-- 
2.20.1


From b8123058074fc9f89d7bc93a2835a0d50c6020c7 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:56:14 -0700
Subject: [PATCH 17/60] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for KDC resolve_ads().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 1af78218bb2..c4ab345e30a 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2682,12 +2682,13 @@ NTSTATUS internal_resolve_name(const char *name,
 			 * This will result in a SRV record lookup */
 			status = resolve_ads(name, KDC_NAME_TYPE, sitename,
 					     return_iplist, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				/* Ensure we don't namecache
-				 * this with the KDC port. */
-				name_type = KDC_NAME_TYPE;
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
 			}
+			/* Ensure we don't namecache
+			 * this with the KDC port. */
+			name_type = KDC_NAME_TYPE;
+			goto done;
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-- 
2.20.1


From 20a6e828d163db36dbe3d42fa10f4bcac83cb202 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:57:43 -0700
Subject: [PATCH 18/60] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_ads().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index c4ab345e30a..7f105abd402 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2694,9 +2694,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			 * This will result in a SRV record lookup */
 			status = resolve_ads(name, name_type, sitename,
 					     return_iplist, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
 			}
+			goto done;
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list;
 			status = resolve_lmhosts_file_as_sockaddr(
-- 
2.20.1


From 8ba0feea23a4ea1222c45eae9a8951d783c239ab Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:58:46 -0700
Subject: [PATCH 19/60] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_lmhosts_file_as_sockaddr().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 7f105abd402..319ae952d7f 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2703,15 +2703,16 @@ NTSTATUS internal_resolve_name(const char *name,
 			status = resolve_lmhosts_file_as_sockaddr(
 				get_dyn_LMHOSTSFILE(), name, name_type,
 				talloc_tos(), &ss_list, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
+			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
 			}
+			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
 			struct sockaddr_storage *ss_list;
-- 
2.20.1


From 75ce24eb59836ed66410ecdc46d218d3bfce2aa2 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 16:59:38 -0700
Subject: [PATCH 20/60] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for 0x1D name in resolve_wins().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 27 ++++++++++++++-------------
 1 file changed, 14 insertions(+), 13 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 319ae952d7f..95d17b6ebea 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2716,20 +2716,21 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
 			struct sockaddr_storage *ss_list;
-			if (name_type != 0x1D) {
-				status = resolve_wins(name, name_type,
-						      talloc_tos(),
-						      &ss_list,
-						      return_count);
-				if (NT_STATUS_IS_OK(status)) {
-					if (!convert_ss2service(return_iplist,
-								ss_list,
-								return_count)) {
-						status = NT_STATUS_NO_MEMORY;
-						goto fail;
-					}
-					goto done;
+			if (name_type == 0x1D) {
+				continue;
+			}
+			status = resolve_wins(name, name_type,
+					      talloc_tos(),
+					      &ss_list,
+					      return_count);
+			if (NT_STATUS_IS_OK(status)) {
+				if (!convert_ss2service(return_iplist,
+							ss_list,
+							return_count)) {
+					status = NT_STATUS_NO_MEMORY;
+					goto fail;
 				}
+				goto done;
 			}
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
-- 
2.20.1


From 967c9d9ba5afa409f27ea2027de5c06887e4da41 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:00:35 -0700
Subject: [PATCH 21/60] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for resolve_wins().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 95d17b6ebea..ffc36b0acf5 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2723,15 +2723,16 @@ NTSTATUS internal_resolve_name(const char *name,
 					      talloc_tos(),
 					      &ss_list,
 					      return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
+			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
 			}
+			goto done;
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
 			status = name_resolve_bcast(
-- 
2.20.1


From 77182f52562197bbb617cd445e1bb1afb0041fb4 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:01:04 -0700
Subject: [PATCH 22/60] s3: libsmb: Cleanup - change to early continue in
 internal_resolve_name() for name_resolve_bcast().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index ffc36b0acf5..9b459c58b18 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2738,15 +2738,16 @@ NTSTATUS internal_resolve_name(const char *name,
 			status = name_resolve_bcast(
 				name, name_type, talloc_tos(),
 				&ss_list, return_count);
-			if (NT_STATUS_IS_OK(status)) {
-				if (!convert_ss2service(return_iplist,
-							ss_list,
-							return_count)) {
-					status = NT_STATUS_NO_MEMORY;
-					goto fail;
-				}
-				goto done;
+			if (!NT_STATUS_IS_OK(status)) {
+				continue;
 			}
+			if (!convert_ss2service(return_iplist,
+						ss_list,
+						return_count)) {
+				status = NT_STATUS_NO_MEMORY;
+				goto fail;
+			}
+			goto done;
 		} else {
 			DEBUG(0,("resolve_name: unknown name switch type %s\n",
 				tok));
-- 
2.20.1


From a66566439cd2f4c9bde2c21a6e27f5146bf95dab Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:02:15 -0700
Subject: [PATCH 23/60] s3: libsmb: Cleanup - use helper 'ok' bool for
 resolve_hosts().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 9b459c58b18..a0607269eb4 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2583,6 +2583,7 @@ NTSTATUS internal_resolve_name(const char *name,
 	const char *tok;
 	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
 	int i;
+	bool ok;
 	TALLOC_CTX *frame = NULL;
 
 	*return_iplist = NULL;
@@ -2670,9 +2671,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From 1152a03baad479fe145cdff59fa5169684742920 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:03:21 -0700
Subject: [PATCH 24/60] s3: libsmb: Cleanup - use helper 'ok' bool for
 resolve_lmhosts_file_as_sockaddr().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index a0607269eb4..ce8f8f30ded 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2728,9 +2728,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From b5dd0d74c5ce919542e19c94c4889768387f525f Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:04:57 -0700
Subject: [PATCH 25/60] s3: libsmb: Cleanup - use helper 'ok' bool for
 resolve_wins().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index ce8f8f30ded..3cc8e3e3f1b 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2744,9 +2744,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From 13b47f75d2336cc3962d0259b2053c763b44c802 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:05:27 -0700
Subject: [PATCH 26/60] s3: libsmb: Cleanup - use helper 'ok' bool for
 name_resolve_bcast().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 3cc8e3e3f1b..b58d79e2e9d 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2708,9 +2708,10 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			if (!convert_ss2service(return_iplist,
+			ok = convert_ss2service(return_iplist,
 						ss_list,
-						return_count)) {
+						return_count);
+			if (!ok) {
 				status = NT_STATUS_NO_MEMORY;
 				goto fail;
 			}
-- 
2.20.1


From 7193f4e2c4e7f78adfa62c3b2ed67fb6c66dfabe Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:27:13 -0700
Subject: [PATCH 27/60] s3: libsmb: Cleanup - use helper 'ok' bool for
 internal_resolve_name().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index b58d79e2e9d..59643fa52d8 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2603,8 +2603,9 @@ NTSTATUS internal_resolve_name(const char *name,
 		(*return_iplist)->port = PORT_NONE;
 
 		/* if it's in the form of an IP address then get the lib to interpret it */
-		if (!interpret_string_addr(&(*return_iplist)->ss,
-					name, AI_NUMERICHOST)) {
+		ok = interpret_string_addr(&(*return_iplist)->ss,
+					name, AI_NUMERICHOST);
+		if (!ok) {
 			DEBUG(1,("internal_resolve_name: interpret_string_addr "
 				"failed on %s\n",
 				name));
-- 
2.20.1


From e8caa2daa6fe583d564b33dfcfa1cf664b7adb83 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:28:41 -0700
Subject: [PATCH 28/60] s3: libsmb: Cleanup - split allocation and NULL check
 in internal_resolve_name().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 59643fa52d8..6886d0b3b2a 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2593,8 +2593,8 @@ NTSTATUS internal_resolve_name(const char *name,
 			name, name_type, sitename ? sitename : "(null)"));
 
 	if (is_ipaddress(name)) {
-		if ((*return_iplist = SMB_MALLOC_P(struct ip_service)) ==
-				NULL) {
+		*return_iplist = SMB_MALLOC_P(struct ip_service);
+		if (*return_iplist == NULL) {
 			DEBUG(0,("internal_resolve_name: malloc fail !\n"));
 			return NT_STATUS_NO_MEMORY;
 		}
-- 
2.20.1


From 14012540cfef0c6802fdec8c0d159680c0f428c2 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:32:47 -0700
Subject: [PATCH 29/60] s3: libsmb: Cleanup - modernize DEBUG -> DBG_ in
 internal_resolve_name()

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 21 ++++++++++-----------
 1 file changed, 10 insertions(+), 11 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 6886d0b3b2a..f69ad676bb8 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2589,13 +2589,13 @@ NTSTATUS internal_resolve_name(const char *name,
 	*return_iplist = NULL;
 	*return_count = 0;
 
-	DEBUG(10, ("internal_resolve_name: looking up %s#%x (sitename %s)\n",
-			name, name_type, sitename ? sitename : "(null)"));
+	DBG_DEBUG("looking up %s#%x (sitename %s)\n",
+		name, name_type, sitename ? sitename : "(null)");
 
 	if (is_ipaddress(name)) {
 		*return_iplist = SMB_MALLOC_P(struct ip_service);
 		if (*return_iplist == NULL) {
-			DEBUG(0,("internal_resolve_name: malloc fail !\n"));
+			DBG_ERR("malloc fail !\n");
 			return NT_STATUS_NO_MEMORY;
 		}
 
@@ -2606,9 +2606,8 @@ NTSTATUS internal_resolve_name(const char *name,
 		ok = interpret_string_addr(&(*return_iplist)->ss,
 					name, AI_NUMERICHOST);
 		if (!ok) {
-			DEBUG(1,("internal_resolve_name: interpret_string_addr "
-				"failed on %s\n",
-				name));
+			DBG_WARNING("interpret_string_addr failed on %s\n",
+				name);
 			SAFE_FREE(*return_iplist);
 			return NT_STATUS_INVALID_PARAMETER;
 		}
@@ -2636,7 +2635,7 @@ NTSTATUS internal_resolve_name(const char *name,
 	/* set the name resolution order */
 
 	if (resolve_order && strcmp(resolve_order[0], "NULL") == 0) {
-		DEBUG(8,("internal_resolve_name: all lookups disabled\n"));
+		DBG_DEBUG("all lookups disabled\n");
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
@@ -2755,8 +2754,8 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else {
-			DEBUG(0,("resolve_name: unknown name switch type %s\n",
-				tok));
+			DBG_ERR("unknown name switch type %s\n",
+				tok);
 		}
 	}
 
@@ -2800,8 +2799,8 @@ NTSTATUS internal_resolve_name(const char *name,
 	/* Display some debugging info */
 
 	if ( DEBUGLEVEL >= 10 ) {
-		DEBUG(10, ("internal_resolve_name: returning %d addresses: ",
-					*return_count));
+		DBG_DEBUG("returning %d addresses: ",
+				*return_count);
 
 		for (i = 0; i < *return_count; i++) {
 			char addr[INET6_ADDRSTRLEN];
-- 
2.20.1


From c61c612a2a73bafc151e221bbb350f8943f96560 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:35:22 -0700
Subject: [PATCH 30/60] s3: libsmb: Cleanup - Remove incorrect comment in
 resolve_ads(). The DNS code copes fine with IPv6 addresses.

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index f69ad676bb8..a71cab8e1bf 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2387,7 +2387,6 @@ static NTSTATUS resolve_ads(const char *name,
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/* The DNS code needs fixing to find IPv6 addresses... JRA. */
 	switch (name_type) {
 		case 0x1b:
 			DEBUG(5,("resolve_ads: Attempting to resolve "
-- 
2.20.1


From 35e9dc4f687e7f9bac02f8b48a0177d66f8a0be8 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:38:20 -0700
Subject: [PATCH 31/60] s3: libsmb: Cleanup - reformatting resolve_hosts()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index a71cab8e1bf..8c570cebe70 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2664,8 +2664,10 @@ NTSTATUS internal_resolve_name(const char *name,
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
 			struct sockaddr_storage *ss_list;
-			status = resolve_hosts(name, name_type,
-					       talloc_tos(), &ss_list,
+			status = resolve_hosts(name,
+					       name_type,
+					       talloc_tos(),
+					       &ss_list,
 					       return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
-- 
2.20.1


From 62f9748c710dfffb69c44b0c7b00a646eb303a42 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:39:33 -0700
Subject: [PATCH 32/60] s3: libsmb: Cleanup - reformatting resolve_ads()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 8c570cebe70..16fa764ec65 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2683,8 +2683,11 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name, KDC_NAME_TYPE, sitename,
-					     return_iplist, return_count);
+			status = resolve_ads(name,
+					     KDC_NAME_TYPE,
+					     sitename,
+					     return_iplist,
+					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From 59caf60b887bf9851f8ee9a154437897dbd0363f Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:40:06 -0700
Subject: [PATCH 33/60] s3: libsmb: Cleanup - reformatting 2nd use of
 resolve_ads() parameters inside internal_resolve_name().

No logic change.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 16fa764ec65..2a92e530794 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2698,8 +2698,11 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name, name_type, sitename,
-					     return_iplist, return_count);
+			status = resolve_ads(name,
+					     name_type,
+					     sitename,
+					     return_iplist,
+					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From 5c37a41ae00bf481e10ed9889f737dd953e65062 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:42:44 -0700
Subject: [PATCH 34/60] s3: libsmb: Cleanup - reformatting
 resolve_lmhosts_file_as_sockaddr() parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 2a92e530794..30c16f349a5 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2710,8 +2710,12 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list;
 			status = resolve_lmhosts_file_as_sockaddr(
-				get_dyn_LMHOSTSFILE(), name, name_type,
-				talloc_tos(), &ss_list, return_count);
+				get_dyn_LMHOSTSFILE(),
+				name,
+				name_type,
+				talloc_tos(),
+				&ss_list,
+				return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From b074e5c334128caf40dcc84b02bd97e42385ffae Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:43:26 -0700
Subject: [PATCH 35/60] s3: libsmb: Cleanup - reformatting resolve_wins()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 30c16f349a5..bd20864a2a9 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2733,7 +2733,8 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (name_type == 0x1D) {
 				continue;
 			}
-			status = resolve_wins(name, name_type,
+			status = resolve_wins(name,
+					      name_type,
 					      talloc_tos(),
 					      &ss_list,
 					      return_count);
-- 
2.20.1


From dc6e2cbf95a2144e98c779499dd3a7f95e703149 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:44:03 -0700
Subject: [PATCH 36/60] s3: libsmb: Cleanup - reformatting name_resolve_bcast()
 parameters inside internal_resolve_name().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index bd20864a2a9..1f3eba9f294 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2752,8 +2752,11 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
 			status = name_resolve_bcast(
-				name, name_type, talloc_tos(),
-				&ss_list, return_count);
+						name,
+						name_type,
+						talloc_tos(),
+						&ss_list,
+						return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-- 
2.20.1


From cbe9c06fcff50e4c859b596a7f5c93e35f8bfc01 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:45:44 -0700
Subject: [PATCH 37/60] s3: libsmb: Cleanup - put talloc parameter first in
 resolve_hosts().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 1f3eba9f294..2e5ecc0fb62 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2274,8 +2274,9 @@ fail:
  Resolve via "hosts" method.
 *********************************************************/
 
-static NTSTATUS resolve_hosts(const char *name, int name_type,
-			      TALLOC_CTX *mem_ctx,
+static NTSTATUS resolve_hosts(TALLOC_CTX *mem_ctx,
+			      const char *name,
+			      int name_type,
 			      struct sockaddr_storage **return_iplist,
 			      int *return_count)
 {
@@ -2664,9 +2665,9 @@ NTSTATUS internal_resolve_name(const char *name,
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
 			struct sockaddr_storage *ss_list;
-			status = resolve_hosts(name,
+			status = resolve_hosts(talloc_tos(),
+					       name,
 					       name_type,
-					       talloc_tos(),
 					       &ss_list,
 					       return_count);
 			if (!NT_STATUS_IS_OK(status)) {
-- 
2.20.1


From 66383beb83a83453dd30bb9805381a3d5eb5ccf9 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:50:21 -0700
Subject: [PATCH 38/60] s3/s4: Cleanup. Move TALLOC_CTX * parameter to be first
 in resolve_lmhosts_file_as_sockaddr() to match modern conventions.

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 libcli/nbt/libnbt.h              | 7 ++++---
 libcli/nbt/lmhosts.c             | 7 ++++---
 source3/libsmb/namequery.c       | 2 +-
 source4/libcli/resolve/lmhosts.c | 8 ++++++--
 4 files changed, 15 insertions(+), 9 deletions(-)

diff --git a/libcli/nbt/libnbt.h b/libcli/nbt/libnbt.h
index f7212789897..496b2b91783 100644
--- a/libcli/nbt/libnbt.h
+++ b/libcli/nbt/libnbt.h
@@ -367,9 +367,10 @@ bool getlmhostsent(TALLOC_CTX *ctx, FILE *fp, char **pp_name, int *name_type,
 		   struct sockaddr_storage *pss);
 void endlmhosts(FILE *fp);
 
-NTSTATUS resolve_lmhosts_file_as_sockaddr(const char *lmhosts_file, 
-					  const char *name, int name_type,
-					  TALLOC_CTX *mem_ctx, 
+NTSTATUS resolve_lmhosts_file_as_sockaddr(TALLOC_CTX *mem_ctx,
+					  const char *lmhosts_file,
+					  const char *name,
+					  int name_type,
 					  struct sockaddr_storage **return_iplist,
 					  int *return_count);
 
diff --git a/libcli/nbt/lmhosts.c b/libcli/nbt/lmhosts.c
index f47d8b9804f..0890c0407d3 100644
--- a/libcli/nbt/lmhosts.c
+++ b/libcli/nbt/lmhosts.c
@@ -159,9 +159,10 @@ void endlmhosts(FILE *fp)
  Resolve via "lmhosts" method.
 *********************************************************/
 
-NTSTATUS resolve_lmhosts_file_as_sockaddr(const char *lmhosts_file,
-					  const char *name, int name_type,
-					  TALLOC_CTX *mem_ctx,
+NTSTATUS resolve_lmhosts_file_as_sockaddr(TALLOC_CTX *mem_ctx,
+					  const char *lmhosts_file,
+					  const char *name,
+					  int name_type,
 					  struct sockaddr_storage **return_iplist,
 					  int *return_count)
 {
diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 2e5ecc0fb62..0edab06fff9 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2711,10 +2711,10 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list;
 			status = resolve_lmhosts_file_as_sockaddr(
+				talloc_tos(),
 				get_dyn_LMHOSTSFILE(),
 				name,
 				name_type,
-				talloc_tos(),
 				&ss_list,
 				return_count);
 			if (!NT_STATUS_IS_OK(status)) {
diff --git a/source4/libcli/resolve/lmhosts.c b/source4/libcli/resolve/lmhosts.c
index 400cf79f68b..42bdaf962f9 100644
--- a/source4/libcli/resolve/lmhosts.c
+++ b/source4/libcli/resolve/lmhosts.c
@@ -68,8 +68,12 @@ static struct composite_context *resolve_name_lmhosts_send(
 	if (composite_nomem(state, c)) return c;
 	c->private_data = state;
 
-	c->status = resolve_lmhosts_file_as_sockaddr(dyn_LMHOSTSFILE, name->name, name->type,
-						     state, &resolved_iplist, &resolved_count);
+	c->status = resolve_lmhosts_file_as_sockaddr(state,
+						     dyn_LMHOSTSFILE,
+						     name->name,
+						     name->type,
+						     &resolved_iplist,
+						     &resolved_count);
 	if (!composite_is_ok(c)) return c;
 
 	for (i=0; i < resolved_count; i++) {
-- 
2.20.1


From 672efd8beced614e953785c08ec70fd32826e5a0 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:53:28 -0700
Subject: [PATCH 39/60] s3: libsmb: Cleanup - put talloc parameter first in
 resolve_wins().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 8 ++++----
 source3/libsmb/namequery.h | 4 ++--
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 0edab06fff9..824f80e6b29 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2242,9 +2242,9 @@ NTSTATUS resolve_wins_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
  Resolve via "wins" method.
 *********************************************************/
 
-NTSTATUS resolve_wins(const char *name,
+NTSTATUS resolve_wins(TALLOC_CTX *mem_ctx,
+		const char *name,
 		int name_type,
-		TALLOC_CTX *mem_ctx,
 		struct sockaddr_storage **return_iplist,
 		int *return_count)
 {
@@ -2734,9 +2734,9 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (name_type == 0x1D) {
 				continue;
 			}
-			status = resolve_wins(name,
+			status = resolve_wins(talloc_tos(),
+					      name,
 					      name_type,
-					      talloc_tos(),
 					      &ss_list,
 					      return_count);
 			if (!NT_STATUS_IS_OK(status)) {
diff --git a/source3/libsmb/namequery.h b/source3/libsmb/namequery.h
index d7bd4d338b4..7e31dc1b632 100644
--- a/source3/libsmb/namequery.h
+++ b/source3/libsmb/namequery.h
@@ -80,9 +80,9 @@ struct tevent_req *resolve_wins_send(TALLOC_CTX *mem_ctx,
 NTSTATUS resolve_wins_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
 			   struct sockaddr_storage **addrs,
 			   int *num_addrs, uint8_t *flags);
-NTSTATUS resolve_wins(const char *name,
+NTSTATUS resolve_wins(TALLOC_CTX *mem_ctx,
+		const char *name,
 		int name_type,
-		TALLOC_CTX *mem_ctx,
 		struct sockaddr_storage **return_iplist,
 		int *return_count);
 NTSTATUS internal_resolve_name(const char *name,
-- 
2.20.1


From ad940524332e5ec938f18fb676a114fefa851d4f Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:56:48 -0700
Subject: [PATCH 40/60] s3: libsmb: Cleanup - put talloc parameter first in
 name_resolve_bcast().

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/libsmb_dir.c | 7 +++++--
 source3/libsmb/namequery.c  | 6 +++---
 source3/libsmb/namequery.h  | 4 ++--
 source3/utils/nmblookup.c   | 8 +++++---
 4 files changed, 15 insertions(+), 10 deletions(-)

diff --git a/source3/libsmb/libsmb_dir.c b/source3/libsmb/libsmb_dir.c
index fd42c71b2b8..506bfc56865 100644
--- a/source3/libsmb/libsmb_dir.c
+++ b/source3/libsmb/libsmb_dir.c
@@ -599,8 +599,11 @@ SMBC_opendir_ctx(SMBCCTX *context,
                  */
 
                 ip_list = NULL;
-		status = name_resolve_bcast(MSBROWSE, 1, talloc_tos(),
-					    &ip_list, &count);
+		status = name_resolve_bcast(talloc_tos(),
+					    MSBROWSE,
+					    1,
+					    &ip_list,
+					    &count);
                 if (!NT_STATUS_IS_OK(status))
 		{
 
diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 824f80e6b29..dde49c84d2d 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -1899,9 +1899,9 @@ NTSTATUS name_resolve_bcast_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
 	return NT_STATUS_OK;
 }
 
-NTSTATUS name_resolve_bcast(const char *name,
+NTSTATUS name_resolve_bcast(TALLOC_CTX *mem_ctx,
+			const char *name,
 			int name_type,
-			TALLOC_CTX *mem_ctx,
 			struct sockaddr_storage **return_iplist,
 			int *return_count)
 {
@@ -2753,9 +2753,9 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if (strequal(tok, "bcast")) {
 			struct sockaddr_storage *ss_list;
 			status = name_resolve_bcast(
+						talloc_tos(),
 						name,
 						name_type,
-						talloc_tos(),
 						&ss_list,
 						return_count);
 			if (!NT_STATUS_IS_OK(status)) {
diff --git a/source3/libsmb/namequery.h b/source3/libsmb/namequery.h
index 7e31dc1b632..aedb043ac81 100644
--- a/source3/libsmb/namequery.h
+++ b/source3/libsmb/namequery.h
@@ -68,9 +68,9 @@ struct tevent_req *name_resolve_bcast_send(TALLOC_CTX *mem_ctx,
 NTSTATUS name_resolve_bcast_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
 				 struct sockaddr_storage **addrs,
 				 int *num_addrs);
-NTSTATUS name_resolve_bcast(const char *name,
+NTSTATUS name_resolve_bcast(TALLOC_CTX *mem_ctx,
+			const char *name,
 			int name_type,
-			TALLOC_CTX *mem_ctx,
 			struct sockaddr_storage **return_iplist,
 			int *return_count);
 struct tevent_req *resolve_wins_send(TALLOC_CTX *mem_ctx,
diff --git a/source3/utils/nmblookup.c b/source3/utils/nmblookup.c
index c74b6497a35..2f50c5c8f5a 100644
--- a/source3/utils/nmblookup.c
+++ b/source3/utils/nmblookup.c
@@ -171,9 +171,11 @@ static bool query_one(const char *lookup, unsigned int lookup_type)
 				    &bcast_addr, talloc_tos(),
 				    &ip_list, &count, &flags);
 	} else {
-		status = name_resolve_bcast(
-			lookup, lookup_type,
-			talloc_tos(), &ip_list, &count);
+		status = name_resolve_bcast(talloc_tos(),
+					    lookup,
+					    lookup_type,
+					    &ip_list,
+					    &count);
 	}
 
 	if (!NT_STATUS_IS_OK(status)) {
-- 
2.20.1


From 3dfb140ce68292e6be28777bd3660d105da72c7e Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:27:38 -0700
Subject: [PATCH 41/60] s3: libsmb: Cleanup - ensure ss_list variables are
 initialized with NULL.

No logic changes.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index dde49c84d2d..01a2bacb9eb 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2664,7 +2664,7 @@ NTSTATUS internal_resolve_name(const char *name,
 		tok = resolve_order[i];
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_hosts(talloc_tos(),
 					       name,
 					       name_type,
@@ -2709,7 +2709,7 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_lmhosts_file_as_sockaddr(
 				talloc_tos(),
 				get_dyn_LMHOSTSFILE(),
@@ -2730,7 +2730,7 @@ NTSTATUS internal_resolve_name(const char *name,
 			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			if (name_type == 0x1D) {
 				continue;
 			}
@@ -2751,7 +2751,7 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "bcast")) {
-			struct sockaddr_storage *ss_list;
+			struct sockaddr_storage *ss_list = NULL;
 			status = name_resolve_bcast(
 						talloc_tos(),
 						name,
-- 
2.20.1


From 8be5558f192d55ff6cb8d4f4f595ac79fef27dc4 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 17:59:20 -0700
Subject: [PATCH 42/60] s3: libsmb: Pass in TALLOC_CTX * parameter to
 resolve_ads() instead of creating one internally.

Pass in talloc_tos() to make it match the other resolve_XXX() functions.

No memory leaks as this is used for transient data and is cleaned up
when the calling frame in internal_resolve_name() is destroyed.

Preparing to have it return a talloc'ed struct sockaddr_storage array
rather than a malloc'ed struct ip_service array.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 20 ++++++--------------
 1 file changed, 6 insertions(+), 14 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 01a2bacb9eb..519bd1bf181 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2365,7 +2365,8 @@ static NTSTATUS resolve_hosts(TALLOC_CTX *mem_ctx,
 /* Special name type used to cause a _kerberos DNS lookup. */
 #define KDC_NAME_TYPE 0xDCDC
 
-static NTSTATUS resolve_ads(const char *name,
+static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
+			    const char *name,
 			    int name_type,
 			    const char *sitename,
 			    struct ip_service **return_iplist,
@@ -2373,7 +2374,6 @@ static NTSTATUS resolve_ads(const char *name,
 {
 	int 			i;
 	NTSTATUS  		status;
-	TALLOC_CTX		*ctx;
 	struct dns_rr_srv	*dcs = NULL;
 	int			numdcs = 0;
 	int			numaddrs = 0;
@@ -2383,11 +2383,6 @@ static NTSTATUS resolve_ads(const char *name,
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	if ( (ctx = talloc_init("resolve_ads")) == NULL ) {
-		DEBUG(0,("resolve_ads: talloc_init() failed!\n"));
-		return NT_STATUS_NO_MEMORY;
-	}
-
 	switch (name_type) {
 		case 0x1b:
 			DEBUG(5,("resolve_ads: Attempting to resolve "
@@ -2422,14 +2417,12 @@ static NTSTATUS resolve_ads(const char *name,
 	}
 
 	if ( !NT_STATUS_IS_OK( status ) ) {
-		talloc_destroy(ctx);
 		return status;
 	}
 
 	if (numdcs == 0) {
 		*return_iplist = NULL;
 		*return_count = 0;
-		talloc_destroy(ctx);
 		return NT_STATUS_OK;
 	}
 
@@ -2445,7 +2438,6 @@ static NTSTATUS resolve_ads(const char *name,
 			NULL ) {
 		DEBUG(0,("resolve_ads: malloc failed for %d entries\n",
 					numaddrs ));
-		talloc_destroy(ctx);
 		return NT_STATUS_NO_MEMORY;
 	}
 
@@ -2487,7 +2479,6 @@ static NTSTATUS resolve_ads(const char *name,
 					if (res) {
 						freeaddrinfo(res);
 					}
-					talloc_destroy(ctx);
 					return NT_STATUS_NO_MEMORY;
 				}
 			}
@@ -2526,7 +2517,6 @@ static NTSTATUS resolve_ads(const char *name,
 		}
 	}
 
-	talloc_destroy(ctx);
 	return NT_STATUS_OK;
 }
 
@@ -2684,7 +2674,8 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name,
+			status = resolve_ads(talloc_tos(),
+					     name,
 					     KDC_NAME_TYPE,
 					     sitename,
 					     return_iplist,
@@ -2699,7 +2690,8 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-			status = resolve_ads(name,
+			status = resolve_ads(talloc_tos(),
+					     name,
 					     name_type,
 					     sitename,
 					     return_iplist,
-- 
2.20.1


From 52d289bf71125d70f617aad8e0943d98bc83a4b7 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 18:31:16 -0700
Subject: [PATCH 43/60] s3: libsmb: Add in (currently unused) function
 dns_lookup_list().

This function takes a list of names returned from a DNS SRV
query which didn't have returned IP addresses and returns an
array of struct sockaddr_storage.

Currently synchronous, but this is the function that will
be changed to be asynchronous later.

Compiles but commented out for now so we don't get "unused
function" warnings.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 83 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 519bd1bf181..8a274bc5fbc 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2270,6 +2270,89 @@ fail:
 	return status;
 }
 
+#if 0
+/********************************************************
+ Resolve a list of DNS names to a list of IP addresses.
+ As this is a DC / LDAP / KDC lookup any IP address will
+ do, the requested names don't have to match the returned
+ IP address list.
+*********************************************************/
+
+static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
+				size_t num_dns_names,
+				const char **dns_lookup_names,
+				size_t *p_num_addrs,
+				struct sockaddr_storage **pp_addrs)
+{
+	size_t total_num_addrs = 0;
+	size_t i;
+	struct sockaddr_storage *ret_addrs = NULL;
+
+	/* FIXME - make this asnyc using our async DNS code. */
+
+	for (i = 0; i < num_dns_names; i++ ) {
+		struct addrinfo *res = NULL;
+		struct addrinfo *p = NULL;
+		size_t num_addrs = 0;
+		bool ok = interpret_string_addr_internal(&res,
+					dns_lookup_names[i],
+					0);
+		if (!ok) {
+			continue;
+		}
+		/* Count the IP's returned from the lookup. */
+		for (p = res; p; p = p->ai_next) {
+			num_addrs++;
+		}
+
+		/* Wrap check. */
+		if (total_num_addrs + num_addrs < total_num_addrs) {
+			if (res) {
+				freeaddrinfo(res);
+			}
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+		ret_addrs = talloc_realloc(ctx,
+					   ret_addrs,
+					   struct sockaddr_storage,
+					   total_num_addrs + num_addrs);
+		if (ret_addrs == NULL) {
+			if (res) {
+				freeaddrinfo(res);
+			}
+			return NT_STATUS_NO_MEMORY;
+		}
+
+		for (p = res; p; p = p->ai_next) {
+			char addr[INET6_ADDRSTRLEN];
+
+			memcpy(&ret_addrs[total_num_addrs],
+				p->ai_addr,
+				p->ai_addrlen);
+
+			if (is_zero_addr(&ret_addrs[total_num_addrs])) {
+				continue;
+			}
+
+			DBG_DEBUG("getaddrinfo name %s returned IP %s\n",
+				dns_lookup_names[i],
+				print_sockaddr(addr,
+					sizeof(addr),
+					&ret_addrs[total_num_addrs]));
+
+			total_num_addrs++;
+		}
+		if (res) {
+			freeaddrinfo(res);
+		}
+	}
+
+	*p_num_addrs = total_num_addrs;
+	*pp_addrs = ret_addrs;
+	return NT_STATUS_OK;
+}
+#endif
+
 /********************************************************
  Resolve via "hosts" method.
 *********************************************************/
-- 
2.20.1


From 216c9512856e9afd854e0fee0047889bf2bdfd91 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 19:50:04 -0700
Subject: [PATCH 44/60] s3: libsmb: Rewrite resolve_ads() to use the previously
 added dns_lookup_list() function.

Clean up internals - a LOT.

This one needs careful review. Ditch the (unused) port returns from
the SRV replies.

Internally uses talloc'ed arrays of struct sockaddr_storage
which it then convert to MALLOC'ed struct ip_service.

Still returns struct ip_service but this will be
fixed in the next commit.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 242 ++++++++++++++++++++++++-------------
 1 file changed, 160 insertions(+), 82 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 8a274bc5fbc..842f82264ba 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2270,7 +2270,6 @@ fail:
 	return status;
 }
 
-#if 0
 /********************************************************
  Resolve a list of DNS names to a list of IP addresses.
  As this is a DC / LDAP / KDC lookup any IP address will
@@ -2351,7 +2350,6 @@ static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
 	*pp_addrs = ret_addrs;
 	return NT_STATUS_OK;
 }
-#endif
 
 /********************************************************
  Resolve via "hosts" method.
@@ -2460,6 +2458,13 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	struct dns_rr_srv	*dcs = NULL;
 	int			numdcs = 0;
 	int			numaddrs = 0;
+	size_t num_srv_addrs = 0;
+	struct sockaddr_storage *srv_addrs = NULL;
+	size_t num_dns_addrs = 0;
+	struct sockaddr_storage *dns_addrs = NULL;
+	size_t num_dns_names = 0;
+	const char **dns_lookup_names = NULL;
+	struct ip_service *iplist = NULL;
 
 	if ((name_type != 0x1c) && (name_type != KDC_NAME_TYPE) &&
 	    (name_type != 0x1b)) {
@@ -2499,107 +2504,180 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 			break;
 	}
 
-	if ( !NT_STATUS_IS_OK( status ) ) {
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
 		return status;
 	}
 
 	if (numdcs == 0) {
+		TALLOC_FREE(dcs);
 		*return_iplist = NULL;
 		*return_count = 0;
 		return NT_STATUS_OK;
 	}
 
-	for (i=0;i<numdcs;i++) {
-		if (!dcs[i].ss_s) {
-			numaddrs += 1;
+	/*
+	 * Split the returned values into 2 arrays. First one
+	 * is a struct sockaddr_storage array that contains results
+	 * from the SRV record lookup that contain both hostnames
+	 * and IP addresses. We only need to copy out the IP
+	 * addresses. This is srv_addrs.
+	 *
+	 * Second array contains the results from the SRV record
+	 * lookup that only contain hostnames - no IP addresses.
+	 * We must then call dns_lookup_list() to lookup
+	 * hostnames -> IP address. This is dns_addrs.
+	 *
+	 * Finally we will merge these two arrays to create the
+	 * return ip_service array.
+	 */
+
+	/* First count the sizes of each array. */
+	for(i = 0; i < numdcs; i++) {
+		if (dcs[i].ss_s != NULL) {
+			/* IP address returned in SRV record. */
+			if (num_srv_addrs + dcs[i].num_ips < num_srv_addrs) {
+				/* Wrap check. */
+				TALLOC_FREE(dcs);
+				return NT_STATUS_INVALID_PARAMETER;
+			}
+			/* Add in the number of addresses we got. */
+			num_srv_addrs += dcs[i].num_ips;
+			/*
+			 * If we got any IP addresses zero out
+			 * the hostname so we know we've already
+			 * processed this entry and won't add it
+			 * to the dns_lookup_names array we use
+			 * to do DNS queries below.
+			 */
+			dcs[i].hostname = NULL;
 		} else {
-			numaddrs += dcs[i].num_ips;
+			/* Ensure we have a hostname to lookup. */
+			if (dcs[i].hostname == NULL) {
+				continue;
+			}
+			/* No IP address returned in SRV record. */
+			if (num_dns_names + 1 < num_dns_names) {
+				/* Wrap check. */
+				TALLOC_FREE(dcs);
+				return NT_STATUS_INVALID_PARAMETER;
+			}
+			/* One more name to lookup. */
+			num_dns_names += 1;
 		}
-        }
+	}
 
-	if ((*return_iplist = SMB_MALLOC_ARRAY(struct ip_service, numaddrs)) ==
-			NULL ) {
-		DEBUG(0,("resolve_ads: malloc failed for %d entries\n",
-					numaddrs ));
+	/* Allocate the list of IP addresses we already have. */
+	srv_addrs = talloc_zero_array(ctx,
+				struct sockaddr_storage,
+				num_srv_addrs);
+	if (srv_addrs == NULL) {
+		TALLOC_FREE(dcs);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/* now unroll the list of IP addresses */
-
-	*return_count = 0;
+	/* Copy the addresses we already have. */
+	num_srv_addrs = 0;
+	for(i = 0; i < numdcs; i++) {
+		/* Copy all the IP addresses from the SRV response */
+		size_t j;
+		for (j = 0; j < dcs[i].num_ips; j++) {
+			char addr[INET6_ADDRSTRLEN];
 
-	for (i = 0; i < numdcs && (*return_count<numaddrs); i++ ) {
-		/* If we don't have an IP list for a name, lookup it up */
-		if (!dcs[i].ss_s) {
-			/* We need to get all IP addresses here. */
-			struct addrinfo *res = NULL;
-			struct addrinfo *p;
-			int extra_addrs = 0;
-
-			if (!interpret_string_addr_internal(&res,
-						dcs[i].hostname,
-						0)) {
+			srv_addrs[num_srv_addrs] = dcs[i].ss_s[j];
+			if (is_zero_addr(&srv_addrs[num_srv_addrs])) {
 				continue;
 			}
-			/* Add in every IP from the lookup. How
-			   many is that ? */
-			for (p = res; p; p = p->ai_next) {
-				struct sockaddr_storage ss;
-				memcpy(&ss, p->ai_addr, p->ai_addrlen);
-				if (is_zero_addr(&ss)) {
-					continue;
-				}
-				extra_addrs++;
-			}
-			if (extra_addrs > 1) {
-				/* We need to expand the return_iplist array
-				   as we only budgeted for one address. */
-				numaddrs += (extra_addrs-1);
-				*return_iplist = SMB_REALLOC_ARRAY(*return_iplist,
-						struct ip_service,
-						numaddrs);
-				if (*return_iplist == NULL) {
-					if (res) {
-						freeaddrinfo(res);
-					}
-					return NT_STATUS_NO_MEMORY;
-				}
-			}
-			for (p = res; p; p = p->ai_next) {
-				(*return_iplist)[*return_count].port = dcs[i].port;
-				memcpy(&(*return_iplist)[*return_count].ss,
-						p->ai_addr,
-						p->ai_addrlen);
-				if (is_zero_addr(&(*return_iplist)[*return_count].ss)) {
-					continue;
-				}
-				(*return_count)++;
-				/* Should never happen, but still... */
-				if (*return_count>=numaddrs) {
-					break;
-				}
-			}
-			if (res) {
-				freeaddrinfo(res);
-			}
-		} else {
-			/* use all the IP addresses from the SRV response */
-			size_t j;
-			for (j = 0; j < dcs[i].num_ips; j++) {
-				(*return_iplist)[*return_count].port = dcs[i].port;
-				(*return_iplist)[*return_count].ss = dcs[i].ss_s[j];
-				if (is_zero_addr(&(*return_iplist)[*return_count].ss)) {
-					continue;
-				}
-                                (*return_count)++;
-				/* Should never happen, but still... */
-				if (*return_count>=numaddrs) {
-					break;
-				}
-			}
+
+			DBG_DEBUG("SRV lookup %s got IP[%zu] %s\n",
+				name,
+				j,
+				print_sockaddr(addr,
+					sizeof(addr),
+					&srv_addrs[num_srv_addrs]));
+
+			num_srv_addrs++;
 		}
 	}
 
+	/* Allocate the array of hostnames we must look up. */
+	dns_lookup_names = talloc_zero_array(ctx,
+					const char *,
+					num_dns_names);
+	if (dns_lookup_names == NULL) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	num_dns_names = 0;
+	for(i = 0; i < numdcs; i++) {
+		if (dcs[i].hostname == NULL) {
+			/*
+			 * Must have been a SRV return with an IP address.
+			 * We don't need to look up this hostname.
+			 */
+			continue;
+                }
+		dns_lookup_names[num_dns_names] = dcs[i].hostname;
+		num_dns_names++;
+	}
+
+	/* Lookup the addresses on the dns_lookup_list. */
+	status = dns_lookup_list(ctx,
+				num_dns_names,
+				dns_lookup_names,
+				&num_dns_addrs,
+				&dns_addrs);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		TALLOC_FREE(dns_lookup_names);
+		return status;
+	}
+
+	/*
+	 * Combine the two sockaddr_storage arrays into a MALLOC'ed
+	 * ipservice array return.
+	 */
+
+	numaddrs = num_srv_addrs + num_dns_addrs;
+	/* Wrap check + bloody int conversion check :-(. */
+	if (numaddrs < num_srv_addrs ||
+				numaddrs < 0) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		TALLOC_FREE(dns_addrs);
+		TALLOC_FREE(dns_lookup_names);
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	iplist = SMB_MALLOC_ARRAY(struct ip_service, numaddrs);
+	if (iplist == NULL) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(srv_addrs);
+		TALLOC_FREE(dns_addrs);
+		TALLOC_FREE(dns_lookup_names);
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	for (i = 0; i < num_srv_addrs; i++) {
+		iplist[i].ss = srv_addrs[i];
+		iplist[i].port = 0;
+	}
+	for (i = 0; i < num_dns_addrs; i++) {
+		iplist[num_srv_addrs+i].ss = dns_addrs[i];
+		iplist[i].port = 0;
+	}
+
+	TALLOC_FREE(dcs);
+	TALLOC_FREE(srv_addrs);
+	TALLOC_FREE(dns_addrs);
+	TALLOC_FREE(dns_lookup_names);
+
+	*return_iplist = iplist;
+	*return_count = numaddrs;
 	return NT_STATUS_OK;
 }
 
-- 
2.20.1


From f626e211ba9138a5f5c3e7eed487c31d1becfb62 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:17:54 -0700
Subject: [PATCH 45/60] s3: libsmb: Change resolve_ads() to return a talloc'ed
 ss_list, matching the other name resolution methods.

Now we can move all the convert_ss2service() calls to one place.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 46 +++++++++++++++++++++++++-------------
 1 file changed, 30 insertions(+), 16 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 842f82264ba..473eeb92436 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2450,7 +2450,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 			    const char *name,
 			    int name_type,
 			    const char *sitename,
-			    struct ip_service **return_iplist,
+			    struct sockaddr_storage **return_addrs,
 			    int *return_count)
 {
 	int 			i;
@@ -2464,7 +2464,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	struct sockaddr_storage *dns_addrs = NULL;
 	size_t num_dns_names = 0;
 	const char **dns_lookup_names = NULL;
-	struct ip_service *iplist = NULL;
+	struct sockaddr_storage *ret_addrs = NULL;
 
 	if ((name_type != 0x1c) && (name_type != KDC_NAME_TYPE) &&
 	    (name_type != 0x1b)) {
@@ -2511,7 +2511,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 
 	if (numdcs == 0) {
 		TALLOC_FREE(dcs);
-		*return_iplist = NULL;
+		*return_addrs = NULL;
 		*return_count = 0;
 		return NT_STATUS_OK;
 	}
@@ -2529,7 +2529,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	 * hostnames -> IP address. This is dns_addrs.
 	 *
 	 * Finally we will merge these two arrays to create the
-	 * return ip_service array.
+	 * return sockaddr_storage array.
 	 */
 
 	/* First count the sizes of each array. */
@@ -2638,9 +2638,9 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	}
 
 	/*
-	 * Combine the two sockaddr_storage arrays into a MALLOC'ed
-	 * ipservice array return.
-	 */
+	 * Combine the two sockaddr_storage arrays into a talloc'ed
+	 * struct sockaddr_storage array return.
+         */
 
 	numaddrs = num_srv_addrs + num_dns_addrs;
 	/* Wrap check + bloody int conversion check :-(. */
@@ -2653,8 +2653,10 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	iplist = SMB_MALLOC_ARRAY(struct ip_service, numaddrs);
-	if (iplist == NULL) {
+	ret_addrs = talloc_zero_array(ctx,
+				struct sockaddr_storage,
+				numaddrs);
+	if (ret_addrs == NULL) {
 		TALLOC_FREE(dcs);
 		TALLOC_FREE(srv_addrs);
 		TALLOC_FREE(dns_addrs);
@@ -2663,12 +2665,10 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	}
 
 	for (i = 0; i < num_srv_addrs; i++) {
-		iplist[i].ss = srv_addrs[i];
-		iplist[i].port = 0;
+		ret_addrs[i] = srv_addrs[i];
 	}
 	for (i = 0; i < num_dns_addrs; i++) {
-		iplist[num_srv_addrs+i].ss = dns_addrs[i];
-		iplist[i].port = 0;
+		ret_addrs[num_srv_addrs+i] = dns_addrs[i];
 	}
 
 	TALLOC_FREE(dcs);
@@ -2676,7 +2676,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	TALLOC_FREE(dns_addrs);
 	TALLOC_FREE(dns_lookup_names);
 
-	*return_iplist = iplist;
+	*return_addrs = ret_addrs;
 	*return_count = numaddrs;
 	return NT_STATUS_OK;
 }
@@ -2835,11 +2835,12 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     KDC_NAME_TYPE,
 					     sitename,
-					     return_iplist,
+					     &ss_list,
 					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
@@ -2847,19 +2848,32 @@ NTSTATUS internal_resolve_name(const char *name,
 			/* Ensure we don't namecache
 			 * this with the KDC port. */
 			name_type = KDC_NAME_TYPE;
+			ok = convert_ss2service(return_iplist,
+						ss_list,
+						return_count);
+			if (!ok) {
+				status = NT_STATUS_NO_MEMORY;
+			}
 			goto done;
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
+			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     name_type,
 					     sitename,
-					     return_iplist,
+					     &ss_list,
 					     return_count);
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
+			ok = convert_ss2service(return_iplist,
+						ss_list,
+						return_count);
+			if (!ok) {
+				status = NT_STATUS_NO_MEMORY;
+			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
 			struct sockaddr_storage *ss_list = NULL;
-- 
2.20.1


From d8a94cd58d8417ba83f10dfe18b3a8461b33de85 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:40:02 -0700
Subject: [PATCH 46/60] s3: libsmb: Now all resolution functions return a
 ss_list on success, we only need one local variable for this.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 473eeb92436..8cbbafd9b4f 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2735,6 +2735,7 @@ NTSTATUS internal_resolve_name(const char *name,
 	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
 	int i;
 	bool ok;
+	struct sockaddr_storage *ss_list = NULL;
 	TALLOC_CTX *frame = NULL;
 
 	*return_iplist = NULL;
@@ -2815,7 +2816,6 @@ NTSTATUS internal_resolve_name(const char *name,
 		tok = resolve_order[i];
 
 		if((strequal(tok, "host") || strequal(tok, "hosts"))) {
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_hosts(talloc_tos(),
 					       name,
 					       name_type,
@@ -2835,7 +2835,6 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
 			 * This will result in a SRV record lookup */
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     KDC_NAME_TYPE,
@@ -2858,7 +2857,6 @@ NTSTATUS internal_resolve_name(const char *name,
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
 			 * This will result in a SRV record lookup */
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_ads(talloc_tos(),
 					     name,
 					     name_type,
@@ -2876,7 +2874,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
-			struct sockaddr_storage *ss_list = NULL;
 			status = resolve_lmhosts_file_as_sockaddr(
 				talloc_tos(),
 				get_dyn_LMHOSTSFILE(),
@@ -2897,7 +2894,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
-			struct sockaddr_storage *ss_list = NULL;
 			if (name_type == 0x1D) {
 				continue;
 			}
@@ -2918,7 +2914,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			}
 			goto done;
 		} else if (strequal(tok, "bcast")) {
-			struct sockaddr_storage *ss_list = NULL;
 			status = name_resolve_bcast(
 						talloc_tos(),
 						name,
-- 
2.20.1


From 2b76ac6a75660112f2e559bf3f5f5ca2748530a1 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Mon, 20 Jul 2020 20:52:58 -0700
Subject: [PATCH 47/60] s3: libsmb: Move all calls to convert_ss2service() to
 one place now all methods return a sockaddr_storage.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 50 ++++++--------------------------------
 1 file changed, 8 insertions(+), 42 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 8cbbafd9b4f..f1d10bda593 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2824,13 +2824,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else if(strequal( tok, "kdc")) {
 			/* deal with KDC_NAME_TYPE names here.
@@ -2847,12 +2840,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			/* Ensure we don't namecache
 			 * this with the KDC port. */
 			name_type = KDC_NAME_TYPE;
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-			}
 			goto done;
 		} else if(strequal( tok, "ads")) {
 			/* deal with 0x1c and 0x1b names here.
@@ -2866,12 +2853,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-			}
 			goto done;
 		} else if (strequal(tok, "lmhosts")) {
 			status = resolve_lmhosts_file_as_sockaddr(
@@ -2884,13 +2865,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else if (strequal(tok, "wins")) {
 			/* don't resolve 1D via WINS */
@@ -2905,13 +2879,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else if (strequal(tok, "bcast")) {
 			status = name_resolve_bcast(
@@ -2923,13 +2890,6 @@ NTSTATUS internal_resolve_name(const char *name,
 			if (!NT_STATUS_IS_OK(status)) {
 				continue;
 			}
-			ok = convert_ss2service(return_iplist,
-						ss_list,
-						return_count);
-			if (!ok) {
-				status = NT_STATUS_NO_MEMORY;
-				goto fail;
-			}
 			goto done;
 		} else {
 			DBG_ERR("unknown name switch type %s\n",
@@ -2939,8 +2899,6 @@ NTSTATUS internal_resolve_name(const char *name,
 
 	/* All of the resolve_* functions above have returned false. */
 
-  fail:
-
 	TALLOC_FREE(frame);
 	SAFE_FREE(*return_iplist);
 	*return_count = 0;
@@ -2949,6 +2907,14 @@ NTSTATUS internal_resolve_name(const char *name,
 
   done:
 
+	ok = convert_ss2service(return_iplist, ss_list, return_count);
+	if (!ok) {
+		TALLOC_FREE(frame);
+		SAFE_FREE(*return_iplist);
+		*return_count = 0;
+		return NT_STATUS_NO_MEMORY;
+	}
+
 	/* Remove duplicate entries.  Some queries, notably #1c (domain
 	controllers) return the PDC in iplist[0] and then all domain
 	controllers including the PDC in iplist[1..n].  Iterating over
-- 
2.20.1


From 507d7fc99ac285c5c1eac0f0731dc00a7b2f42e5 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 17 Jul 2020 14:21:09 -0700
Subject: [PATCH 48/60] lib: addns: Add code for asynchronously looking up A
 records.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 lib/addns/dnsquery.c | 195 +++++++++++++++++++++++++++++++++++++++++++
 lib/addns/dnsquery.h |  15 ++++
 2 files changed, 210 insertions(+)

diff --git a/lib/addns/dnsquery.c b/lib/addns/dnsquery.c
index 87ae97e3d0b..68101597242 100644
--- a/lib/addns/dnsquery.c
+++ b/lib/addns/dnsquery.c
@@ -369,6 +369,201 @@ fail:
 	return status;
 }
 
+/*********************************************************************
+ Async A record lookup.
+*********************************************************************/
+
+struct ads_dns_lookup_a_state {
+	uint8_t rcode;
+	size_t num_names;
+	char **hostnames;
+	struct sockaddr_storage *addrs;
+};
+
+static void ads_dns_lookup_a_done(struct tevent_req *subreq);
+
+struct tevent_req *ads_dns_lookup_a_send(TALLOC_CTX *mem_ctx,
+					 struct tevent_context *ev,
+					 const char *name)
+{
+	struct tevent_req *req, *subreq;
+	struct ads_dns_lookup_a_state *state;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct ads_dns_lookup_a_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	subreq = dns_lookup_send(
+		state,
+		ev,
+		NULL,
+		name,
+		DNS_QCLASS_IN,
+		DNS_QTYPE_A);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(subreq, ads_dns_lookup_a_done, req);
+	return req;
+}
+
+static void ads_dns_lookup_a_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct ads_dns_lookup_a_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_a_state);
+	int ret;
+	struct dns_name_packet *reply;
+	uint16_t i;
+
+	ret = dns_lookup_recv(subreq, state, &reply);
+	TALLOC_FREE(subreq);
+	if (ret != 0) {
+		tevent_req_nterror(req, map_nt_error_from_unix_common(ret));
+		return;
+	}
+
+	state->rcode = (reply->operation & DNS_RCODE);
+	if (state->rcode != DNS_RCODE_OK) {
+		/* Don't bother looking for answers. */
+		tevent_req_done(req);
+		return;
+	}
+
+	/*
+	 * We don't care about CNAME answers here. We're
+	 * just wanting an async name -> IPv4 lookup.
+	 */
+	for (i=0; i<reply->ancount; i++) {
+		if (reply->answers[i].rr_type == DNS_QTYPE_A) {
+			state->num_names += 1;
+		}
+	}
+
+	state->hostnames = talloc_zero_array(state,
+					     char *,
+					     state->num_names);
+	if (tevent_req_nomem(state->hostnames, req)) {
+		return;
+	}
+	state->addrs = talloc_zero_array(state,
+					 struct sockaddr_storage,
+					 state->num_names);
+	if (tevent_req_nomem(state->addrs, req)) {
+		return;
+	}
+
+	state->num_names = 0;
+
+	for (i=0; i<reply->ancount; i++) {
+		bool ok;
+		struct dns_res_rec *an = &reply->answers[i];
+
+		if (an->rr_type != DNS_QTYPE_A) {
+			continue;
+		}
+		if (an->name == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		if (an->rdata.ipv4_record == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		state->hostnames[state->num_names] = talloc_strdup(
+							state->hostnames,
+							an->name);
+		if (tevent_req_nomem(state->hostnames[state->num_names], req)) {
+			return;
+		}
+		ok = dns_res_rec_get_sockaddr(an,
+					      &state->addrs[state->num_names]);
+		if (!ok) {
+			continue;
+		}
+		state->num_names += 1;
+	}
+
+	tevent_req_done(req);
+}
+
+NTSTATUS ads_dns_lookup_a_recv(struct tevent_req *req,
+			       TALLOC_CTX *mem_ctx,
+			       uint8_t *rcode_out,
+			       size_t *num_names_out,
+			       char ***hostnames_out,
+			       struct sockaddr_storage **addrs_out)
+{
+	struct ads_dns_lookup_a_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_a_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
+	}
+	if (rcode_out != NULL) {
+		/*
+		 * If we got no names, an upper layer may
+		 * want to print a debug message.
+		 */
+		*rcode_out = state->rcode;
+	}
+	if (hostnames_out != NULL) {
+		*hostnames_out = talloc_move(mem_ctx,
+					     &state->hostnames);
+	}
+	if (addrs_out != NULL) {
+		*addrs_out = talloc_move(mem_ctx,
+					 &state->addrs);
+	}
+	*num_names_out = state->num_names;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+/*********************************************************************
+ Simple wrapper for a DNS A query
+*********************************************************************/
+
+NTSTATUS ads_dns_lookup_a(TALLOC_CTX *ctx,
+			  const char *name_in,
+			  size_t *num_names_out,
+			  char ***hostnames_out,
+			  struct sockaddr_storage **addrs_out)
+{
+	struct tevent_context *ev;
+	struct tevent_req *req;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	ev = samba_tevent_context_init(ctx);
+	if (ev == NULL) {
+		goto fail;
+	}
+	req = ads_dns_lookup_a_send(ev, ev, name_in);
+	if (req == NULL) {
+		goto fail;
+	}
+	if (!tevent_req_poll_ntstatus(req, ev, &status)) {
+		goto fail;
+	}
+	/*
+	 * Sychronous doesn't need to care about the rcode or
+	 * a copy of the name_in.
+	 */
+	status = ads_dns_lookup_a_recv(req,
+				       ctx,
+				       NULL,
+				       num_names_out,
+				       hostnames_out,
+				       addrs_out);
+fail:
+	TALLOC_FREE(ev);
+	return status;
+}
 
 /********************************************************************
  Query with optional sitename.
diff --git a/lib/addns/dnsquery.h b/lib/addns/dnsquery.h
index bb691f5d55a..229b2134ff7 100644
--- a/lib/addns/dnsquery.h
+++ b/lib/addns/dnsquery.h
@@ -48,6 +48,21 @@ NTSTATUS ads_dns_lookup_ns(TALLOC_CTX *ctx,
 				const char *dnsdomain,
 				struct dns_rr_ns **nslist,
 				int *numns);
+struct tevent_req *ads_dns_lookup_a_send(TALLOC_CTX *mem_ctx,
+				struct tevent_context *ev,
+				const char *name);
+NTSTATUS ads_dns_lookup_a_recv(struct tevent_req *req,
+				TALLOC_CTX *mem_ctx,
+				uint8_t *rcode_out,
+				size_t *num_names_out,
+				char ***hostnames_out,
+				struct sockaddr_storage **addrs_out);
+NTSTATUS ads_dns_lookup_a(TALLOC_CTX *ctx,
+			const char *name_in,
+			size_t *num_names_out,
+			char ***hostnames_out,
+			struct sockaddr_storage **addrs_out);
+
 NTSTATUS ads_dns_query_dcs(TALLOC_CTX *ctx,
 			   const char *realm,
 			   const char *sitename,
-- 
2.20.1


From 8e84e6dee9d5751507ccb649e5fda104fc78a3aa Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 17 Jul 2020 14:30:02 -0700
Subject: [PATCH 49/60] lib: addns: Add code for asynchronously looking up AAAA
 records.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 lib/addns/dnsquery.c | 198 +++++++++++++++++++++++++++++++++++++++++++
 lib/addns/dnsquery.h |  16 ++++
 2 files changed, 214 insertions(+)

diff --git a/lib/addns/dnsquery.c b/lib/addns/dnsquery.c
index 68101597242..b91bcbe357c 100644
--- a/lib/addns/dnsquery.c
+++ b/lib/addns/dnsquery.c
@@ -565,6 +565,204 @@ fail:
 	return status;
 }
 
+#if defined(HAVE_IPV6)
+/*********************************************************************
+ Async AAAA record lookup.
+*********************************************************************/
+
+struct ads_dns_lookup_aaaa_state {
+	uint8_t rcode;
+	size_t num_names;
+	char **hostnames;
+	struct sockaddr_storage *addrs;
+};
+
+static void ads_dns_lookup_aaaa_done(struct tevent_req *subreq);
+
+struct tevent_req *ads_dns_lookup_aaaa_send(TALLOC_CTX *mem_ctx,
+					    struct tevent_context *ev,
+					    const char *name)
+{
+	struct tevent_req *req, *subreq;
+	struct ads_dns_lookup_aaaa_state *state;
+
+	req = tevent_req_create(mem_ctx, &state,
+				struct ads_dns_lookup_aaaa_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	subreq = dns_lookup_send(
+		state,
+		ev,
+		NULL,
+		name,
+		DNS_QCLASS_IN,
+		DNS_QTYPE_AAAA);
+
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
+	}
+	tevent_req_set_callback(subreq, ads_dns_lookup_aaaa_done, req);
+	return req;
+}
+
+static void ads_dns_lookup_aaaa_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req = tevent_req_callback_data(
+		subreq, struct tevent_req);
+	struct ads_dns_lookup_aaaa_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_aaaa_state);
+	int ret;
+	struct dns_name_packet *reply;
+	uint16_t i;
+
+	ret = dns_lookup_recv(subreq, state, &reply);
+	TALLOC_FREE(subreq);
+	if (ret != 0) {
+		tevent_req_nterror(req, map_nt_error_from_unix_common(ret));
+		return;
+	}
+
+	state->rcode = (reply->operation & DNS_RCODE);
+	if (state->rcode != DNS_RCODE_OK) {
+		/* Don't bother looking for answers. */
+		tevent_req_done(req);
+		return;
+	}
+
+	/*
+	 * We don't care about CNAME answers here. We're
+	 * just wanting an async name -> IPv6 lookup.
+	 */
+	for (i=0; i<reply->ancount; i++) {
+		if (reply->answers[i].rr_type == DNS_QTYPE_AAAA) {
+			state->num_names += 1;
+		}
+	}
+
+	state->hostnames = talloc_zero_array(state,
+					     char *,
+					     state->num_names);
+	if (tevent_req_nomem(state->hostnames, req)) {
+		return;
+	}
+	state->addrs = talloc_zero_array(state,
+					 struct sockaddr_storage,
+					 state->num_names);
+	if (tevent_req_nomem(state->addrs, req)) {
+		return;
+	}
+
+	state->num_names = 0;
+
+	for (i=0; i<reply->ancount; i++) {
+		bool ok;
+		struct dns_res_rec *an = &reply->answers[i];
+
+		if (an->rr_type != DNS_QTYPE_AAAA) {
+			continue;
+		}
+		if (an->name == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		if (an->rdata.ipv6_record == NULL) {
+			/* Can this happen? */
+			continue;
+		}
+		state->hostnames[state->num_names] = talloc_strdup(
+							state->hostnames,
+							an->name);
+		if (tevent_req_nomem(state->hostnames[state->num_names], req)) {
+			return;
+		}
+		ok = dns_res_rec_get_sockaddr(an,
+					      &state->addrs[state->num_names]);
+		if (!ok) {
+			continue;
+		}
+		state->num_names += 1;
+	}
+
+	tevent_req_done(req);
+}
+
+NTSTATUS ads_dns_lookup_aaaa_recv(struct tevent_req *req,
+				  TALLOC_CTX *mem_ctx,
+				  uint8_t *rcode_out,
+				  size_t *num_names_out,
+				  char ***hostnames_out,
+				  struct sockaddr_storage **addrs_out)
+{
+	struct ads_dns_lookup_aaaa_state *state = tevent_req_data(
+		req, struct ads_dns_lookup_aaaa_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		return status;
+	}
+	if (rcode_out != NULL) {
+		/*
+		 * If we got no names, an upper layer may
+		 * want to print a debug message.
+		 */
+		*rcode_out = state->rcode;
+	}
+	if (hostnames_out != NULL) {
+		*hostnames_out = talloc_move(mem_ctx,
+					     &state->hostnames);
+	}
+	if (addrs_out != NULL) {
+		*addrs_out = talloc_move(mem_ctx,
+					 &state->addrs);
+	}
+	*num_names_out = state->num_names;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+/*********************************************************************
+ Simple wrapper for a DNS AAAA query
+*********************************************************************/
+
+NTSTATUS ads_dns_lookup_aaaa(TALLOC_CTX *ctx,
+			     const char *name_in,
+			     size_t *num_names_out,
+			     char ***hostnames_out,
+			     struct sockaddr_storage **addrs_out)
+{
+	struct tevent_context *ev;
+	struct tevent_req *req;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	ev = samba_tevent_context_init(ctx);
+	if (ev == NULL) {
+		goto fail;
+	}
+	req = ads_dns_lookup_aaaa_send(ev, ev, name_in);
+	if (req == NULL) {
+		goto fail;
+	}
+	if (!tevent_req_poll_ntstatus(req, ev, &status)) {
+		goto fail;
+	}
+	/*
+	 * Sychronous doesn't need to care about the rcode or
+	 * a copy of the name_in.
+	 */
+	status = ads_dns_lookup_aaaa_recv(req,
+					  ctx,
+					  NULL,
+					  num_names_out,
+					  hostnames_out,
+					  addrs_out);
+fail:
+	TALLOC_FREE(ev);
+	return status;
+}
+#endif
+
 /********************************************************************
  Query with optional sitename.
 ********************************************************************/
diff --git a/lib/addns/dnsquery.h b/lib/addns/dnsquery.h
index 229b2134ff7..c7d397172f0 100644
--- a/lib/addns/dnsquery.h
+++ b/lib/addns/dnsquery.h
@@ -62,6 +62,22 @@ NTSTATUS ads_dns_lookup_a(TALLOC_CTX *ctx,
 			size_t *num_names_out,
 			char ***hostnames_out,
 			struct sockaddr_storage **addrs_out);
+#if defined(HAVE_IPV6)
+struct tevent_req *ads_dns_lookup_aaaa_send(TALLOC_CTX *mem_ctx,
+				struct tevent_context *ev,
+				const char *name);
+NTSTATUS ads_dns_lookup_aaaa_recv(struct tevent_req *req,
+				TALLOC_CTX *mem_ctx,
+				uint8_t *rcode_out,
+				size_t *num_names_out,
+				char ***hostnames_out,
+				struct sockaddr_storage **addrs_out);
+NTSTATUS ads_dns_lookup_aaaa(TALLOC_CTX *ctx,
+			const char *name_in,
+			size_t *num_names_out,
+			char ***hostnames_out,
+			struct sockaddr_storage **addrs_out);
+#endif
 
 NTSTATUS ads_dns_query_dcs(TALLOC_CTX *ctx,
 			   const char *realm,
-- 
2.20.1


From 5eaf8a5aa07b530054f0f94e96377f9baa93a1fe Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Fri, 17 Jul 2020 14:45:45 -0700
Subject: [PATCH 50/60] WIP: Test harness for async DNS - not really thought
 out.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/utils/net_ads.c | 82 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 82 insertions(+)

diff --git a/source3/utils/net_ads.c b/source3/utils/net_ads.c
index 19ac9e4533f..11128129ff9 100644
--- a/source3/utils/net_ads.c
+++ b/source3/utils/net_ads.c
@@ -2211,6 +2211,80 @@ static int net_ads_dns_gethostbyname(struct net_context *c, int argc, const char
 	return 0;
 }
 
+static int net_ads_dns_testasync(struct net_context *c, int argc, const char **argv)
+{
+	size_t num_names = 0;
+	char **hostnames;
+	size_t i = 0;
+	struct sockaddr_storage *addrs = NULL;
+	NTSTATUS status;
+
+	if (argc != 1 || c->display_usage) {
+		d_printf(  "%s\n"
+			   "    %s\n"
+			   "    %s\n",
+			 _("Usage:"),
+			 _("net ads dns testasync <name>\n"),
+			 _("  Async look up hostname from the DNS server\n"
+			   "    hostname\tName to look up\n"));
+		return -1;
+	}
+
+	status = ads_dns_lookup_a(talloc_tos(),
+					   argv[0],
+					   &num_names,
+					   &hostnames,
+					   &addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		d_printf("Looking up A record for %s got error %s\n",
+			 argv[0],
+			 nt_errstr(status));
+		return -1;
+	}
+	d_printf("Async A record lookup - got %u names for %s\n",
+		 (unsigned int)num_names,
+		 argv[0]);
+	for (i = 0; i < num_names; i++) {
+		char addr_buf[INET6_ADDRSTRLEN];
+		print_sockaddr(addr_buf,
+			       sizeof(addr_buf),
+			       &addrs[i]);
+		d_printf("hostname[%u] = %s, addr = %s\n",
+			(unsigned int)i,
+			hostnames[i],
+			addr_buf);
+	}
+
+#if defined(HAVE_IPV6)
+	status = ads_dns_lookup_aaaa(talloc_tos(),
+					   argv[0],
+					   &num_names,
+					   &hostnames,
+					   &addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		d_printf("Looking up AAAA record for %s got error %s\n",
+			 argv[0],
+			 nt_errstr(status));
+		return -1;
+	}
+	d_printf("Async AAAA record lookup - got %u names for %s\n",
+		 (unsigned int)num_names,
+		 argv[0]);
+	for (i = 0; i < num_names; i++) {
+		char addr_buf[INET6_ADDRSTRLEN];
+		print_sockaddr(addr_buf,
+			       sizeof(addr_buf),
+			       &addrs[i]);
+		d_printf("hostname[%u] = %s, addr = %s\n",
+			(unsigned int)i,
+			hostnames[i],
+			addr_buf);
+	}
+#endif
+	return 0;
+}
+
+
 static int net_ads_dns(struct net_context *c, int argc, const char *argv[])
 {
 	struct functable func[] = {
@@ -2238,6 +2312,14 @@ static int net_ads_dns(struct net_context *c, int argc, const char *argv[])
 			N_("net ads dns gethostbyname\n"
 			   "    Look up host")
 		},
+		{
+			"testasync",
+			net_ads_dns_testasync,
+			NET_TRANSPORT_ADS,
+			N_("Look up host"),
+			N_("net ads dns testasync\n"
+			   "    Look up host")
+		},
 		{NULL, NULL, 0, NULL, NULL}
 	};
 
-- 
2.20.1


From ad954019a679c0dc2e8afe3562165a7dd51b11c3 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 12:34:02 -0700
Subject: [PATCH 51/60] s3: libsmb: Add dns_lookup_list_async().

Take a list of hostnames and does async A and AAAA (if
supported) lookups on them. Interface compatible with
dns_lookup_list() and we'll replace it in the next
commit.

Commented out as not yet used.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 321 +++++++++++++++++++++++++++++++++++++
 1 file changed, 321 insertions(+)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index f1d10bda593..c963fe62b33 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -31,6 +31,7 @@
 #include "../libcli/nbt/libnbt.h"
 #include "libads/kerberos_proto.h"
 #include "lib/gencache.h"
+#include "librpc/gen_ndr/dns.h"
 
 /* nmbd.c sets this to True. */
 bool global_in_nmbd = False;
@@ -2270,6 +2271,326 @@ fail:
 	return status;
 }
 
+#if 0
+/********************************************************
+ Use ads_dns_lookup_[a|aaaa]_send() calls to look up a
+ list of names asynchronously.
+*********************************************************/
+
+struct dns_query_state {
+	/* Used to tell our parent we've completed. */
+	struct dns_lookup_list_async_state *p_async_state;
+	const char *query_name; /* For debugging only. */
+	size_t num_addrs;
+	struct sockaddr_storage *addrs;
+};
+
+struct dns_lookup_list_async_state {
+	bool timed_out;
+	size_t num_query_returns;
+	struct dns_query_state *queries;
+};
+
+/* Called on query timeout. */
+static void dns_lookup_send_timeout_handler(struct tevent_context *ev,
+					    struct tevent_timer *te,
+					    struct timeval t,
+					    void *private_data)
+{
+	bool *timed_out = (bool *)private_data;
+	*timed_out = true;
+}
+
+static void dns_lookup_list_a_done(struct tevent_req *req);
+#if defined(HAVE_IPV6)
+static void dns_lookup_list_aaaa_done(struct tevent_req *req);
+#endif
+
+static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
+				      size_t num_dns_names,
+				      const char **dns_lookup_names,
+				      size_t *p_num_addrs,
+				      struct sockaddr_storage **pp_addrs)
+{
+	struct dns_lookup_list_async_state *state = NULL;
+	struct tevent_context *ev = NULL;
+	struct tevent_req *req;
+	struct tevent_timer *timer;
+	size_t num_queries_sent = 0;
+	size_t queries_size = num_dns_names;
+	size_t i;
+	size_t num_addrs = 0;
+	struct sockaddr_storage *addr_out = NULL;
+	NTSTATUS status = NT_STATUS_NO_MEMORY;
+
+	/* Nothing to do. */
+	if (num_dns_names == 0) {
+		*p_num_addrs = 0;
+		*pp_addrs = NULL;
+		return NT_STATUS_OK;
+	}
+
+	state = talloc_zero(ctx, struct dns_lookup_list_async_state);
+	if (state == NULL) {
+		goto fail;
+	}
+	ev = samba_tevent_context_init(ctx);
+	if (ev == NULL) {
+		goto fail;
+	}
+
+#if defined(HAVE_IPV6)
+	queries_size = 2 * num_dns_names;
+	/* Wrap protection. */
+	if (queries_size < num_dns_names) {
+		goto fail;
+	}
+#else
+	queries_size = num_dns_names;
+#endif
+
+	state->queries = talloc_zero_array(state,
+					   struct dns_query_state,
+					   queries_size);
+	if (state == NULL) {
+		goto fail;
+	}
+
+	/* Hit all the DNS servers with asnyc lookups for all the names. */
+	for (i = 0; i < num_dns_names; i++) {
+		DBG_INFO("async DNS lookup A record for %s\n",
+			dns_lookup_names[i]);
+
+		/* Setup the query state. */
+		state->queries[num_queries_sent].query_name =
+					dns_lookup_names[i];
+		state->queries[num_queries_sent].p_async_state = state;
+
+		req = ads_dns_lookup_a_send(ev, ev, dns_lookup_names[i]);
+		if (req == NULL) {
+			goto fail;
+		}
+		tevent_req_set_callback(req,
+				dns_lookup_list_a_done,
+				&state->queries[num_queries_sent]);
+		num_queries_sent++;
+
+#if defined(HAVE_IPV6)
+		/* If we're IPv6 capable ask for that too. */
+		state->queries[num_queries_sent].query_name =
+					dns_lookup_names[i];
+		state->queries[num_queries_sent].p_async_state = state;
+
+		DBG_INFO("async DNS lookup AAAA record for %s\n",
+			dns_lookup_names[i]);
+
+		req = ads_dns_lookup_aaaa_send(ev, ev, dns_lookup_names[i]);
+		if (req == NULL) {
+			goto fail;
+		}
+		tevent_req_set_callback(req,
+					dns_lookup_list_aaaa_done,
+					&state->queries[num_queries_sent]);
+		num_queries_sent++;
+#endif
+	}
+
+	/* Set a 10 second timeout. FIXME - lp_dns_timeout() ? */
+	timer = tevent_add_timer(ev,
+				 ev,
+				 timeval_current_ofs(10, 0),
+				 dns_lookup_send_timeout_handler,
+				 &state->timed_out);
+	if (timer == NULL) {
+		goto fail;
+	}
+
+	/* Loop until timed out or got all replies. */
+	while (1) {
+		int ret;
+
+		if (state->timed_out) {
+			break;
+		}
+		if (state->num_query_returns == num_queries_sent) {
+			break;
+		}
+		ret = tevent_loop_once(ev);
+		if (ret != 0) {
+			goto fail;
+		}
+	}
+
+	/* Count what we got back. */
+	for (i = 0; i < num_queries_sent; i++) {
+		struct dns_query_state *query = &state->queries[i];
+
+		/* Wrap check. */
+		if (num_addrs + query->num_addrs < num_addrs) {
+			goto fail;
+		}
+		num_addrs += query->num_addrs;
+	}
+
+	if (state->timed_out) {
+		DBG_INFO("async DNS lookup timed out after %zu entries "
+			"(not an error)\n",
+			num_addrs);
+	}
+
+	addr_out = talloc_zero_array(ctx,
+				     struct sockaddr_storage,
+				     num_addrs);
+	if (addr_out == NULL) {
+		goto fail;
+	}
+
+	/* Copy what we got back. */
+	num_addrs = 0;
+	for (i = 0; i < num_queries_sent; i++) {
+		struct dns_query_state *query = &state->queries[i];
+
+		memcpy(&addr_out[num_addrs],
+			query->addrs,
+			query->num_addrs * sizeof(query->addrs[0]));
+		num_addrs += query->num_addrs;
+	}
+
+	*p_num_addrs = num_addrs;
+	*pp_addrs = addr_out;
+
+	status = NT_STATUS_OK;
+
+  fail:
+
+	TALLOC_FREE(state);
+	TALLOC_FREE(ev);
+	return status;
+}
+
+/*
+ Called when an A record lookup completes.
+*/
+
+static void dns_lookup_list_a_done(struct tevent_req *req)
+{
+	/*
+	 * Callback data is an element of a talloc'ed array,
+	 * not a talloc object in its own right. So use the
+	 * tevent_req_callback_data_void() void * cast function.
+	 */
+	struct dns_query_state *state = (struct dns_query_state *)
+				tevent_req_callback_data_void(req);
+	uint8_t rcode = 0;
+	size_t i;
+	char **hostnames_out = NULL;
+	NTSTATUS status;
+
+	/* For good or ill, tell the parent we're finished. */
+	state->p_async_state->num_query_returns++;
+
+	status = ads_dns_lookup_a_recv(req,
+				       state->p_async_state,
+				       &rcode,
+				       &state->num_addrs,
+				       &hostnames_out,
+				       &state->addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_INFO("async DNS A lookup for %s returned %s\n",
+			state->query_name,
+			nt_errstr(status));
+		return;
+	}
+
+	if (rcode != DNS_RCODE_OK) {
+		DBG_INFO("async DNS A lookup for %s returned DNS code %u\n",
+			state->query_name,
+			(unsigned int)rcode);
+		return;
+	}
+
+	if (state->num_addrs == 0) {
+		DBG_INFO("async DNS A lookup for %s returned 0 addresses.\n",
+			state->query_name);
+		return;
+	}
+
+	/* Debug print. */
+	for (i = 0; i < state->num_addrs; i++) {
+		char addr[INET6_ADDRSTRLEN];
+		DBG_INFO("async DNS A lookup for %s [%zu] got %s -> %s\n",
+			state->query_name,
+			i,
+			hostnames_out[i],
+			print_sockaddr(addr,
+				sizeof(addr),
+				&state->addrs[i]));
+	}
+}
+
+#if defined(HAVE_IPV6)
+/*
+ Called when an AAAA record lookup completes.
+*/
+
+static void dns_lookup_list_aaaa_done(struct tevent_req *req)
+{
+	/*
+	 * Callback data is an element of a talloc'ed array,
+	 * not a talloc object in its own right. So use the
+	 * tevent_req_callback_data_void() void * cast function.
+	 */
+	struct dns_query_state *state = (struct dns_query_state *)
+				tevent_req_callback_data_void(req);
+	uint8_t rcode = 0;
+	size_t i;
+	char **hostnames_out = NULL;
+	NTSTATUS status;
+
+	/* For good or ill, tell the parent we're finished. */
+	state->p_async_state->num_query_returns++;
+
+	status = ads_dns_lookup_aaaa_recv(req,
+					  state->p_async_state,
+					  &rcode,
+					  &state->num_addrs,
+					  &hostnames_out,
+					  &state->addrs);
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_INFO("async DNS AAAA lookup for %s returned %s\n",
+			state->query_name,
+			nt_errstr(status));
+		return;
+	}
+
+	if (rcode != DNS_RCODE_OK) {
+		DBG_INFO("async DNS AAAA lookup for %s returned DNS code %u\n",
+			state->query_name,
+			(unsigned int)rcode);
+		return;
+	}
+
+	if (state->num_addrs == 0) {
+		DBG_INFO("async DNS AAAA lookup for %s returned 0 addresses.\n",
+			state->query_name);
+		return;
+	}
+
+	/* Debug print. */
+	for (i = 0; i < state->num_addrs; i++) {
+		char addr[INET6_ADDRSTRLEN];
+		DBG_INFO("async DNS AAAA lookup for %s [%zu] got %s -> %s\n",
+			state->query_name,
+			i,
+			hostnames_out[i],
+			print_sockaddr(addr,
+				sizeof(addr),
+				&state->addrs[i]));
+	}
+}
+#endif
+#endif
+
 /********************************************************
  Resolve a list of DNS names to a list of IP addresses.
  As this is a DC / LDAP / KDC lookup any IP address will
-- 
2.20.1


From 88b3da02ff676f9100bfd995487f391ecb07c56f Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 12:38:42 -0700
Subject: [PATCH 52/60] s3: libsmb: Use dns_lookup_list_async() instead of
 dns_lookup_list().

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index c963fe62b33..1c1131c67fd 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2271,7 +2271,6 @@ fail:
 	return status;
 }
 
-#if 0
 /********************************************************
  Use ads_dns_lookup_[a|aaaa]_send() calls to look up a
  list of names asynchronously.
@@ -2589,8 +2588,8 @@ static void dns_lookup_list_aaaa_done(struct tevent_req *req)
 	}
 }
 #endif
-#endif
 
+#if 0
 /********************************************************
  Resolve a list of DNS names to a list of IP addresses.
  As this is a DC / LDAP / KDC lookup any IP address will
@@ -2671,6 +2670,7 @@ static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
 	*pp_addrs = ret_addrs;
 	return NT_STATUS_OK;
 }
+#endif
 
 /********************************************************
  Resolve via "hosts" method.
@@ -2945,7 +2945,7 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 	}
 
 	/* Lookup the addresses on the dns_lookup_list. */
-	status = dns_lookup_list(ctx,
+	status = dns_lookup_list_async(ctx,
 				num_dns_names,
 				dns_lookup_names,
 				&num_dns_addrs,
-- 
2.20.1


From e912343175e6c060bf0916e1f5bf57cdcdfe439e Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 22 Jul 2020 19:09:21 -0700
Subject: [PATCH 53/60] s3: libsmb: Remove dns_lookup_list(). No longer used.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 83 --------------------------------------
 1 file changed, 83 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 1c1131c67fd..4e0ab397c2c 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2589,89 +2589,6 @@ static void dns_lookup_list_aaaa_done(struct tevent_req *req)
 }
 #endif
 
-#if 0
-/********************************************************
- Resolve a list of DNS names to a list of IP addresses.
- As this is a DC / LDAP / KDC lookup any IP address will
- do, the requested names don't have to match the returned
- IP address list.
-*********************************************************/
-
-static NTSTATUS dns_lookup_list(TALLOC_CTX *ctx,
-				size_t num_dns_names,
-				const char **dns_lookup_names,
-				size_t *p_num_addrs,
-				struct sockaddr_storage **pp_addrs)
-{
-	size_t total_num_addrs = 0;
-	size_t i;
-	struct sockaddr_storage *ret_addrs = NULL;
-
-	/* FIXME - make this asnyc using our async DNS code. */
-
-	for (i = 0; i < num_dns_names; i++ ) {
-		struct addrinfo *res = NULL;
-		struct addrinfo *p = NULL;
-		size_t num_addrs = 0;
-		bool ok = interpret_string_addr_internal(&res,
-					dns_lookup_names[i],
-					0);
-		if (!ok) {
-			continue;
-		}
-		/* Count the IP's returned from the lookup. */
-		for (p = res; p; p = p->ai_next) {
-			num_addrs++;
-		}
-
-		/* Wrap check. */
-		if (total_num_addrs + num_addrs < total_num_addrs) {
-			if (res) {
-				freeaddrinfo(res);
-			}
-			return NT_STATUS_INVALID_PARAMETER;
-		}
-		ret_addrs = talloc_realloc(ctx,
-					   ret_addrs,
-					   struct sockaddr_storage,
-					   total_num_addrs + num_addrs);
-		if (ret_addrs == NULL) {
-			if (res) {
-				freeaddrinfo(res);
-			}
-			return NT_STATUS_NO_MEMORY;
-		}
-
-		for (p = res; p; p = p->ai_next) {
-			char addr[INET6_ADDRSTRLEN];
-
-			memcpy(&ret_addrs[total_num_addrs],
-				p->ai_addr,
-				p->ai_addrlen);
-
-			if (is_zero_addr(&ret_addrs[total_num_addrs])) {
-				continue;
-			}
-
-			DBG_DEBUG("getaddrinfo name %s returned IP %s\n",
-				dns_lookup_names[i],
-				print_sockaddr(addr,
-					sizeof(addr),
-					&ret_addrs[total_num_addrs]));
-
-			total_num_addrs++;
-		}
-		if (res) {
-			freeaddrinfo(res);
-		}
-	}
-
-	*p_num_addrs = total_num_addrs;
-	*pp_addrs = ret_addrs;
-	return NT_STATUS_OK;
-}
-#endif
-
 /********************************************************
  Resolve via "hosts" method.
 *********************************************************/
-- 
2.20.1


From afac825e0fe7e8c35c1045a8c8cded086d65cc84 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 12:48:44 -0700
Subject: [PATCH 54/60] s3: libsmb: Make resolve_hosts() use new async DNS
 lookup.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 78 ++++++++++++--------------------------
 1 file changed, 24 insertions(+), 54 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 4e0ab397c2c..3e541aad3a0 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2602,11 +2602,9 @@ static NTSTATUS resolve_hosts(TALLOC_CTX *mem_ctx,
 	/*
 	 * "host" means do a localhost, or dns lookup.
 	 */
-	struct addrinfo hints;
-	struct addrinfo *ailist = NULL;
-	struct addrinfo *res = NULL;
-	int ret = -1;
-	int i = 0;
+	size_t num_addrs = 0;
+	struct sockaddr_storage *addrs = NULL;
+	NTSTATUS status;
 
 	if ( name_type != 0x20 && name_type != 0x0) {
 		DEBUG(5, ("resolve_hosts: not appropriate "
@@ -2621,60 +2619,32 @@ static NTSTATUS resolve_hosts(TALLOC_CTX *mem_ctx,
 	DEBUG(3,("resolve_hosts: Attempting host lookup for name %s<0x%x>\n",
 				name, name_type));
 
-	ZERO_STRUCT(hints);
-	/* By default make sure it supports TCP. */
-	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_flags = AI_ADDRCONFIG;
-
-#if !defined(HAVE_IPV6)
-	/* Unless we have IPv6, we really only want IPv4 addresses back. */
-	hints.ai_family = AF_INET;
-#endif
+	/* Lookup the addresses on the dns_lookup_list. */
+	status = dns_lookup_list_async(mem_ctx,
+				1,
+				&name,
+				&num_addrs,
+				&addrs);
 
-	ret = getaddrinfo(name,
-			NULL,
-			&hints,
-			&ailist);
-	if (ret) {
-		DEBUG(3,("resolve_hosts: getaddrinfo failed for name %s [%s]\n",
-			name,
-			gai_strerror(ret) ));
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
 	}
 
-	for (res = ailist; res; res = res->ai_next) {
-		struct sockaddr_storage ss;
-
-		if (!res->ai_addr || res->ai_addrlen == 0) {
-			continue;
-		}
-
-		ZERO_STRUCT(ss);
-		memcpy(&ss, res->ai_addr, res->ai_addrlen);
-
-		if (is_zero_addr(&ss)) {
-			continue;
-		}
-
-		*return_count += 1;
-
-		*return_iplist = talloc_realloc(
-			mem_ctx, *return_iplist, struct sockaddr_storage,
-			*return_count);
-		if (!*return_iplist) {
-			DEBUG(3,("resolve_hosts: malloc fail !\n"));
-			freeaddrinfo(ailist);
-			return NT_STATUS_NO_MEMORY;
-		}
-		(*return_iplist)[i] = ss;
-		i++;
-	}
-	if (ailist) {
-		freeaddrinfo(ailist);
+	*return_count = (int)num_addrs;
+	if (return_count < 0) {
+		return NT_STATUS_INVALID_PARAMETER;
 	}
-	if (*return_count) {
-		return NT_STATUS_OK;
+	*return_iplist = addrs;
+	/*
+	 * resolve_hosts() semantics returns
+	 * NT_STATUS_UNSUCCESSFUL if no addresses
+	 * were returned. This allows lookup to
+	 * continue using another method.
+	 */
+	if (*return_count == 0) {
+		return NT_STATUS_UNSUCCESSFUL;
 	}
-	return NT_STATUS_UNSUCCESSFUL;
+	return NT_STATUS_OK;
 }
 
 /********************************************************
-- 
2.20.1


From 9f2e9021366153b97578e3911039d8d892ea9534 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 14:49:35 -0700
Subject: [PATCH 55/60] s3: libsmb: Tweak the interface to
 dns_lookup_list_async() slightly.

Allow a caller to request it to return an array of names that match
element by element the array of IP addresses returned.

Doing this and making exposing this interface will allow the
async DNS lookups to be re-used inside the dsgetdcname() internals
code used by winbindd to find DC's.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 48 +++++++++++++++++++++++++++++++++++---
 1 file changed, 45 insertions(+), 3 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index 3e541aad3a0..bc64e78dac9 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2309,7 +2309,8 @@ static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
 				      size_t num_dns_names,
 				      const char **dns_lookup_names,
 				      size_t *p_num_addrs,
-				      struct sockaddr_storage **pp_addrs)
+				      struct sockaddr_storage **pp_addrs,
+				      char ***pp_dns_names)
 {
 	struct dns_lookup_list_async_state *state = NULL;
 	struct tevent_context *ev = NULL;
@@ -2320,12 +2321,16 @@ static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
 	size_t i;
 	size_t num_addrs = 0;
 	struct sockaddr_storage *addr_out = NULL;
+	char **dns_names_ret = NULL;
 	NTSTATUS status = NT_STATUS_NO_MEMORY;
 
 	/* Nothing to do. */
 	if (num_dns_names == 0) {
 		*p_num_addrs = 0;
 		*pp_addrs = NULL;
+		if (pp_dns_names != NULL) {
+			*pp_dns_names = NULL;
+		}
 		return NT_STATUS_OK;
 	}
 
@@ -2444,11 +2449,43 @@ static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
 		goto fail;
 	}
 
+	/*
+	 * Did the caller want an array of names back
+	 * that match the IP addresses ? If we provide
+	 * this, dsgetdcname() internals can now use this
+	 * async lookup code also.
+	 */
+	if (pp_dns_names != NULL) {
+		dns_names_ret = talloc_zero_array(ctx,
+						  char *,
+						  num_addrs);
+		if (dns_names_ret == NULL) {
+			goto fail;
+		}
+	}
+
 	/* Copy what we got back. */
 	num_addrs = 0;
 	for (i = 0; i < num_queries_sent; i++) {
 		struct dns_query_state *query = &state->queries[i];
 
+		if (dns_names_ret != NULL) {
+			/*
+			 * If caller wants a name array matched with
+			 * the addrs array, copy the same queried name for
+			 * each IP address returned.
+			 */
+			size_t j;
+			for (j = 0; j < query->num_addrs; j++) {
+				dns_names_ret[num_addrs + j] = talloc_strdup(
+						ctx,
+						query->query_name);
+				if (dns_names_ret[num_addrs + j] == NULL) {
+					goto fail;
+				}
+			}
+		}
+
 		memcpy(&addr_out[num_addrs],
 			query->addrs,
 			query->num_addrs * sizeof(query->addrs[0]));
@@ -2457,6 +2494,9 @@ static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
 
 	*p_num_addrs = num_addrs;
 	*pp_addrs = addr_out;
+	if (pp_dns_names != NULL) {
+		*pp_dns_names = dns_names_ret;
+	}
 
 	status = NT_STATUS_OK;
 
@@ -2624,7 +2664,8 @@ static NTSTATUS resolve_hosts(TALLOC_CTX *mem_ctx,
 				1,
 				&name,
 				&num_addrs,
-				&addrs);
+				&addrs,
+				NULL);
 
 	if (!NT_STATUS_IS_OK(status)) {
 		return status;
@@ -2836,7 +2877,8 @@ static NTSTATUS resolve_ads(TALLOC_CTX *ctx,
 				num_dns_names,
 				dns_lookup_names,
 				&num_dns_addrs,
-				&dns_addrs);
+				&dns_addrs,
+				NULL);
 
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(dcs);
-- 
2.20.1


From 1e552a75a31fa50535765c7dfa72010c6c482275 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 14:56:47 -0700
Subject: [PATCH 56/60] s3: libsmb: Make dns_lookup_list_async() available to
 other Samba callers.

This allows the async DNS lookups to be re-used inside the dsgetdcname() internals
code used by winbindd to find DC's.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/namequery.c | 12 ++++++------
 source3/libsmb/namequery.h |  6 ++++++
 2 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/source3/libsmb/namequery.c b/source3/libsmb/namequery.c
index bc64e78dac9..bebc7f847ae 100644
--- a/source3/libsmb/namequery.c
+++ b/source3/libsmb/namequery.c
@@ -2305,12 +2305,12 @@ static void dns_lookup_list_a_done(struct tevent_req *req);
 static void dns_lookup_list_aaaa_done(struct tevent_req *req);
 #endif
 
-static NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
-				      size_t num_dns_names,
-				      const char **dns_lookup_names,
-				      size_t *p_num_addrs,
-				      struct sockaddr_storage **pp_addrs,
-				      char ***pp_dns_names)
+NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
+			      size_t num_dns_names,
+			      const char **dns_lookup_names,
+			      size_t *p_num_addrs,
+			      struct sockaddr_storage **pp_addrs,
+			      char ***pp_dns_names)
 {
 	struct dns_lookup_list_async_state *state = NULL;
 	struct tevent_context *ev = NULL;
diff --git a/source3/libsmb/namequery.h b/source3/libsmb/namequery.h
index aedb043ac81..d6f5d216733 100644
--- a/source3/libsmb/namequery.h
+++ b/source3/libsmb/namequery.h
@@ -85,6 +85,12 @@ NTSTATUS resolve_wins(TALLOC_CTX *mem_ctx,
 		int name_type,
 		struct sockaddr_storage **return_iplist,
 		int *return_count);
+NTSTATUS dns_lookup_list_async(TALLOC_CTX *ctx,
+			       size_t num_dns_names,
+			       const char **dns_lookup_names,
+			       size_t *p_num_addrs,
+			       struct sockaddr_storage **pp_addrs,
+			       char ***pp_dns_names);
 NTSTATUS internal_resolve_name(const char *name,
 			        int name_type,
 				const char *sitename,
-- 
2.20.1


From 1b51a4a86a95e30062c0c3724d2b3f77b71aecde Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Tue, 21 Jul 2020 22:09:27 -0700
Subject: [PATCH 57/60] s3: libsmb: Make discover_dc_dns() use async DNS.

Change to call dns_lookup_list_async().

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libsmb/dsgetdcname.c | 229 ++++++++++++++++++++++++++++-------
 1 file changed, 183 insertions(+), 46 deletions(-)

diff --git a/source3/libsmb/dsgetdcname.c b/source3/libsmb/dsgetdcname.c
index 08477065f34..c5c4b58c6ae 100644
--- a/source3/libsmb/dsgetdcname.c
+++ b/source3/libsmb/dsgetdcname.c
@@ -504,14 +504,17 @@ static NTSTATUS discover_dc_dns(TALLOC_CTX *mem_ctx,
 				struct ip_service_name **returned_dclist,
 				int *return_count)
 {
-	int i;
-	size_t j;
+	size_t i;
 	NTSTATUS status;
 	struct dns_rr_srv *dcs = NULL;
 	int numdcs = 0;
-	int numaddrs = 0;
 	struct ip_service_name *dclist = NULL;
-	int count = 0;
+	size_t ret_count = 0;
+	size_t num_dns_lookups = 0;
+	const char **dns_lookups = NULL;
+	size_t num_lookups_ret = 0;
+	struct sockaddr_storage *dns_addrs_ret = NULL;
+	char **dns_lookups_ret = NULL;
 
 	if (flags & DS_PDC_REQUIRED) {
 		status = ads_dns_query_pdc(mem_ctx,
@@ -554,74 +557,208 @@ static NTSTATUS discover_dc_dns(TALLOC_CTX *mem_ctx,
 	}
 
 	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
 		return status;
 	}
 
-	if (numdcs == 0) {
+	/* Wrap protect. */
+	if (numdcs < 0) {
+		TALLOC_FREE(dcs);
 		return NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND;
 	}
 
-	for (i=0;i<numdcs;i++) {
-		numaddrs += MAX(dcs[i].num_ips,1);
+	if (numdcs == 0) {
+		TALLOC_FREE(dcs);
+		return NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND;
 	}
 
+	/*
+	 * We're only returning one address per
+	 * DC name, so just allocate size numdcs.
+	 */
+
 	dclist = talloc_zero_array(mem_ctx,
 				   struct ip_service_name,
-				   numaddrs);
+				   numdcs);
 	if (!dclist) {
+		TALLOC_FREE(dcs);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/* now unroll the list of IP addresses */
-
-	*return_count = 0;
-	i = 0;
-	j = 0;
-
-	while ((i < numdcs) && (count < numaddrs)) {
+	/*
+	 * First, copy the SRV record replies that
+	 * have IP addresses returned with them.
+	 */
+	ret_count = 0;
+	for (i = 0; i < numdcs; i++) {
+		size_t j;
+
+		if (dcs[i].num_ips == 0) {
+			/*
+			 * No addresses returned in the SRV
+			 * reply, we must look this up via
+			 * DNS.
+			 */
+			num_dns_lookups++;
+			continue;
+		}
 
-		struct ip_service_name *r = &dclist[count];
+		dclist[ret_count].hostname = talloc_move(mem_ctx,
+						&dcs[i].hostname);
+
+		/*
+		 * Pick the first IPv4 address,
+		 * if none pick the first address.
+		 *
+		 * This is different from the previous
+		 * code which picked a 'next ip' address
+		 * each time, incrementing an index.
+		 * Too complex to maintain :-(.
+		 */
+		for (j = 0; j < dcs[i].num_ips; j++) {
+			if (dcs[i].ss_s[j].ss_family == AF_INET) {
+				dclist[ret_count].ss = dcs[i].ss_s[j];
+				break;
+			}
+		}
+		if (j == dcs[i].num_ips) {
+			/* No IPv4- use the first IPv6 addr. */
+			dclist[ret_count].ss = dcs[i].ss_s[0];
+		}
+		ret_count++;
+	}
+
+	/*
+	 * Now, create an array of hostnames we
+	 * will asynchronously look up in DNS.
+	 */
+	dns_lookups = talloc_zero_array(mem_ctx,
+					const char *,
+					num_dns_lookups);
+	if (dns_lookups == NULL) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(dclist);
+		return NT_STATUS_NO_MEMORY;
+	}
 
-		r->hostname = dcs[i].hostname;
+	num_dns_lookups = 0;
+	for (i = 0; i < numdcs; i++) {
+		if (dcs[i].num_ips != 0) {
+			/*
+			 * We already got an address
+			 * for this via SRV return.
+			 */
+			continue;
+		}
+		dns_lookups[num_dns_lookups] = talloc_strdup(mem_ctx,
+							dcs[i].hostname);
+		if (dns_lookups[num_dns_lookups] == NULL) {
+			TALLOC_FREE(dcs);
+			TALLOC_FREE(dclist);
+			TALLOC_FREE(dns_lookups);
+		}
+		num_dns_lookups++;
+	}
 
-		/* If we don't have an IP list for a name, lookup it up */
+	status = dns_lookup_list_async(mem_ctx,
+				       num_dns_lookups,
+				       dns_lookups,
+				       &num_lookups_ret,
+				       &dns_addrs_ret,
+				       &dns_lookups_ret);
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(dclist);
+		TALLOC_FREE(dns_lookups);
+		return status;
+	}
 
-		if (!dcs[i].ss_s) {
-			interpret_string_addr_prefer_ipv4(&r->ss,
-						dcs[i].hostname, 0);
-			i++;
-			j = 0;
-		} else {
-			/* use the IP addresses from the SRV response */
+	/*
+	 * Remember, if we timed out or some
+	 * addresses didn't look up then
+	 * num_dns_lookups > num_lookups_ret,
+	 * so there isn't a one to one correspondence.
+	 *
+	 * The order of the requests is preserved
+	 * in the replies, but there may be requests
+	 * for which there are no replies if we
+	 * timed out.
+	 *
+	 * For example this means for looking up
+	 * names:
+	 *	NAME1
+	 *	NAME2
+	 *	NAME3
+	 *
+	 * The replies might look like:
+	 * 	NAME1 -> IPv4
+	 * 	NAME1 -> IPv4
+	 *	NAME1 -> IPv6
+	 *	NAME1 -> IPv6
+	 *	NAME3 -> IPv6
+	 *
+	 * But they will never be in the order:
+	 *
+	 *	NAME2
+	 *	NAME3
+	 *	NAME1
+	 *
+	 * Also in dns_lookup_list_async()
+	 * we arrange the requests/replies in
+	 * the order IPv4 followed by IPv6, so in
+	 * the replies, we can always pick the first
+	 * reply - we know it will be IPv4 if there
+	 * is an IPv4 for that name.
+	 *
+	 */
+
+	for (i = 0; i < num_lookups_ret; i++) {
+		/*
+		 * PARANOIA Check. This cannot happen.
+		 */
+		SMB_ASSERT(ret_count < numdcs);
+
+		if (ret_count == numdcs) {
+			TALLOC_FREE(dcs);
+			TALLOC_FREE(dclist);
+			TALLOC_FREE(dns_lookups);
+			return NT_STATUS_INTERNAL_ERROR;
+		}
 
-			if (j >= dcs[i].num_ips) {
-				i++;
-				j = 0;
+		dclist[ret_count].hostname = talloc_move(mem_ctx,
+						&dns_lookups_ret[i]);
+		dclist[ret_count].ss = dns_addrs_ret[i];
+		/*
+		 * Is this a duplicate name return.
+		 * Remember we can look up both A and
+		 * AAAA records which can return multiple
+		 * addresses and the order of names
+		 * is preserved.
+		 */
+		if (ret_count > 0) {
+			if (strcmp(dclist[ret_count-1].hostname,
+				   dclist[ret_count].hostname) == 0) {
+				/*
+				 * Same name. Keep the first address
+				 * which is IPv4 by preference.
+				 */
 				continue;
 			}
-
-			r->ss = dcs[i].ss_s[j];
-			j++;
-		}
-
-		/* make sure it is a valid IP.  I considered checking the
-		 * negative connection cache, but this is the wrong place for
-		 * it.  Maybe only as a hack. After think about it, if all of
-		 * the IP addresses returned from DNS are dead, what hope does a
-		 * netbios name lookup have?  The standard reason for falling
-		 * back to netbios lookups is that our DNS server doesn't know
-		 * anything about the DC's   -- jerry */
-
-		if (!is_zero_addr(&r->ss)) {
-			count++;
-			continue;
 		}
+		ret_count++;
 	}
 
 	*returned_dclist = dclist;
-	*return_count = count;
+	*return_count = (int)ret_count;
+
+	if (*return_count < 0) {
+		TALLOC_FREE(dcs);
+		TALLOC_FREE(dclist);
+		TALLOC_FREE(dns_lookups);
+		return NT_STATUS_INTERNAL_ERROR;
+	}
 
-	if (count > 0) {
+	if (ret_count > 0) {
 		return NT_STATUS_OK;
 	}
 
-- 
2.20.1


From 206cb66bcfed2a1bfc8bd44d7e2a91ce62f962a9 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 22 Jul 2020 15:35:43 -0700
Subject: [PATCH 58/60] s3: libads: ads_connect can be passed in an ADS_STRUCT
 with an existing IP address.

ads_connect can be passed in an ADS_STRUCT
with an existing ads->ldap.ss IP address that
is stored by going through ads_find_dc(). Store this off
before zeroing out ads->ldap so we don't need to do
multiple calls to ads_find_dc().

If a caller wants a clean ADS_STRUCT they
will call ads_destroy().

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ldap.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index 8ad76ed0ae9..5f6a36819ff 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -576,6 +576,22 @@ ADS_STATUS ads_connect(ADS_STRUCT *ads)
 	ADS_STATUS status;
 	NTSTATUS ntstatus;
 	char addr[INET6_ADDRSTRLEN];
+	struct sockaddr_storage existing_ss = {0};
+
+	/*
+	 * ads_connect can be passed in an ADS_STRUCT
+	 * with an existing ads->ldap.ss IP address that
+	 * is stored by going through ads_find_dc(). Store this off
+	 * before zeroing out ads->ldap so we don't need to do
+	 * multiple calls to ads_find_dc().
+	 *
+	 * If a caller wants a clean ADS_STRUCT they
+	 * will call ads_destroy().
+	 */
+	if (!is_zero_addr(&ads->ldap.ss)) {
+		/* We already know who to talk to. */
+		existing_ss = ads->ldap.ss;
+	}
 
 	ZERO_STRUCT(ads->ldap);
 	ZERO_STRUCT(ads->ldap_wrap_data);
@@ -622,6 +638,15 @@ ADS_STATUS ads_connect(ADS_STRUCT *ads)
 		}
 	}
 
+	if (!is_zero_addr(&existing_ss)) {
+		/* We already know who to talk to. */
+		bool ok = ads_try_connect(ads, ads->server.gc, &existing_ss);
+		if (ok) {
+			goto got_connection;
+		}
+		/* Keep trying.. */
+	}
+
 	ntstatus = ads_find_dc(ads);
 	if (NT_STATUS_IS_OK(ntstatus)) {
 		goto got_connection;
-- 
2.20.1


From 97395a91ac0e6b694749cd3287ee65f124b843ca Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 22 Jul 2020 19:00:52 -0700
Subject: [PATCH 59/60] s3: libads: Don't re-do DNS lookups in
 ads_current_time() if not needed.

ADS_STRUCT may be being reused after a
DC lookup, so ads->ldap.ss may already have a
good address. Only do the DNS lookup if we have to.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ldap.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index 5f6a36819ff..d3cdf178d96 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -3223,11 +3223,19 @@ ADS_STATUS ads_current_time(ADS_STRUCT *ads)
         /* establish a new ldap tcp session if necessary */
 
 	if ( !ads->ldap.ld ) {
-		if ( (ads_s = ads_init( ads->server.realm, ads->server.workgroup, 
-			ads->server.ldap_server, ADS_SASL_PLAIN )) == NULL )
-		{
-			status = ADS_ERROR(LDAP_NO_MEMORY);
-			goto done;
+		/*
+		 * ADS_STRUCT may be being reused after a
+		 * DC lookup, so ads->ldap.ss may already have a
+		 * good address. Only do the DNS lookup if we have to.
+		 */
+		if (is_zero_addr(&ads->ldap.ss)) {
+			if ((ads_s = ads_init(ads->server.realm,
+					ads->server.workgroup,
+					ads->server.ldap_server,
+					ADS_SASL_PLAIN )) == NULL ) {
+				status = ADS_ERROR(LDAP_NO_MEMORY);
+				goto done;
+			}
 		}
 		ads_s->auth.flags = ADS_AUTH_ANON_BIND;
 		status = ads_connect( ads_s );
-- 
2.20.1


From 88eb66287fca73698236b418da548812b4a5a7a1 Mon Sep 17 00:00:00 2001
From: Jeremy Allison <jra@samba.org>
Date: Wed, 22 Jul 2020 19:03:23 -0700
Subject: [PATCH 60/60] s3: libads: Don't re-do DNS lookups in
 ads_domain_func_level() if not needed.

ADS_STRUCT may be being reused after a
DC lookup, so ads->ldap.ss may already have a
good address. Only do the DNS lookup if we have to.

Signed-off-by: Jeremy Allison <jra@samba.org>
---
 source3/libads/ldap.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/source3/libads/ldap.c b/source3/libads/ldap.c
index d3cdf178d96..0cadb62e377 100644
--- a/source3/libads/ldap.c
+++ b/source3/libads/ldap.c
@@ -3293,11 +3293,19 @@ ADS_STATUS ads_domain_func_level(ADS_STRUCT *ads, uint32_t *val)
         /* establish a new ldap tcp session if necessary */
 
 	if ( !ads->ldap.ld ) {
-		if ( (ads_s = ads_init( ads->server.realm, ads->server.workgroup, 
-			ads->server.ldap_server, ADS_SASL_PLAIN )) == NULL )
-		{
-			status = ADS_ERROR_NT(NT_STATUS_NO_MEMORY);
-			goto done;
+		/*
+		 * ADS_STRUCT may be being reused after a
+		 * DC lookup, so ads->ldap.ss may already have a
+		 * good address. Only do the DNS lookup if we have to.
+		 */
+		if (is_zero_addr(&ads->ldap.ss)) {
+			if ((ads_s = ads_init(ads->server.realm,
+						ads->server.workgroup,
+						ads->server.ldap_server,
+						ADS_SASL_PLAIN )) == NULL ) {
+				status = ADS_ERROR_NT(NT_STATUS_NO_MEMORY);
+				goto done;
+			}
 		}
 		ads_s->auth.flags = ADS_AUTH_ANON_BIND;
 		status = ads_connect( ads_s );
-- 
2.20.1

