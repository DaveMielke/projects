Index: bus/engineproxy.c
diff --git a/bus/engineproxy.c b/bus/engineproxy.c
index f808727ba1cd0cfbd339a64365f50813a8d4a178..600b28b8d0adba5c97d8532cd0c95b9d108b30fe 100644
--- a/bus/engineproxy.c
+++ b/bus/engineproxy.c
@@ -616,6 +616,8 @@ create_engine_ready_cb (BusFactoryProxy    *factory,
                         GAsyncResult       *res,
                         EngineProxyNewData *data)
 {
+    g_return_if_fail (data->simple != NULL);
+
     GError *error = NULL;
     gchar *path = bus_factory_proxy_create_engine_finish (factory,
                                                           res,
@@ -662,6 +664,20 @@ notify_factory_cb (BusComponent       *component,
             g_signal_handler_disconnect (data->component, data->handler_id);
             data->handler_id = 0;
         }
+
+        /* We *have to* disconnect the cancelled_cb here, since g_dbus_proxy_call
+         * calls create_engine_ready_cb even if the proxy call is cancelled, and
+         * in this case, create_engine_ready_cb itself will return error using
+         * g_simple_async_result_set_from_error and g_simple_async_result_complete.
+         * Otherwise, g_simple_async_result_complete might be called twice for a
+         * single data->simple twice (first in cancelled_cb and later in
+         * create_engine_ready_cb). */
+        if (data->cancellable && data->cancelled_handler_id != 0) {
+            g_cancellable_disconnect (data->cancellable, data->cancelled_handler_id);
+            data->cancelled_handler_id = 0;
+            /* data->cancellable will be unref'ed in bus_engine_proxy_new_finish later. */
+        }
+
         /* Create engine from factory. */
         bus_factory_proxy_create_engine (data->factory,
                                          data->desc,
@@ -720,6 +736,11 @@ cancelled_cb (GCancellable       *cancellable,
         data->handler_id = 0;
     }
 
+    if (data->cancellable != NULL) {
+        g_object_unref (data->cancellable);
+        data->cancellable = NULL;
+    }
+
     g_simple_async_result_set_error (data->simple,
                                      G_DBUS_ERROR,
                                      G_DBUS_ERROR_FAILED,
@@ -774,6 +795,11 @@ bus_engine_proxy_new (IBusEngineDesc      *desc,
     else {
         /* The factory is ready. We'll create the engine proxy directly. */
         g_object_ref (data->factory);
+
+        /* We don't have to connect to cancelled_cb here, since g_dbus_proxy_call
+         * calls create_engine_ready_cb even if the proxy call is cancelled, and
+         * in this case, create_engine_ready_cb itself can return error using
+         * g_simple_async_result_set_from_error and g_simple_async_result_complete. */
         bus_factory_proxy_create_engine (data->factory,
                                          data->desc,
                                          timeout,
@@ -796,8 +822,11 @@ bus_engine_proxy_new_finish (GAsyncResult   *res,
     EngineProxyNewData *data =
             (EngineProxyNewData *) g_object_get_data ((GObject *) simple,
                                                       "EngineProxyNewData");
-    if (data->cancellable) {
+
+    if (data->cancellable && data->cancelled_handler_id != 0) {
         g_cancellable_disconnect (data->cancellable, data->cancelled_handler_id);
+    }
+    if (data->cancellable) {
         g_object_unref (data->cancellable);
     }
 
@@ -813,12 +842,14 @@ bus_engine_proxy_new_finish (GAsyncResult   *res,
     if (data->factory != NULL)
         g_object_unref (data->factory);
 
-    g_slice_free (EngineProxyNewData, data);
+    BusEngineProxy *engine = NULL;
+    if (!g_simple_async_result_propagate_error (simple, error)) {
+        engine = g_simple_async_result_get_op_res_gpointer (simple);
+    }
 
-    if (g_simple_async_result_propagate_error (simple, error))
-        return NULL;
+    g_object_unref (data->simple);
+    g_slice_free (EngineProxyNewData, data);
 
-    BusEngineProxy *engine = g_simple_async_result_get_op_res_gpointer (simple);
     return engine;
 }
 
Index: bus/inputcontext.c
diff --git a/bus/inputcontext.c b/bus/inputcontext.c
index 32d51e8173bc64b174063dca6ec21eb00f86165e..80e77861ed87d25c408829a09e3cc8516e766fd7 100644
--- a/bus/inputcontext.c
+++ b/bus/inputcontext.c
@@ -2078,6 +2078,15 @@ new_engine_cb (GObject         *obj,
 
     BusEngineProxy *engine = bus_engine_proxy_new_finish (res, &error);
 
+    if (context->simple == NULL) {
+        /* If two or more data->simple objects created in engineproxy.c are already
+         * passed to bus_factory_proxy_create_engine (it could happen since when we
+         * already have the factory, cancelled_cb is not used), this callback could
+         * be called multiple times consequtively via the data->simple objects, and
+         * context->simple could be NULL from the second call. */
+        return;
+    }
+
     if (engine == NULL) {
         g_simple_async_result_set_from_error (context->simple, error);
         g_error_free (error);
@@ -2120,7 +2129,7 @@ set_engine_by_desc_ready_cb (BusInputContext *context,
 {
     GError *error = NULL;
     if (!bus_input_context_set_engine_by_desc_finish (context, res, &error)) {
-        g_warning ("%s", error->message);
+        g_warning ("Set context engine failed: %s", error->message);
         g_error_free (error);
     }
 }
@@ -2140,11 +2149,14 @@ bus_input_context_set_engine_by_desc (BusInputContext    *context,
     if (context->simple != NULL) {
         /* We need cancel previous set engine request */
         g_cancellable_cancel (context->cancellable);
-        g_simple_async_result_set_error (context->simple,
-                                         G_DBUS_ERROR,
-                                         G_DBUS_ERROR_FAILED,
-                                         "Set engine request is overrided.");
-        g_simple_async_result_complete (context->simple);
+        if (context->simple != NULL) {
+            /* The cancel callback might set NULL on context->simple. */
+            g_simple_async_result_set_error (context->simple,
+                                             G_DBUS_ERROR,
+                                             G_DBUS_ERROR_FAILED,
+                                             "Set engine request is overridden.");
+            g_simple_async_result_complete (context->simple);
+        }
     }
 
     g_assert (context->simple == NULL);
