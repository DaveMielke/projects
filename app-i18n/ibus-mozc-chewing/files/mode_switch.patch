Index: chewing/unix/ibus/mozc_engine_property.cc
===================================================================
--- chewing/unix/ibus/mozc_engine_property.cc	(revision 55)
+++ chewing/unix/ibus/mozc_engine_property.cc	(working copy)
@@ -40,7 +40,7 @@
 // The list of properties used in ibus-mozc.
 const MozcEngineProperty kMozcEngineProperties[] = {
   {
-    commands::DIRECT,
+    commands::HALF_ASCII,
     "CompositionMode.English",
     "English",
     "A",
Index: chewing/session.cc
===================================================================
--- chewing/session.cc	(revision 55)
+++ chewing/session.cc	(working copy)
@@ -294,12 +294,12 @@
   candidates->set_direction(commands::Candidates::HORIZONTAL);
 }
 
-void Session::FillOutput(commands::Command *command) {
+void Session::FillOutput(commands::Command *command, bool consumed) {
   DLOG(INFO) << ::chewing_get_KBString(context_);
   commands::Output *output = command->mutable_output();
   output->mutable_key()->CopyFrom(command->input().key());
 
-  output->set_consumed(!::chewing_keystroke_CheckIgnore(context_));
+  output->set_consumed(consumed && !::chewing_keystroke_CheckIgnore(context_));
 
   // Fill the result
   if (::chewing_commit_Check(context_)) {
@@ -347,7 +347,6 @@
     if (buffer_len > 0) {
       if (cursor < buffer_len) {
         int bytes = BytesForChars(buffer, cursor);
-        LOG(INFO) << bytes;
         pre_text = buffer.substr(0, bytes);
         trailing_text = buffer.substr(bytes);
         pre_len = cursor;
@@ -407,7 +406,10 @@
       new_mode = commands::HALF_ASCII;
     }
   }
-  output->mutable_status()->set_mode(new_mode);
+  if (new_mode != commands::NUM_OF_COMPOSITIONS) {
+    output->mutable_status()->set_mode(new_mode);
+    output->set_mode(new_mode);
+  }
 
   DLOG(INFO) << command->DebugString();
 }
@@ -420,14 +422,19 @@
 
   // Check the modifier keys at first.
   const KeyEvent &key_event = command->input().key();
+  bool status_updated = false;
+
   if (key_event.modifiers() == KeyEvent::SHIFT) {
     if (key_event.has_special_key()) {
       if (key_event.special_key() == KeyEvent::LEFT) {
         ::chewing_handle_ShiftLeft(context_);
+        status_updated = true;
       } else if (key_event.special_key() == KeyEvent::RIGHT) {
         ::chewing_handle_ShiftRight(context_);
+        status_updated = true;
       } else if (key_event.special_key() == KeyEvent::SPACE) {
         ::chewing_handle_ShiftSpace(context_);
+        status_updated = true;
       }
     }
   } if (key_event.modifiers() == KeyEvent::CTRL) {
@@ -437,8 +444,10 @@
       ::chewing_handle_CtrlNum(
           context_,
           '0' + key_event.special_key() - KeyEvent::NUMPAD0);
+      status_updated = true;
     } else if ('0' <= key_event.key_code() && key_event.key_code() <= '9') {
       ::chewing_handle_CtrlNum(context_, key_event.key_code());
+      status_updated = true;
     }
   } else {
     // normal key event.
@@ -447,64 +456,80 @@
       switch (key_event.special_key()) {
         case KeyEvent::SPACE:
           ::chewing_handle_Space(context_);
+          status_updated = true;
           break;
         case KeyEvent::ESCAPE:
           ::chewing_handle_Esc(context_);
+          status_updated = true;
           break;
         case KeyEvent::ENTER:
           ::chewing_handle_Enter(context_);
+          status_updated = true;
           break;
         case KeyEvent::DEL:
           ::chewing_handle_Del(context_);
+          status_updated = true;
           break;
         case KeyEvent::BACKSPACE:
           ::chewing_handle_Backspace(context_);
+          status_updated = true;
           break;
         case KeyEvent::TAB:
           ::chewing_handle_Tab(context_);
+          status_updated = true;
           break;
         case KeyEvent::LEFT:
           ::chewing_handle_Left(context_);
+          status_updated = true;
           break;
         case KeyEvent::RIGHT:
           ::chewing_handle_Right(context_);
+          status_updated = true;
           break;
         case KeyEvent::UP:
           ::chewing_handle_Up(context_);
+          status_updated = true;
           break;
         case KeyEvent::HOME:
           ::chewing_handle_Home(context_);
+          status_updated = true;
           break;
         case KeyEvent::END:
           ::chewing_handle_End(context_);
+          status_updated = true;
           break;
         case KeyEvent::PAGE_UP:
           ::chewing_handle_PageUp(context_);
+          status_updated = true;
           break;
         case KeyEvent::PAGE_DOWN:
           ::chewing_handle_PageDown(context_);
+          status_updated = true;
           break;
         case KeyEvent::CAPS_LOCK:
           ::chewing_handle_Capslock(context_);
+          status_updated = true;
+          break;
         default:
           // do nothing
           // Currently we don't handle the following keys:
           //   CapsLock, NumLock, DblTab.
           break;
       }
-    } else {
+    } else if (key_event.modifier_keys_size() == 0) {
       ::chewing_handle_Default(context_, key_event.key_code());
+      status_updated = true;
     }
   }
 
-  FillOutput(command);
+  FillOutput(command, status_updated);
   return true;
 }
 
 bool Session::TestSendKey(commands::Command *command) {
   // TODO(mukai): implement this.
   last_command_time_ = Util::GetTime();
-  FillOutput(command);
+  FillOutput(command, true);
   return true;
 }
 
@@ -575,10 +600,7 @@
       break;
   }
 
-  if (consumed) {
-    command->mutable_output()->set_consumed(true);
-  }
-  FillOutput(command);
+  FillOutput(command, consumed);
   return true;
 }
 
Index: chewing/session.h
===================================================================
--- chewing/session.h	(revision 55)
+++ chewing/session.h	(working copy)
@@ -81,8 +81,10 @@
   // Fill the candidates with the current context.
   void FillCandidates(commands::Candidates *candidates);
 
-  // Fill the output with the current context.
-  void FillOutput(commands::Command *command);
+  // Fill the output with the current context.  Set true for the
+  // consumed if this FillOutput is expected to set |consumed| field
+  // in the output.
+  void FillOutput(commands::Command *command, bool consumed);
 
   // Set configurations.
   void ResetConfig();
