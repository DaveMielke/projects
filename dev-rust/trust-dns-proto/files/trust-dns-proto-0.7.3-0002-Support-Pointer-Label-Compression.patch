Support pointer ending label compression.
--- a/src/serialize/binary/encoder.rs
+++ b/src/serialize/binary/encoder.rs
@@ -92,7 +92,7 @@ pub struct BinEncoder<'a> {
     offset: usize,
     buffer: private::MaximalBuf<'a>,
     /// start and end of label pointers, smallvec here?
-    name_pointers: Vec<(usize, usize)>,
+    name_pointers: Vec<(usize, Vec<u8>)>,
     mode: EncodeMode,
     canonical_names: bool,
 }
@@ -131,7 +131,7 @@ impl<'a> BinEncoder<'a> {
             offset: offset as usize,
             // FIXME: add max_size to signature
             buffer: private::MaximalBuf::new(u16::max_value(), buf),
-            name_pointers: Vec::new(),
+            name_pointers: Vec::<(usize, Vec<u8>)>::new(),
             mode,
             canonical_names: false,
         }
@@ -212,7 +212,7 @@ impl<'a> BinEncoder<'a> {
         let offset = self.offset;
         self.buffer.truncate(offset);
         self.name_pointers
-            .retain(|&(start, end)| start < offset && end <= offset);
+            .retain(|&(start, _)| start < offset);
     }
 
     // /// returns an error if the maximum buffer size would be exceeded with the addition number of elements
@@ -243,7 +243,7 @@ impl<'a> BinEncoder<'a> {
         assert!(end <= (u16::max_value() as usize));
         assert!(start <= end);
         if self.offset < 0x3FFF_usize {
-            self.name_pointers.push((start, end)); // the next char will be at the len() location
+            self.name_pointers.push((start, self.slice_of(start, end).to_vec())); // the next char will be at the len() location
         }
     }
 
@@ -251,11 +251,10 @@ impl<'a> BinEncoder<'a> {
     pub fn get_label_pointer(&self, start: usize, end: usize) -> Option<u16> {
         let search = self.slice_of(start, end);
 
-        for &(match_start, match_end) in &self.name_pointers {
-            let matcher = self.slice_of(match_start as usize, match_end as usize);
-            if matcher == search {
-                assert!(match_start <= (u16::max_value() as usize));
-                return Some(match_start as u16);
+        for (match_start, matcher) in &self.name_pointers {
+            if matcher.as_slice() == search {
+                assert!(match_start <= &(u16::max_value() as usize));
+                return Some(*match_start as u16);
             }
         }
 
