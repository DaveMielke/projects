From 715ca0c0ccd94650948efd36a9e7b4592c306906 Mon Sep 17 00:00:00 2001
From: Chris Wolfe <cwolfe@chromium.org>
Date: Thu, 20 Dec 2012 15:27:59 -0500
Subject: [PATCH] xf86-video-intel: Split framebuffer and flip crtcs.

Try to allocate a separate framebuffer for each CRTC and flip those
directly with the back-buffer of updated drawables. This avoids
blitting content when the drawable size matches the crtc size.

When CopyRegion is used top copy content into or out of the screen
buffer, it may be redirected to exactly one scanout buffer. This is
enough to support our one-drawable-per-crtc case, but not sufficient
in general.

This change also moves page flip state that was previously centralized
in the intel_mode structure into the intel_crtc structure associated
with the reference crtc for a flip. This allows flips to pending on
multiple pipes simultaneously.

Tested with the WebGL aquarium and space rocks demos, a Youtube
video and WebKit poster circle demo. Added and removed displays while
active and while suspended.
---
 src/intel.h         |   55 ++++-
 src/intel_display.c |  685 ++++++++++++++++++++++++++++++++++++++++++---------
 src/intel_dri.c     |  180 ++++++++++++--
 src/intel_driver.c  |   10 +
 src/intel_uxa.c     |   48 ++++
 src/intel_video.c   |   11 +-
 6 files changed, 851 insertions(+), 138 deletions(-)

diff --git a/src/intel.h b/src/intel.h
index 22527df..99b2cfe 100644
--- a/src/intel.h
+++ b/src/intel.h
@@ -185,6 +185,8 @@ struct intel_pixmap {
 	int8_t batch_write :1;
 	int8_t offscreen :1;
 	int8_t pinned :1;
+
+	uint32_t fb;
 };
 
 #if HAS_DEVPRIVATEKEYREC
@@ -429,6 +431,7 @@ typedef struct intel_screen_private {
 	Bool has_kernel_flush;
 	Bool needs_flush;
 	Bool use_shadow;
+	Bool use_split_framebuffer;
 
 	struct _DRI2FrameEvent *pending_flip[2];
 
@@ -462,15 +465,43 @@ extern void intel_mode_init(struct intel_screen_private *intel);
 extern void intel_mode_remove_fb(intel_screen_private *intel);
 extern void intel_mode_fini(intel_screen_private *intel);
 
+extern void intel_pixmap_remove_fb(intel_screen_private *intel, PixmapPtr pixmap);
+
 extern int intel_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, xf86CrtcPtr crtc);
 extern int intel_crtc_id(xf86CrtcPtr crtc);
 extern int intel_output_dpms_status(xf86OutputPtr output);
 extern void intel_copy_fb(ScrnInfoPtr pScrn);
 
+struct intel_scanout {
+	PixmapPtr pixmap;
+	BoxRec area; /* area of the virtual screen provided by this scanout */
+};
+
+/* Splits the screen buffer into one scanout per distinct crtc region. */
+extern Bool intel_split_fb(intel_screen_private *intel);
+
+/* Merges any scanouts into the screen buffer. */
+extern void intel_merge_fb(intel_screen_private *intel);
+
+/* Finds a scanout that exactly matches the area, and stores it in |out_scanout|.
+ * Will return FALSE if any scanout partially intersects the area. If no scanout
+ * includes the area, will return TRUE with |out_scanout| set to NULL.
+ */
+extern Bool intel_find_scanout(intel_screen_private *intel, BoxPtr area,
+			       struct intel_scanout **out_scanout);
+
+/* Finds a scanout that contains the area, and stores it in |out_scanout|.
+ * Will return FALSE if any scanout partially intersects the area. If no scanout
+ * includes the area, will return TRUE with |out_scanout| set to NULL.
+ */
+extern Bool intel_covering_scanout(intel_screen_private *intel, BoxPtr area,
+				   struct intel_scanout **out_scanout);
+
 enum DRI2FrameEventType {
 	DRI2_SWAP,
 	DRI2_SWAP_CHAIN,
-	DRI2_FLIP,
+	DRI2_FLIP_FRONT,
+	DRI2_FLIP_SPLIT,
 	DRI2_WAITMSC,
 };
 
@@ -495,13 +526,14 @@ typedef struct _DRI2FrameEvent {
 	void *event_data;
 	DRI2BufferPtr front;
 	DRI2BufferPtr back;
+	BoxRec area; /* screen rectangle being flipped */
 
 	struct _DRI2FrameEvent *chain;
 } DRI2FrameEventRec, *DRI2FrameEventPtr;
 
 extern Bool intel_do_pageflip(intel_screen_private *intel,
-			      dri_bo *new_front,
-			      DRI2FrameEventPtr flip_info, int ref_crtc_hw_id);
+			      PixmapPtr new_front,
+			      DRI2FrameEventPtr flip_info);
 
 static inline intel_screen_private *
 intel_get_screen_private(ScrnInfoPtr scrn)
@@ -529,6 +561,11 @@ extern void I915EmitInvarientState(ScrnInfoPtr scrn);
 extern void I830EmitFlush(ScrnInfoPtr scrn);
 
 extern void I830InitVideo(ScreenPtr pScreen);
+
+extern void intel_box_intersect(BoxPtr dest, BoxPtr a, BoxPtr b);
+extern void intel_crtc_box(xf86CrtcPtr crtc, BoxPtr crtc_box);
+extern void intel_drawable_box(DrawablePtr draw, BoxPtr draw_box);
+
 extern xf86CrtcPtr intel_covering_crtc(ScrnInfoPtr scrn, BoxPtr box,
 				      xf86CrtcPtr desired, BoxPtr crtc_box_ret);
 
@@ -734,6 +771,18 @@ void intel_uxa_block_handler(intel_screen_private *intel);
 Bool intel_get_aperture_space(ScrnInfoPtr scrn, drm_intel_bo ** bo_table,
 			      int num_bos);
 
+/* Copies a box between pixmaps using intel->uxa_driver. */
+extern Bool intel_uxa_driver_copy_pixmap(intel_screen_private *intel,
+					 PixmapPtr src, PixmapPtr dst,
+					 int src_x, int src_y,
+					 int dst_x, int dst_y,
+					 int w, int h);
+
+/* Fills a box of a pixmap using intel->uxa_driver. */
+extern Bool intel_uxa_driver_fill_pixmap(intel_screen_private *intel,
+					 uint32_t src, PixmapPtr dst,
+					 int x, int y, int w, int h);
+
 /* intel_shadow.c */
 void intel_shadow_blt(intel_screen_private *intel);
 void intel_shadow_create(struct intel_screen_private *intel);
diff --git a/src/intel_display.c b/src/intel_display.c
index bac3f8f..8908386 100644
--- a/src/intel_display.c
+++ b/src/intel_display.c
@@ -44,27 +44,33 @@
 #include "xf86drmMode.h"
 #include "X11/Xatom.h"
 
+#define MAX_SCANOUTS (4)
+
+enum intel_scanout_state {
+	INTEL_SCANOUT_INVALID = 0,
+	INTEL_SCANOUT_FRONT,
+	INTEL_SCANOUT_SPLIT,
+};
+
 struct intel_mode {
 	int fd;
-	uint32_t fb_id;
 	drmModeResPtr mode_res;
 	int cpp;
 
 	drmEventContext event_context;
-	DRI2FrameEventPtr flip_info;
-	int old_fb_id;
-	int flip_count;
-	unsigned int fe_frame;
-	unsigned int fe_tv_sec;
-	unsigned int fe_tv_usec;
+
+	uint32_t front_fb_id;
+
+	int scanout_state;
+	struct intel_scanout scanouts[MAX_SCANOUTS];
 
 	struct list outputs;
 	struct list crtcs;
 };
 
 struct intel_pageflip {
-	struct intel_mode *mode;
-	Bool dispatch_me;
+	struct intel_crtc *reference_crtc;
+	struct intel_crtc *flipped_crtc;
 };
 
 struct intel_crtc {
@@ -72,10 +78,20 @@ struct intel_crtc {
 	drmModeModeInfo kmode;
 	drmModeCrtcPtr mode_crtc;
 	int pipe;
+
+	struct {
+		int pending; /* number of outstanding flip requests */
+		unsigned int frame;
+		unsigned int tv_sec;
+		unsigned int tv_usec;
+		DRI2FrameEventPtr info;
+	} flip;
+
 	dri_bo *cursor;
 	dri_bo *rotate_bo;
 	uint32_t rotate_pitch;
 	uint32_t rotate_fb_id;
+
 	xf86CrtcPtr crtc;
 	struct list link;
 };
@@ -109,6 +125,9 @@ struct intel_output {
 };
 
 static void
+intel_crtc_merge_scanouts(intel_screen_private *intel);
+
+static void
 intel_output_dpms(xf86OutputPtr output, int mode);
 
 static void
@@ -330,16 +349,97 @@ intel_crtc_dpms(xf86CrtcPtr intel_crtc, int mode)
 
 }
 
+/* Get a scratch pixmap attached to the current front buffer. This needs to be
+ * used rather than GetScreenPixmap before the screen is fully initialized,
+ * and during intel_xf86crtc_resize when the state is inconsistent.
+ */
+static PixmapPtr intel_get_scratch_front_pixmap(intel_screen_private *intel)
+{
+	ScrnInfoPtr scrn = intel->scrn;
+	PixmapPtr pixmap;
+
+	pixmap = GetScratchPixmapHeader(
+		scrn->pScreen,
+		scrn->virtualX,
+		scrn->virtualY,
+		scrn->depth,
+		scrn->bitsPerPixel,
+		intel->front_pitch,
+		NULL);
+
+	intel_set_pixmap_bo(pixmap, intel->front_buffer);
+	return pixmap;
+}
+
+static void intel_free_scratch_front_pixmap(PixmapPtr pixmap)
+{
+	if (pixmap == NULL)
+		return;
+	intel_set_pixmap_bo(pixmap, NULL);
+	FreeScratchPixmapHeader(pixmap);
+}
+
+static uint32_t
+intel_pixmap_ensure_fb(intel_screen_private *intel, PixmapPtr pixmap)
+{
+	struct intel_mode *mode = intel->modes;
+	struct intel_pixmap *intel_pixmap = intel_get_pixmap_private(pixmap);
+	int ret;
+
+	if (intel_pixmap->fb != 0)
+		return intel_pixmap->fb;
+
+	ret = drmModeAddFB(mode->fd,
+		pixmap->drawable.width,
+		pixmap->drawable.height,
+		intel->scrn->depth,
+		intel->scrn->bitsPerPixel,
+		intel_pixmap_pitch(pixmap),
+		intel_get_pixmap_bo(pixmap)->handle,
+		&intel_pixmap->fb);
+	if (ret < 0) {
+		xf86DrvMsg(intel->scrn->scrnIndex, X_ERROR,
+			   "failed to add fb for pixmap: %s\n",
+			   strerror(-ret));
+		return FALSE;
+	}
+
+	return intel_pixmap->fb;
+}
+
+void intel_pixmap_remove_fb(intel_screen_private *intel, PixmapPtr pixmap)
+{
+	struct intel_mode *mode = intel->modes;
+	struct intel_pixmap *intel_pixmap = intel_get_pixmap_private(pixmap);
+	int ret;
+
+	if (intel_pixmap->fb == 0)
+		return;
+
+	ret = drmModeRmFB(mode->fd, intel_pixmap->fb);
+	if (ret < 0) {
+		xf86DrvMsg(intel->scrn->scrnIndex, X_ERROR,
+			   "failed to remove fb for pixmap: %s\n",
+			   strerror(-ret));
+	}
+
+	intel_pixmap->fb = 0;
+}
+
 static Bool
 intel_crtc_apply(xf86CrtcPtr crtc)
 {
 	ScrnInfoPtr scrn = crtc->scrn;
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	struct intel_mode *mode = intel->modes;
 	struct intel_crtc *intel_crtc = crtc->driver_private;
-	struct intel_mode *mode = intel_crtc->mode;
+	BoxRec crtc_box;
+	struct intel_scanout *scanout;
 	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
 	uint32_t *output_ids;
 	int output_count = 0;
-	int fb_id, x, y;
+	uint32_t fb_id;
+	int x, y;
 	int i, ret = FALSE;
 
 	output_ids = calloc(sizeof(uint32_t), xf86_config->num_output);
@@ -372,9 +472,20 @@ intel_crtc_apply(xf86CrtcPtr crtc)
 			       crtc->gamma_blue, crtc->gamma_size);
 #endif
 
+	fb_id = mode->front_fb_id;
 	x = crtc->x;
 	y = crtc->y;
-	fb_id = mode->fb_id;
+
+	intel_crtc_box(crtc, &crtc_box);
+	if (!intel_find_scanout(intel, &crtc_box, &scanout)) {
+		/* partially intersects a scanout; merge everything */
+		intel_crtc_merge_scanouts(intel);
+	}
+	if (scanout != NULL) {
+		fb_id = intel_pixmap_ensure_fb(intel, scanout->pixmap);
+		x -= scanout->area.x1;
+		y -= scanout->area.y1;
+	}
 	if (intel_crtc->rotate_fb_id) {
 		fb_id = intel_crtc->rotate_fb_id;
 		x = 0;
@@ -396,7 +507,6 @@ intel_crtc_apply(xf86CrtcPtr crtc)
 		for (i = 0; i < xf86_config->num_output; i++) {
 		    xf86OutputPtr output = xf86_config->output[i];
 		    struct intel_output *intel_output;
-
 		    if (output->crtc != crtc)
 			continue;
 
@@ -421,20 +531,20 @@ intel_crtc_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
 {
 	ScrnInfoPtr scrn = crtc->scrn;
 	intel_screen_private *intel = intel_get_screen_private(scrn);
+	struct intel_mode *intel_mode = intel->modes;
 	struct intel_crtc *intel_crtc = crtc->driver_private;
-	struct intel_mode *intel_mode = intel_crtc->mode;
 	int saved_x, saved_y;
 	Rotation saved_rotation;
 	DisplayModeRec saved_mode;
-	int ret = TRUE;
-	unsigned int pitch = scrn->displayWidth * intel->cpp;
+	int ret;
 
-	if (intel_mode->fb_id == 0) {
+	if (intel_mode->front_fb_id == 0) {
 		ret = drmModeAddFB(intel_mode->fd,
 				   scrn->virtualX, scrn->virtualY,
 				   scrn->depth, scrn->bitsPerPixel,
-				   pitch, intel->front_buffer->handle,
-				   &intel_mode->fb_id);
+				   scrn->displayWidth * intel->cpp,
+				   intel->front_buffer->handle,
+				   &intel_mode->front_fb_id);
 		if (ret < 0) {
 			ErrorF("failed to add fb\n");
 			return FALSE;
@@ -454,14 +564,17 @@ intel_crtc_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
 	intel_batch_submit(crtc->scrn);
 
 	mode_to_kmode(crtc->scrn, &intel_crtc->kmode, mode);
-	ret = intel_crtc_apply(crtc);
-	if (!ret) {
-		crtc->x = saved_x;
-		crtc->y = saved_y;
-		crtc->rotation = saved_rotation;
-		crtc->mode = saved_mode;
-	}
-	return ret;
+	if (!intel_crtc_apply(crtc))
+		goto error_undo;
+
+	return TRUE;
+
+error_undo:
+	crtc->x = saved_x;
+	crtc->y = saved_y;
+	crtc->rotation = saved_rotation;
+	crtc->mode = saved_mode;
+	return FALSE;
 }
 
 static void
@@ -1349,31 +1462,51 @@ intel_output_init(ScrnInfoPtr scrn, struct intel_mode *mode, int num)
 	list_add(&intel_output->link, &mode->outputs);
 }
 
+static void
+intel_destroy_scanout(struct intel_scanout *scanout)
+{
+	if (!scanout)
+		return;
+
+	if (scanout->pixmap) {
+		intel_set_pixmap_bo(scanout->pixmap, NULL);
+		FreeScratchPixmapHeader(scanout->pixmap);
+	}
+	memset(scanout, 0, sizeof(*scanout));
+}
+
 static Bool
 intel_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height)
 {
 	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
-	struct intel_crtc *intel_crtc = xf86_config->crtc[0]->driver_private;
-	struct intel_mode *mode = intel_crtc->mode;
 	intel_screen_private *intel = intel_get_screen_private(scrn);
+	struct intel_mode *mode = intel->modes;
 	drm_intel_bo *old_front = NULL;
-	Bool	    ret;
+	int         ret;
 	uint32_t    old_fb_id;
 	int	    i, old_width, old_height, old_pitch;
 	unsigned long pitch;
 	uint32_t tiling;
 
+	intel_batch_submit(scrn);
+
 	if (scrn->virtualX == width && scrn->virtualY == height)
 		return TRUE;
 
-	intel_batch_submit(scrn);
+	for (i = 0; i < MAX_SCANOUTS; i++) {
+		intel_destroy_scanout(&mode->scanouts[i]);
+	}
+	mode->scanout_state = INTEL_SCANOUT_INVALID;
 
 	old_width = scrn->virtualX;
 	old_height = scrn->virtualY;
 	old_pitch = scrn->displayWidth;
-	old_fb_id = mode->fb_id;
+	old_fb_id = mode->front_fb_id;
 	old_front = intel->front_buffer;
 
+	intel->front_buffer = NULL;
+	mode->front_fb_id = 0;
+
 	if (intel->back_buffer) {
 		drm_intel_bo_unreference(intel->back_buffer);
 		intel->back_buffer = NULL;
@@ -1390,7 +1523,7 @@ intel_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height)
 	ret = drmModeAddFB(mode->fd, width, height, scrn->depth,
 			   scrn->bitsPerPixel, pitch,
 			   intel->front_buffer->handle,
-			   &mode->fb_id);
+			   &mode->front_fb_id);
 	if (ret)
 		goto fail;
 
@@ -1426,9 +1559,9 @@ fail:
 	scrn->virtualX = old_width;
 	scrn->virtualY = old_height;
 	scrn->displayWidth = old_pitch;
-	if (old_fb_id != mode->fb_id)
-		drmModeRmFB(mode->fd, mode->fb_id);
-	mode->fb_id = old_fb_id;
+	if (old_fb_id != mode->front_fb_id)
+		drmModeRmFB(mode->fd, mode->front_fb_id);
+	mode->front_fb_id = old_fb_id;
 
 	return FALSE;
 }
@@ -1536,86 +1669,408 @@ void intel_copy_fb(ScrnInfoPtr pScrn)
 
 }
 
+static PixmapPtr intel_create_split_fb(intel_screen_private *intel, int width, int height)
+{
+	ScrnInfoPtr scrn = intel->scrn;
+	drm_intel_bo *pixmap_bo = NULL;
+	PixmapPtr pixmap = NULL;
+	unsigned long pitch;
+	uint32_t tiling;
+
+	pixmap_bo = intel_allocate_framebuffer(scrn, width, height, intel->cpp,
+					       &pitch, &tiling);
+	if (!pixmap_bo)
+		goto fail;
+
+	pixmap = GetScratchPixmapHeader(scrn->pScreen,
+					width, height,
+					scrn->depth,
+					scrn->bitsPerPixel,
+					pitch,
+					NULL);
+	if (!pixmap)
+		goto fail;
+
+	intel_set_pixmap_bo(pixmap, pixmap_bo);
+	drm_intel_bo_unreference(pixmap_bo);
+	pixmap_bo = NULL;
+
+	return pixmap;
+fail:
+	drm_intel_bo_unreference(pixmap_bo);
+	return NULL;
+}
+
 Bool
-intel_do_pageflip(intel_screen_private *intel,
-		  dri_bo *new_front,
-		  DRI2FrameEventPtr flip_info, int ref_crtc_hw_id)
+intel_split_fb(intel_screen_private *intel)
 {
 	ScrnInfoPtr scrn = intel->scrn;
+	struct intel_mode *mode = intel->modes;
 	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
-	struct intel_crtc *crtc = config->crtc[0]->driver_private;
-	struct intel_mode *mode = crtc->mode;
-	unsigned int pitch = scrn->displayWidth * intel->cpp;
-	struct intel_pageflip *flip;
-	int i, old_fb_id;
+	struct intel_scanout *scanout;
+	PixmapPtr screen_pixmap;
+	BoxRec crtc_box;
+	int i, j, old_state;
 
-	/*
-	 * Create a new handle for the back buffer
-	 */
-	old_fb_id = mode->fb_id;
-	if (drmModeAddFB(mode->fd, scrn->virtualX, scrn->virtualY,
-			 scrn->depth, scrn->bitsPerPixel, pitch,
-			 new_front->handle, &mode->fb_id))
-		goto error_out;
+	if (mode->scanout_state == INTEL_SCANOUT_SPLIT)
+		return TRUE; /* nothing to do */
+
+	old_state = mode->scanout_state;
+	mode->scanout_state = INTEL_SCANOUT_SPLIT;
+
+	screen_pixmap = intel_get_scratch_front_pixmap(intel);
+
+	for (i = 0; i < config->num_crtc; i++) {
+		xf86CrtcPtr crtc = config->crtc[i];
+		if (!crtc->enabled)
+			continue;
+
+		intel_crtc_box(crtc, &crtc_box);
+
+		for (j = 0; j < MAX_SCANOUTS; j++) {
+			scanout = &mode->scanouts[j];
+			if (scanout->pixmap == NULL)
+				break; /* beyond the last valid entry */
+
+			if (crtc_box.x1 == scanout->area.x1 &&
+			    crtc_box.y1 == scanout->area.y1 &&
+			    crtc_box.x2 == scanout->area.x2 &&
+			    crtc_box.y2 == scanout->area.y2)
+				break; /* already have a scanout for this crtc */
+		}
+		if (j == MAX_SCANOUTS) {
+			xf86DrvMsg(intel->scrn->scrnIndex, X_WARNING,
+				   "failed to split framebuffer: all scanouts in use\n");
+			goto fail;
+		}
+
+		if (scanout->pixmap)
+			continue; /* already have a complete scanout for this crtc */
+
+		/* need to allocate a new scanout bo for this crtc */
+		scanout->pixmap = intel_create_split_fb(intel,
+				crtc->mode.HDisplay, crtc->mode.VDisplay);
+		if (!scanout->pixmap) {
+			xf86DrvMsg(intel->scrn->scrnIndex, X_WARNING,
+				   "failed to split framebuffer: allocation failure\n");
+			goto fail;
+		}
+
+		scanout->area.x1 = crtc_box.x1;
+		scanout->area.y1 = crtc_box.y1;
+		scanout->area.x2 = crtc_box.x2;
+		scanout->area.y2 = crtc_box.y2;
+
+		if (old_state == INTEL_SCANOUT_FRONT) {
+			/* copy current content from the front buffer */
+			intel_uxa_driver_copy_pixmap(intel,
+				screen_pixmap, scanout->pixmap,
+				crtc_box.x1, crtc_box.y1, 0, 0,
+				crtc_box.x2 - crtc_box.x1,
+				crtc_box.y2 - crtc_box.y1);
+		}
+	}
 
 	intel_batch_submit(scrn);
 
-	/*
-	 * Queue flips on all enabled CRTCs
-	 * Note that if/when we get per-CRTC buffers, we'll have to update this.
-	 * Right now it assumes a single shared fb across all CRTCs, with the
-	 * kernel fixing up the offset of each CRTC as necessary.
-	 *
-	 * Also, flips queued on disabled or incorrectly configured displays
-	 * may never complete; this is a configuration error.
-	 */
-	mode->fe_frame = 0;
-	mode->fe_tv_sec = 0;
-	mode->fe_tv_usec = 0;
+	for (i = 0; i < config->num_crtc; i++) {
+		xf86CrtcPtr crtc = config->crtc[i];
+		if (!crtc->enabled)
+			continue;
+
+		if (!intel_crtc_apply(crtc))
+			goto fail;
+	}
+
+	intel_free_scratch_front_pixmap(screen_pixmap);
+
+	return TRUE;
+
+fail:
+	mode->scanout_state = old_state;
+	intel_free_scratch_front_pixmap(screen_pixmap);
+	return FALSE;
+}
+
+static void
+intel_crtc_merge_scanouts(intel_screen_private *intel)
+{
+	struct intel_mode *mode = intel->modes;
+	PixmapPtr screen_pixmap;
+	int i, old_state;
+
+	old_state = mode->scanout_state;
+	mode->scanout_state = INTEL_SCANOUT_FRONT;
+
+	screen_pixmap = intel_get_scratch_front_pixmap(intel);
+
+	for (i = 0; i < MAX_SCANOUTS; i++) {
+		struct intel_scanout *scanout = &mode->scanouts[i];
+		if (scanout->pixmap == NULL)
+			continue;
+
+		if (old_state == INTEL_SCANOUT_SPLIT) {
+			/* copy current content from the split buffer */
+			intel_uxa_driver_copy_pixmap(intel,
+				scanout->pixmap, screen_pixmap,
+				0, 0,
+				scanout->area.x1, scanout->area.y1,
+				scanout->area.x2 - scanout->area.x1,
+				scanout->area.y2 - scanout->area.y1);
+		}
+
+		intel_destroy_scanout(scanout);
+	}
+
+	intel_free_scratch_front_pixmap(screen_pixmap);
+}
+
+void
+intel_merge_fb(intel_screen_private *intel)
+{
+	ScrnInfoPtr scrn = intel->scrn;
+	struct intel_mode *mode = intel->modes;
+	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
+	int i;
+
+	if (mode->scanout_state == INTEL_SCANOUT_FRONT)
+		return; /* nothing to do */
+
+	intel_crtc_merge_scanouts(intel);
+	intel_batch_submit(scrn);
 
 	for (i = 0; i < config->num_crtc; i++) {
-		if (!config->crtc[i]->enabled)
+		xf86CrtcPtr crtc = config->crtc[i];
+		if (!crtc->enabled)
 			continue;
 
-		mode->flip_info = flip_info;
-		mode->flip_count++;
+		if (!intel_crtc_apply(crtc))
+			continue; /* update as many crtcs as possible */
+	}
+}
+
+Bool
+intel_find_scanout(intel_screen_private *intel, BoxPtr area,
+		   struct intel_scanout **out_scanout)
+{
+	struct intel_mode *mode = intel->modes;
+	BoxRec intersect_box;
+	int i;
+
+	*out_scanout = NULL;
+
+	if (mode->scanout_state != INTEL_SCANOUT_SPLIT)
+		return TRUE; /* always use screen buffer */
+
+	for (i = 0; i < MAX_SCANOUTS; i++) {
+		struct intel_scanout *scanout = &mode->scanouts[i];
+		if (scanout->pixmap == NULL)
+			continue;
+
+		if (scanout->area.x1 == area->x1 &&
+		    scanout->area.y1 == area->y1 &&
+		    scanout->area.x2 == area->x2 &&
+		    scanout->area.y2 == area->y2) {
+			*out_scanout = scanout;
+			return TRUE;
+		}
+
+		intel_box_intersect(&intersect_box, &scanout->area, area);
+		if (intersect_box.x1 != intersect_box.x2 ||
+		    intersect_box.y1 != intersect_box.y2) {
+			/* partial intersection; must merge to use area. */
+			return FALSE;
+		}
+	}
 
-		crtc = config->crtc[i]->driver_private;
+	/* did not intersect any scanouts; use the screen. */
+	return TRUE;
+}
 
-		flip = calloc(1, sizeof(struct intel_pageflip));
-		if (flip == NULL) {
+Bool
+intel_covering_scanout(intel_screen_private *intel, BoxPtr area,
+		       struct intel_scanout **out_scanout)
+{
+	struct intel_mode *mode = intel->modes;
+	BoxRec intersect_box;
+	int i;
+
+	*out_scanout = NULL;
+
+	if (mode->scanout_state != INTEL_SCANOUT_SPLIT)
+		return TRUE; /* always use screen buffer */
+
+	for (i = 0; i < MAX_SCANOUTS; i++) {
+		struct intel_scanout *scanout = &mode->scanouts[i];
+		if (scanout->pixmap == NULL)
+			continue;
+
+		if (scanout->area.x1 <= area->x1 &&
+		    scanout->area.y1 <= area->y1 &&
+		    scanout->area.x2 >= area->x2 &&
+		    scanout->area.y2 >= area->y2) {
+			*out_scanout = scanout;
+			return TRUE;
+		}
+
+		intel_box_intersect(&intersect_box, &scanout->area, area);
+		if (intersect_box.x1 != intersect_box.x2 ||
+		    intersect_box.y1 != intersect_box.y2) {
+			/* partial intersection; must merge to use area. */
+			return FALSE;
+		}
+	}
+
+	/* did not intersect any scanouts; use the screen. */
+	return TRUE;
+}
+
+Bool
+intel_do_pageflip(intel_screen_private *intel,
+		  PixmapPtr new_front,
+		  DRI2FrameEventPtr flip_info)
+{
+	struct intel_mode *mode = intel->modes;
+	ScrnInfoPtr scrn = intel->scrn;
+	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
+	struct intel_pageflip **flip_data = NULL;
+	uint32_t new_front_fb_id;
+	struct intel_crtc *reference_crtc;
+	BoxRec crtc_box, intersect_box;
+	int i, ret;
+
+	if (mode->scanout_state == INTEL_SCANOUT_INVALID) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+			"flip queue failed: scanout state not configured.\n");
+		return FALSE;
+	}
+
+	new_front_fb_id = intel_pixmap_ensure_fb(intel, new_front);
+	if (new_front_fb_id == 0)
+		goto error_undo;
+
+	flip_data = calloc(config->num_crtc, sizeof(*flip_data));
+	if (!flip_data) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+			"flip queue failed: memory allocation error.\n");
+		goto error_undo;
+	}
+
+	/* Find the reference CRTC, check safety and allocate flip data. */
+	reference_crtc = NULL;
+	for (i = 0; i < config->num_crtc; i++) {
+		xf86CrtcPtr crtc = config->crtc[i];
+		struct intel_crtc *intel_crtc = crtc->driver_private;
+		if (!crtc->enabled)
+			continue;
+
+		if (flip_info->pipe == intel_crtc->pipe)
+			reference_crtc = intel_crtc;
+
+		intel_crtc_box(crtc, &crtc_box);
+		intel_box_intersect(&intersect_box, &crtc_box, &flip_info->area);
+
+		if (intersect_box.x1 == intersect_box.x2 ||
+		    intersect_box.y1 == intersect_box.y2) {
+			/* Skip crtcs unaffected by this update. */
+			if (reference_crtc == intel_crtc) {
+				xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+					"flip queue failed: updated area does "
+					"not include the reference crtc.\n");
+				goto error_undo;
+			}
+			continue;
+		}
+
+		if (intersect_box.x1 != crtc_box.x1 ||
+		    intersect_box.y1 != crtc_box.y1 ||
+		    intersect_box.x2 != crtc_box.x2 ||
+		    intersect_box.y2 != crtc_box.y2) {
 			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "flip queue: carrier alloc failed.\n");
+				"flip queue failed: updated area partially "
+				"intersects crtc %d.\n",
+				crtc_id(intel_crtc));
 			goto error_undo;
 		}
 
-		/* Only the reference crtc will finally deliver its page flip
-		 * completion event. All other crtc's events will be discarded.
-		 */
-		flip->dispatch_me = (intel_crtc_to_pipe(crtc->crtc) == ref_crtc_hw_id);
-		flip->mode = mode;
+		flip_data[i] = calloc(1, sizeof(**flip_data));
+		if (!flip_data[i]) {
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+				"flip queue failed: memory allocation error.\n");
+			goto error_undo;
+		}
+	}
+	if (reference_crtc == NULL) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+			"flip queue failed: no reference crtc for pipe %d.\n",
+			flip_info->pipe);
+		goto error_undo;
+	}
+	if (reference_crtc->flip.info) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+			"flip queue failed: reference crtc %d (for pipe %d) "
+			"already has a flip pending.\n",
+			crtc_id(reference_crtc),
+			flip_info->pipe);
+		goto error_undo;
+	}
+
+	intel_batch_submit(scrn);
+
+	reference_crtc->flip.pending = 0;
+	reference_crtc->flip.frame = 0;
+	reference_crtc->flip.tv_sec = 0;
+	reference_crtc->flip.tv_usec = 0;
+
+	/* Defer storing the flip info until we have successfully queued all of
+	 * the flips. If this function returns FALSE, the caller will free the
+	 * flip_info structure, so any successful flips must not access it.
+	 */
+	reference_crtc->flip.info = NULL;
+
+	/*
+	 * Queue flips on all updated CRTCs.
+	 * Flips queued on disabled or incorrectly-configured crtcs may never
+	 * complete. This type of configuration error will result in the
+	 * flip never completing, and leak some objects.
+	 */
+	for (i = 0; i < config->num_crtc; i++) {
+		struct intel_crtc *intel_crtc = config->crtc[i]->driver_private;
+		if (!flip_data[i])
+			continue;
+
+		flip_data[i]->reference_crtc = reference_crtc;
+		flip_data[i]->flipped_crtc = intel_crtc;
 
-		if (drmModePageFlip(mode->fd,
-				    crtc_id(crtc),
-				    mode->fb_id,
-				    DRM_MODE_PAGE_FLIP_EVENT, flip)) {
+		ret = drmModePageFlip(mode->fd,
+				      crtc_id(intel_crtc),
+				      new_front_fb_id,
+				      DRM_MODE_PAGE_FLIP_EVENT,
+				      flip_data[i]);
+		if (ret < 0) {
 			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "flip queue failed: %s\n", strerror(errno));
-			free(flip);
+				"flip queue failed: error flipping crtc %d: %s\n",
+				crtc_id(intel_crtc), strerror(-ret));
 			goto error_undo;
 		}
+		/* The flip_data object will be freed when the flip completes. */
+		flip_data[i] = NULL;
+
+		reference_crtc->flip.pending++;
 	}
 
-	mode->old_fb_id = old_fb_id;
+	reference_crtc->flip.info = flip_info;
+	free(flip_data);
 	return TRUE;
 
 error_undo:
-	drmModeRmFB(mode->fd, mode->fb_id);
-	mode->fb_id = old_fb_id;
-
-error_out:
-	xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Page flip failed: %s\n",
-		   strerror(errno));
+	if (flip_data) {
+		/* Free any unused flip data objects. */
+		for (i = 0; i < config->num_crtc; i++) {
+			free(flip_data[i]);
+		}
+		free(flip_data);
+	}
 	return FALSE;
 }
 
@@ -1635,31 +2090,33 @@ intel_page_flip_handler(int fd, unsigned int frame, unsigned int tv_sec,
 			  unsigned int tv_usec, void *event_data)
 {
 	struct intel_pageflip *flip = event_data;
-	struct intel_mode *mode = flip->mode;
-
-	/* Is this the event whose info shall be delivered to higher level? */
-	if (flip->dispatch_me) {
-		/* Yes: Cache msc, ust for later delivery. */
-		mode->fe_frame = frame;
-		mode->fe_tv_sec = tv_sec;
-		mode->fe_tv_usec = tv_usec;
+	struct intel_crtc *reference_crtc = flip->reference_crtc;
+	struct intel_crtc *flipped_crtc = flip->flipped_crtc;
+
+	if (reference_crtc == flipped_crtc) {
+		/* Cache information from the reference crtc's flip for the event handler. */
+		reference_crtc->flip.frame = frame;
+		reference_crtc->flip.tv_sec = tv_sec;
+		reference_crtc->flip.tv_usec = tv_usec;
 	}
+
 	free(flip);
 
-	/* Last crtc completed flip? */
-	mode->flip_count--;
-	if (mode->flip_count > 0)
+	/* Was this the last pending flip? */
+	reference_crtc->flip.pending--;
+	if (reference_crtc->flip.pending > 0)
 		return;
 
-	/* Release framebuffer */
-	drmModeRmFB(mode->fd, mode->old_fb_id);
-
-	if (mode->flip_info == NULL)
+	if (reference_crtc->flip.info == NULL)
 		return;
 
-	/* Deliver cached msc, ust from reference crtc to flip event handler */
-	I830DRI2FlipEventHandler(mode->fe_frame, mode->fe_tv_sec,
-				 mode->fe_tv_usec, mode->flip_info);
+	/* Deliver cached info from reference crtc to flip event handler */
+	I830DRI2FlipEventHandler(
+		reference_crtc->flip.frame,
+		reference_crtc->flip.tv_sec,
+		reference_crtc->flip.tv_usec,
+		reference_crtc->flip.info);
+	reference_crtc->flip.info = NULL;
 }
 
 static void
@@ -1714,6 +2171,7 @@ Bool intel_mode_pre_init(ScrnInfoPtr scrn, int fd, int cpp)
 
 	for (i = 0; i < mode->mode_res->count_connectors; i++)
 		intel_output_init(scrn, mode, i);
+		intel_output_init(scrn, mode, i);
 
 	xf86InitialConfiguration(scrn, TRUE);
 
@@ -1746,7 +2204,6 @@ intel_mode_init(struct intel_screen_private *intel)
 		 * feedback on every server generation, so perform the
 		 * registration within ScreenInit and not PreInit.
 		 */
-		mode->flip_count = 0;
 		AddGeneralSocket(mode->fd);
 		RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
 					       drm_wakeup_handler, mode);
@@ -1758,9 +2215,9 @@ intel_mode_remove_fb(intel_screen_private *intel)
 {
 	struct intel_mode *mode = intel->modes;
 
-	if (mode->fb_id) {
-		drmModeRmFB(mode->fd, mode->fb_id);
-		mode->fb_id = 0;
+	if (mode->front_fb_id != 0) {
+		drmModeRmFB(mode->fd, mode->front_fb_id);
+		mode->front_fb_id = 0;
 	}
 }
 
@@ -1768,6 +2225,7 @@ void
 intel_mode_fini(intel_screen_private *intel)
 {
 	struct intel_mode *mode = intel->modes;
+	int i;
 
 	while(!list_is_empty(&mode->crtcs)) {
 		xf86CrtcDestroy(list_first_entry(&mode->crtcs,
@@ -1781,8 +2239,9 @@ intel_mode_fini(intel_screen_private *intel)
 						   link)->output);
 	}
 
-	if (mode->fb_id)
-		drmModeRmFB(mode->fd, mode->fb_id);
+	for (i = 0; i < MAX_SCANOUTS; i++) {
+		intel_destroy_scanout(&mode->scanouts[i]);
+	}
 
 	/* mode->rotate_fb_id should have been destroyed already */
 
diff --git a/src/intel_dri.c b/src/intel_dri.c
index 938a022..d8768a6 100644
--- a/src/intel_dri.c
+++ b/src/intel_dri.c
@@ -457,6 +457,12 @@ I830DRI2CopyRegion(DrawablePtr drawable, RegionPtr pRegion,
 		? drawable : &dstPrivate->pixmap->drawable;
 	RegionPtr pCopyClip;
 	GCPtr gc;
+	BoxRec draw_box;
+	struct intel_scanout *scanout;
+
+	if (pRegion->extents.x1 == pRegion->extents.x2 ||
+	    pRegion->extents.y1 == pRegion->extents.y2)
+		return; /* nothing actually being copied */
 
 	gc = GetScratchGC(dst->depth, screen);
 	if (!gc)
@@ -542,6 +548,22 @@ I830DRI2CopyRegion(DrawablePtr drawable, RegionPtr pRegion,
 		}
 	}
 
+	if (pixmap_is_scanout(get_drawable_pixmap(dst))) {
+		intel_drawable_box(drawable, &draw_box);
+		if (!intel_find_scanout(intel, &draw_box, &scanout) || scanout == NULL)
+			intel_merge_fb(intel);
+		else
+			dst = &scanout->pixmap->drawable;
+	}
+
+	if (pixmap_is_scanout(get_drawable_pixmap(src))) {
+		intel_drawable_box(drawable, &draw_box);
+		if (!intel_find_scanout(intel, &draw_box, &scanout) || scanout == NULL)
+			intel_merge_fb(intel);
+		else
+			src = &scanout->pixmap->drawable;
+	}
+
 	/* It's important that this copy gets submitted before the
 	 * direct rendering client submits rendering for the next
 	 * frame, but we don't actually need to submit right now.  The
@@ -764,10 +786,11 @@ i830_dri2_del_frame_event(DrawablePtr drawable, DRI2FrameEventPtr info)
 static void
 I830DRI2ExchangeBuffers(DrawablePtr draw, DRI2BufferPtr front, DRI2BufferPtr back)
 {
+	ScreenPtr pScreen = draw->pScreen;
+	ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
+	intel_screen_private *intel = intel_get_screen_private(scrn);
 	I830DRI2BufferPrivatePtr front_priv, back_priv;
 	struct intel_pixmap *front_intel, *back_intel;
-	ScreenPtr screen;
-	intel_screen_private *intel;
 	int tmp;
 
 	front_priv = front->driverPrivate;
@@ -784,14 +807,42 @@ I830DRI2ExchangeBuffers(DrawablePtr draw, DRI2BufferPtr front, DRI2BufferPtr bac
 	intel_set_pixmap_private(front_priv->pixmap, back_intel);
 	intel_set_pixmap_private(back_priv->pixmap, front_intel);
 
-	screen = draw->pScreen;
-	intel = intel_get_screen_private(xf86Screens[screen->myNum]);
-
 	dri_bo_unreference (intel->front_buffer);
 	intel->front_buffer = back_intel->bo;
 	dri_bo_reference (intel->front_buffer);
 
-	intel_set_pixmap_private(screen->GetScreenPixmap(screen), back_intel);
+	intel_set_pixmap_private(pScreen->GetScreenPixmap(pScreen), back_intel);
+	back_intel->busy = 1;
+	front_intel->busy = -1;
+}
+
+static void
+I830DRI2ExchangeBuffersSplit(DrawablePtr draw, DRI2BufferPtr front, DRI2BufferPtr back)
+{
+	ScreenPtr pScreen = draw->pScreen;
+	ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	I830DRI2BufferPrivatePtr back_priv;
+	struct intel_pixmap *front_intel, *back_intel;
+	struct intel_scanout *scanout;
+	BoxRec draw_box;
+
+	back_priv = back->driverPrivate;
+
+	intel_drawable_box(draw, &draw_box);
+	if (!intel_find_scanout(intel, &draw_box, &scanout) || scanout == NULL) {
+		xf86DrvMsg(intel->scrn->scrnIndex, X_WARNING,
+			   "failed to exchange with scanout");
+		return;
+	}
+
+	front_intel = intel_get_pixmap_private(scanout->pixmap);
+	back_intel = intel_get_pixmap_private(back_priv->pixmap);
+	intel_set_pixmap_private(scanout->pixmap, back_intel);
+	intel_set_pixmap_private(back_priv->pixmap, front_intel);
+
+	back->name = pixmap_flink(back_priv->pixmap);
+
 	back_intel->busy = 1;
 	front_intel->busy = -1;
 }
@@ -806,16 +857,19 @@ I830DRI2ScheduleFlip(struct intel_screen_private *intel,
 		     DRI2FrameEventPtr info)
 {
 	I830DRI2BufferPrivatePtr priv = info->back->driverPrivate;
-	drm_intel_bo *new_back, *old_back;
+	drm_intel_bo *new_back;
 
 	if (!intel->use_triple_buffer) {
-		if (!intel_do_pageflip(intel,
-				       intel_get_pixmap_bo(priv->pixmap),
-				       info, info->pipe))
+		if (!intel_do_pageflip(intel, priv->pixmap, info))
 			return FALSE;
 
-		info->type = DRI2_SWAP;
-		I830DRI2ExchangeBuffers(draw, info->front, info->back);
+		if (info->type == DRI2_FLIP_SPLIT) {
+			info->type = DRI2_SWAP;
+			I830DRI2ExchangeBuffersSplit(draw, info->front, info->back);
+		} else {
+			info->type = DRI2_SWAP;
+			I830DRI2ExchangeBuffers(draw, info->front, info->back);
+		}
 		return TRUE;
 	}
 
@@ -846,8 +900,7 @@ I830DRI2ScheduleFlip(struct intel_screen_private *intel,
 		intel->back_buffer = NULL;
 	}
 
-	old_back = intel_get_pixmap_bo(priv->pixmap);
-	if (!intel_do_pageflip(intel, old_back, info, info->pipe)) {
+	if (!intel_do_pageflip(intel, priv->pixmap, info)) {
 		intel->back_buffer = new_back;
 		return FALSE;
 	}
@@ -916,6 +969,79 @@ can_exchange(DrawablePtr drawable, DRI2BufferPtr front, DRI2BufferPtr back)
 	return TRUE;
 }
 
+static Bool
+can_exchange_split(DrawablePtr drawable, DRI2BufferPtr front, DRI2BufferPtr back)
+{
+	struct intel_screen_private *intel = intel_get_screen_private(xf86Screens[drawable->pScreen->myNum]);
+	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(intel->scrn);
+	I830DRI2BufferPrivatePtr front_priv = front->driverPrivate;
+	I830DRI2BufferPrivatePtr back_priv = back->driverPrivate;
+	PixmapPtr front_pixmap = front_priv->pixmap;
+	PixmapPtr back_pixmap = back_priv->pixmap;
+	struct intel_pixmap *front_intel = intel_get_pixmap_private(front_pixmap);
+	struct intel_pixmap *back_intel = intel_get_pixmap_private(back_pixmap);
+	WindowPtr draw_win;
+	Bool found_match, found_conflict;
+	BoxRec draw_box, crtc_box, intersect_box;
+	int i;
+
+	if (drawable == NULL ||
+	    drawable->type != DRAWABLE_WINDOW ||
+	    intel->shadow_present ||
+	    !intel->use_pageflipping ||
+	    !intel->use_split_framebuffer)
+		return FALSE;
+
+	if (!pixmap_is_scanout(front_pixmap))
+		return FALSE;
+
+	/* Reject cases where the drawable and backing store have different
+	 * sizes. This occurs occasionally when a resize and an update happen
+	 * simultaneously. */
+	if (drawable->width != back_pixmap->drawable.width ||
+	    drawable->height != back_pixmap->drawable.height)
+		return FALSE;
+
+	/* Reported depth differs because the scanout pixmap has no alpha,
+         * however the formats are still interchangeable. */
+	if (front_pixmap->drawable.bitsPerPixel != back_pixmap->drawable.bitsPerPixel ||
+	    front_intel->tiling != back_intel->tiling)
+		return FALSE;
+
+	/* Can only do a split exchange if the window is completely exposed. */
+	draw_win = (WindowPtr)drawable;
+	if (!RegionEqual(&draw_win->clipList, &draw_win->winSize))
+		return FALSE;
+
+	/* Only split if the area matches at least one crtc, and does not
+	 * partially intersect any crtcs. */
+	found_match = FALSE;
+	found_conflict = FALSE;
+	intel_drawable_box(drawable, &draw_box);
+	for (i = 0; i < config->num_crtc; i++) {
+		xf86CrtcPtr crtc = config->crtc[i];
+		if (!crtc->enabled)
+			continue;
+
+		intel_crtc_box(crtc, &crtc_box);
+		if (crtc_box.x1 == draw_box.x1 &&
+		    crtc_box.y1 == draw_box.y1 &&
+		    crtc_box.x2 == draw_box.x2 &&
+		    crtc_box.y2 == draw_box.y2) {
+			/* regions are equal, so can flip with this crtc */
+			found_match = TRUE;
+			continue;
+		}
+
+		/* not equal, so any intersection indicates a conflict */
+		intel_box_intersect(&intersect_box, &draw_box, &crtc_box);
+		if (intersect_box.x1 != intersect_box.x2 &&
+		    intersect_box.y1 != intersect_box.y2)
+			found_conflict = TRUE;
+	}
+	return found_match && !found_conflict;
+}
+
 void I830DRI2FrameEventHandler(unsigned int frame, unsigned int tv_sec,
 			       unsigned int tv_usec, DRI2FrameEventPtr swap_info)
 {
@@ -935,11 +1061,18 @@ void I830DRI2FrameEventHandler(unsigned int frame, unsigned int tv_sec,
 
 
 	switch (swap_info->type) {
-	case DRI2_FLIP:
+	case DRI2_FLIP_SPLIT:
+		if (can_exchange_split(drawable, swap_info->front, swap_info->back)) {
+			if (I830DRI2ScheduleFlip(intel, drawable, swap_info))
+				return;
+		}
+
+	case DRI2_FLIP_FRONT:
 		/* If we can still flip... */
-		if (can_exchange(drawable, swap_info->front, swap_info->back) &&
-		    I830DRI2ScheduleFlip(intel, drawable, swap_info))
-			return;
+		if (can_exchange(drawable, swap_info->front, swap_info->back)) {
+			if (I830DRI2ScheduleFlip(intel, drawable, swap_info))
+				return;
+		}
 
 		/* else fall through to exchange/blit */
 	case DRI2_SWAP: {
@@ -1124,6 +1257,7 @@ I830DRI2ScheduleSwap(ClientPtr client, DrawablePtr draw, DRI2BufferPtr front,
 	swap_info->front = front;
 	swap_info->back = back;
 	swap_info->pipe = I830DRI2DrawablePipe(draw);
+	intel_drawable_box(draw, &swap_info->area);
 
 	if (!i830_dri2_add_frame_event(swap_info)) {
 	    free(swap_info);
@@ -1151,7 +1285,13 @@ I830DRI2ScheduleSwap(ClientPtr client, DrawablePtr draw, DRI2BufferPtr front,
 
 	/* Flips need to be submitted one frame before */
 	if (can_exchange(draw, front, back)) {
-		swap_type = DRI2_FLIP;
+		intel_merge_fb(intel);
+		swap_type = DRI2_FLIP_FRONT;
+		flip = 1;
+	} else if (can_exchange_split(draw, front, back)) {
+		if (!intel_split_fb(intel))
+			goto blit_fallback;
+		swap_type = DRI2_FLIP_SPLIT;
 		flip = 1;
 	} else {
 		/* Using the DRI2_SWAP path defers the back-to-front blit until
@@ -1163,7 +1303,7 @@ I830DRI2ScheduleSwap(ClientPtr client, DrawablePtr draw, DRI2BufferPtr front,
 	}
 	swap_info->type = swap_type;
 
-	/* Correct target_msc by 'flip' if swap_type == DRI2_FLIP.
+	/* Correct target_msc by 'flip' if swap_type == DRI2_FLIP_*.
 	 * Do it early, so handling of different timing constraints
 	 * for divisor, remainder and msc vs. target_msc works.
 	 */
diff --git a/src/intel_driver.c b/src/intel_driver.c
index cdd7713..12ff9a1 100644
--- a/src/intel_driver.c
+++ b/src/intel_driver.c
@@ -101,6 +101,7 @@ typedef enum {
    OPTION_DEBUG_WAIT,
    OPTION_HOTPLUG,
    OPTION_RELAXED_FENCING,
+   OPTION_SPLIT_FRAMEBUFFER,
 } I830Opts;
 
 static OptionInfoRec I830Options[] = {
@@ -122,6 +123,7 @@ static OptionInfoRec I830Options[] = {
    {OPTION_DEBUG_WAIT, "DebugWait", OPTV_BOOLEAN, {0}, FALSE},
    {OPTION_HOTPLUG,	"HotPlug",	OPTV_BOOLEAN,	{0},	TRUE},
    {OPTION_RELAXED_FENCING,	"RelaxedFencing",	OPTV_BOOLEAN,	{0},	TRUE},
+   {OPTION_SPLIT_FRAMEBUFFER,	"SplitFramebuffer",	OPTV_BOOLEAN,	{0},	TRUE},
    {-1,			NULL,		OPTV_NONE,	{0},	FALSE}
 };
 /* *INDENT-ON* */
@@ -669,6 +671,14 @@ static Bool I830PreInit(ScrnInfoPtr scrn, int flags)
 	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "Triple buffering? %s\n",
 		   intel->use_triple_buffer ? "enabled" : "disabled");
 
+	intel->use_split_framebuffer =
+		xf86ReturnOptValBool(intel->Options,
+				     OPTION_SPLIT_FRAMEBUFFER,
+				     TRUE);
+	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "Split framebuffer? %s\n",
+		   intel->use_split_framebuffer ? "enabled" : "disabled");
+
+
 	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "Framebuffer %s\n",
 		   intel->tiling & INTEL_TILING_FB ? "tiled" : "linear");
 	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "Pixmaps %s\n",
diff --git a/src/intel_uxa.c b/src/intel_uxa.c
index b55b285..c811fbe 100644
--- a/src/intel_uxa.c
+++ b/src/intel_uxa.c
@@ -636,6 +636,7 @@ void intel_set_pixmap_bo(PixmapPtr pixmap, dri_bo * bo)
 		if (priv->bo == bo)
 			return;
 
+		intel_pixmap_remove_fb(intel, pixmap);
 		priv->dst_bound = priv->src_bound = 0;
 		if (list_is_empty(&priv->batch)) {
 			dri_bo_unreference(priv->bo);
@@ -704,6 +705,9 @@ static Bool intel_uxa_prepare_access(PixmapPtr pixmap, uxa_access_t access)
 	dri_bo *bo = priv->bo;
 	int ret;
 
+	if (pixmap_is_scanout(pixmap))
+		intel_merge_fb(intel);
+
 	if (!list_is_empty(&priv->batch) &&
 	    (access == UXA_ACCESS_RW || priv->batch_write))
 		intel_batch_submit(scrn);
@@ -765,8 +769,13 @@ static Bool intel_uxa_put_image(PixmapPtr pixmap,
 				int w, int h,
 				char *src, int src_pitch)
 {
+	ScrnInfoPtr scrn = xf86Screens[pixmap->drawable.pScreen->myNum];
+	intel_screen_private *intel = intel_get_screen_private(scrn);
 	struct intel_pixmap *priv;
 
+	if (pixmap_is_scanout(pixmap))
+		intel_merge_fb(intel);
+
 	priv = intel_get_pixmap_private(pixmap);
 	if (!intel_pixmap_is_busy(priv)) {
 		/* bo is not busy so can be replaced without a stall, upload in-place. */
@@ -882,6 +891,8 @@ static Bool intel_uxa_get_image(PixmapPtr pixmap,
 				int w, int h,
 				char *dst, int dst_pitch)
 {
+	ScrnInfoPtr scrn = xf86Screens[pixmap->drawable.pScreen->myNum];
+	intel_screen_private *intel = intel_get_screen_private(scrn);
 	struct intel_pixmap *priv;
 	PixmapPtr scratch = NULL;
 	Bool ret;
@@ -893,6 +904,24 @@ static Bool intel_uxa_get_image(PixmapPtr pixmap,
 	 * Also the gpu is much faster at detiling.
 	 */
 
+	if (pixmap_is_scanout(pixmap)) {
+		struct intel_scanout *scanout;
+		BoxRec get_box;
+
+		get_box.x1 = x;
+		get_box.x2 = x + w;
+		get_box.y1 = y;
+		get_box.y2 = y + h;
+		if (!intel_covering_scanout(intel, &get_box, &scanout) || scanout == NULL) {
+			intel_merge_fb(intel);
+		} else {
+			/* Adjust the copy to come from the scanout. */
+			pixmap = scanout->pixmap;
+			x -= scanout->area.x1;
+			y -= scanout->area.y1;
+		}
+	}
+
 	priv = intel_get_pixmap_private(pixmap);
 	if (intel_pixmap_is_busy(priv) || priv->tiling != I915_TILING_NONE) {
 		ScreenPtr screen = pixmap->drawable.pScreen;
@@ -1191,6 +1220,25 @@ intel_limits_init(intel_screen_private *intel)
 	}
 }
 
+Bool
+intel_uxa_driver_copy_pixmap(intel_screen_private *intel,
+			     PixmapPtr src, PixmapPtr dst,
+			     int src_x, int src_y,
+			     int dst_x, int dst_y,
+			     int w, int h)
+{
+	if (!intel->uxa_driver->check_copy(src, dst, GXcopy, FB_ALLONES))
+		return FALSE;
+
+	if (!intel->uxa_driver->prepare_copy(src, dst, -1, -1,
+					     GXcopy, FB_ALLONES))
+		return FALSE;
+
+	intel->uxa_driver->copy(dst, src_x, src_y, dst_x, dst_y, w, h);
+	intel->uxa_driver->done_copy(dst);
+	return TRUE;
+}
+
 Bool intel_uxa_init(ScreenPtr screen)
 {
 	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
diff --git a/src/intel_video.c b/src/intel_video.c
index 021ca5f..17fd0d7 100644
--- a/src/intel_video.c
+++ b/src/intel_video.c
@@ -1033,7 +1033,7 @@ I830CopyPlanarData(intel_adaptor_private *adaptor_priv,
 	return TRUE;
 }
 
-static void intel_box_intersect(BoxPtr dest, BoxPtr a, BoxPtr b)
+void intel_box_intersect(BoxPtr dest, BoxPtr a, BoxPtr b)
 {
 	dest->x1 = a->x1 > b->x1 ? a->x1 : b->x1;
 	dest->x2 = a->x2 < b->x2 ? a->x2 : b->x2;
@@ -1043,7 +1043,7 @@ static void intel_box_intersect(BoxPtr dest, BoxPtr a, BoxPtr b)
 		dest->x1 = dest->x2 = dest->y1 = dest->y2 = 0;
 }
 
-static void intel_crtc_box(xf86CrtcPtr crtc, BoxPtr crtc_box)
+void intel_crtc_box(xf86CrtcPtr crtc, BoxPtr crtc_box)
 {
 	if (crtc->enabled) {
 		crtc_box->x1 = crtc->x;
@@ -1056,6 +1056,13 @@ static void intel_crtc_box(xf86CrtcPtr crtc, BoxPtr crtc_box)
 		crtc_box->x1 = crtc_box->x2 = crtc_box->y1 = crtc_box->y2 = 0;
 }
 
+void intel_drawable_box(DrawablePtr draw, BoxPtr draw_box) {
+	draw_box->x1 = draw->x;
+	draw_box->x2 = draw->x + draw->width;
+	draw_box->y1 = draw->y;
+	draw_box->y2 = draw->y + draw->height;
+}
+
 static int intel_box_area(BoxPtr box)
 {
 	return (int)(box->x2 - box->x1) * (int)(box->y2 - box->y1);
-- 
1.7.7.3

