From: Ang Pan <oscarpan@chromium.org>
Subject: [PATCH] Accelerate wheel scrolling
---
 include/evdev-properties.h |    4 +
 src/evdev.c                |  207 ++++++++++++++++++++++++++++++++++++++------
 src/evdev.h                |   12 +++
 3 files changed, 198 insertions(+), 25 deletions(-)

diff --git a/include/evdev-properties.h b/include/evdev-properties.h
index 745a1ba..66e8a75 100644
--- a/include/evdev-properties.h
+++ b/include/evdev-properties.h
@@ -87,4 +87,8 @@
 */
 #define EVDEV_PROP_FUNCTION_KEYS "Evdev Function Keys"
 
+/* Mouse scroll wheel axes acceleration. */
+/* BOOL */
+#define EVDEV_PROP_WHEEL_ACCEL_AXES "Evdev Wheel Axes Acceleration"
+
 #endif
diff --git a/src/evdev.c b/src/evdev.c
index 54772c7..a75dcc5 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -93,6 +93,9 @@
 #define ABS_MT_TRACKING_ID 0x39
 #endif
 
+#define AXIS_LABEL_PROP_ABS_DBL_START_TIME  "Abs Dbl Start Timestamp"
+#define AXIS_LABEL_PROP_ABS_DBL_END_TIME    "Abs Dbl End Timestamp"
+
 static const char *evdevDefaults[] = {
     "XkbRules",     "evdev",
     "XkbModel",     "evdev",
@@ -134,6 +137,7 @@ static Atom prop_axis_label;
 static Atom prop_btn_label;
 static Atom prop_device;
 static Atom prop_virtual;
+static Atom prop_wheel_accel_axes;
 
 /* All devices the evdev driver has allocated and knows about.
  * MAXDEVICES is safe as null-terminated array, as two devices (VCP and VCK)
@@ -670,6 +674,89 @@ EvdevProcessButtonEvent(InputInfoPtr pInfo, struct input_event *ev)
         EvdevQueueKbdEvent(pInfo, ev, value);
 }
 
+#ifndef HAVE_SMOOTH_SCROLLING
+/**
+ * Normal CDF seems like a good curve to simulate scroll wheel acceleration
+ * curve. Use following methods to generate the coefficients of a degree-4
+ * polynomial regression for a specific normal cdf in matlab.
+ *
+ * Note: x for click_speed, y for scroll pixels.
+ * In reality, x ranges from 1 to 120+ for an Apple Mighty Mouse, use range
+ * greater than that to minimize approximation error at the end points.
+ * In our case, the range is [-50, 200].
+ *
+ * matlab code to generate accel_params below:
+ * x=[-50:200];
+ * y=600*normcdf(x,77,40);
+ * a=polyfit(x,y,4);
+ */
+static const double accel_params[] = {
+    -9.528484576366295e-08,
+    -1.515738095456648e-04,
+    3.940238948978762e-02,
+    1.732410732791920,
+    4.412651786252371,
+};
+
+/**
+ * Get the number of pixels to scroll, used for axes_scroll.
+ */
+static double
+EvdevGetPixelsToScroll(double click_speed)
+{
+    double pixels = 0;
+    double term = 1;
+    int i;
+    for (i = 1; i <= ArrayLength(accel_params); i++)
+    {
+        pixels += term * accel_params[ArrayLength(accel_params) - i];
+        term *= fabs(click_speed);
+    }
+    if (click_speed < 0)
+        pixels *= -1;
+    return pixels;
+}
+
+/**
+ * Mouse scroll acceleration.
+ */
+static void
+EvdevAccelWheel(InputInfoPtr pInfo, int wheel_button, int value,
+                double start_time, double end_time)
+{
+    double pixels;
+    double dt; /* seconds */
+    double click_speed; /* clicks / second */
+    EvdevPtr pEvdev = pInfo->private;
+
+    if (!pEvdev->wheelAccelRec.scroll_axes)
+    {
+        EvdevQueueButtonClicks(pInfo, wheel_button, abs(value));
+        return;
+    }
+
+    /* If start_time == end_time, compute click_speed using dt = 1 second */
+    dt = (end_time - start_time) ?: 1.0;
+    click_speed = value / dt;
+    pixels = EvdevGetPixelsToScroll(click_speed);
+
+    valuator_mask_zero(pEvdev->vals);
+    if (wheel_button == wheel_down_button || wheel_button == wheel_up_button)
+        valuator_mask_set_double(pEvdev->vals, pEvdev->axis_map[REL_WHEEL],
+                                 -pixels);
+    else
+        valuator_mask_set_double(pEvdev->vals, pEvdev->axis_map[REL_HWHEEL],
+                                 pixels);
+    if (pEvdev->start_time_valuator_index >= 0)
+       valuator_mask_set_double(pEvdev->vals,
+                                pEvdev->start_time_valuator_index, start_time);
+    if (pEvdev->end_time_valuator_index >= 0)
+        valuator_mask_set_double(pEvdev->vals,
+                                 pEvdev->end_time_valuator_index, end_time);
+    xf86PostMotionEventM(pInfo->dev, TRUE, pEvdev->vals);
+}
+#endif
+
 /**
  * Take the relative motion input event and process it accordingly.
  */
@@ -679,27 +766,50 @@ EvdevProcessRelativeMotionEvent(InputInfoPtr pInfo, struct input_event *ev)
     int value;
     EvdevPtr pEvdev = pInfo->private;
     int map;
+    int last_wheel_button, current_wheel_button;
+    double start_time, end_time;
 
     /* Get the signed value, earlier kernels had this as unsigned */
     value = ev->value;
+    end_time = ev->time.tv_sec + ev->time.tv_usec / 1000000.0;
 
     switch (ev->code) {
 #ifndef HAVE_SMOOTH_SCROLLING
         case REL_WHEEL:
-            if (value > 0)
-                EvdevQueueButtonClicks(pInfo, wheel_up_button, value);
-            else if (value < 0)
-                EvdevQueueButtonClicks(pInfo, wheel_down_button, -value);
+            last_wheel_button = pEvdev->wheelAccelRec.lastWheelButtonVertical;
+            current_wheel_button = (value >= 0) ?
+                                   wheel_up_button : wheel_down_button;
+            start_time = (last_wheel_button == current_wheel_button) ?
+                         pEvdev->wheelAccelRec.lastWheelClickTimeVertical :
+                         end_time;
+            EvdevAccelWheel(pInfo, current_wheel_button, value, start_time,
+                            end_time);
+            pEvdev->wheelAccelRec.lastWheelButtonVertical =
+                current_wheel_button;
+            pEvdev->wheelAccelRec.lastWheelClickTimeVertical = end_time;
+            break;
+        case REL_HWHEEL:
+            last_wheel_button = pEvdev->wheelAccelRec.lastWheelButtonHorizontal;
+            current_wheel_button = (value >= 0) ?
+                                   wheel_right_button : wheel_left_button;
+            start_time = (last_wheel_button == current_wheel_button) ?
+                         pEvdev->wheelAccelRec.lastWheelClickTimeHorizontal :
+                         end_time;
+            EvdevAccelWheel(pInfo, current_wheel_button, value, start_time,
+                            end_time);
+            pEvdev->wheelAccelRec.lastWheelButtonHorizontal =
+                current_wheel_button;
+            pEvdev->wheelAccelRec.lastWheelClickTimeHorizontal = end_time;
             break;
 
         case REL_DIAL:
-        case REL_HWHEEL:
             if (value > 0)
                 EvdevQueueButtonClicks(pInfo, wheel_right_button, value);
             else if (value < 0)
                 EvdevQueueButtonClicks(pInfo, wheel_left_button, -value);
             break;
-        /* We don't post wheel events as axis motion. */
+        /* We don't post DIAL events as axis motion. */
+
 #endif
         default:
             /* Ignore EV_REL events if we never set up for them. */
@@ -1533,12 +1643,6 @@ EvdevAddRelValuatorClass(DeviceIntPtr device)
         goto out;
 
 #ifndef HAVE_SMOOTH_SCROLLING
-    /* Wheels are special, we post them as button events. So let's ignore them
-     * in the axes list too */
-    if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_WHEEL))
-        num_axes--;
-    if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_HWHEEL))
-        num_axes--;
     if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_DIAL))
         num_axes--;
 
@@ -1546,17 +1650,20 @@ EvdevAddRelValuatorClass(DeviceIntPtr device)
         goto out;
 #endif
 
-    if (num_axes > MAX_VALUATORS) {
-        xf86IDrvMsg(pInfo, X_WARNING, "found %d axes, limiting to %d.\n", num_axes, MAX_VALUATORS);
-        num_axes = MAX_VALUATORS;
+    /* -2 to leave room for start and end timestamps */
+    if (num_axes > MAX_VALUATORS - 2) {
+        xf86IDrvMsg(pInfo, X_WARNING, "found %d axes, limiting to %d.\n", num_axes, MAX_VALUATORS - 2);
+        num_axes = MAX_VALUATORS - 2;
     }
 
-    pEvdev->num_vals = num_axes;
-    if (num_axes > 0) {
-        pEvdev->vals = valuator_mask_new(num_axes);
-        if (!pEvdev->vals)
-            goto out;
-    }
+    pEvdev->start_time_valuator_index = num_axes;
+    pEvdev->end_time_valuator_index = num_axes + 1;
+
+    /* +2 for timestamp valuators */
+    pEvdev->num_vals = num_axes + 2;
+    pEvdev->vals = valuator_mask_new(pEvdev->num_vals);
+    if (!pEvdev->vals)
+        goto out;
     atoms = malloc(pEvdev->num_vals * sizeof(Atom));
 
     for (axis = REL_X; i < MAX_VALUATORS && axis <= REL_MAX; axis++)
@@ -1564,7 +1671,7 @@ EvdevAddRelValuatorClass(DeviceIntPtr device)
         pEvdev->axis_map[axis] = -1;
 #ifndef HAVE_SMOOTH_SCROLLING
         /* We don't post wheel events, so ignore them here too */
-        if (axis == REL_WHEEL || axis == REL_HWHEEL || axis == REL_DIAL)
+        if (axis == REL_DIAL)
             continue;
 #endif
         if (!EvdevBitIsSet(pEvdev->rel_bitmask, axis))
@@ -1573,9 +1680,20 @@ EvdevAddRelValuatorClass(DeviceIntPtr device)
         i++;
     }
 
-    EvdevInitAxesLabels(pEvdev, Relative, pEvdev->num_vals, atoms);
+    /* Initialize all axis label atoms except Start & End Timestamps */
+    EvdevInitAxesLabels(pEvdev, Relative, num_axes, atoms);
+
+    /* Create atoms for Start & End Timestamps */
+    atoms[pEvdev->start_time_valuator_index] =
+        MakeAtom(AXIS_LABEL_PROP_ABS_DBL_START_TIME,
+                 strlen(AXIS_LABEL_PROP_ABS_DBL_START_TIME),
+                 TRUE);
+    atoms[pEvdev->end_time_valuator_index] =
+        MakeAtom(AXIS_LABEL_PROP_ABS_DBL_END_TIME,
+                 strlen(AXIS_LABEL_PROP_ABS_DBL_END_TIME),
+                 TRUE);
 
-    if (!InitValuatorClassDeviceStruct(device, num_axes, atoms,
+    if (!InitValuatorClassDeviceStruct(device, pEvdev->num_vals, atoms,
                                        GetMotionHistorySize(), Relative)) {
         xf86IDrvMsg(pInfo, X_ERROR, "failed to initialize valuator class device.\n");
         goto out;
@@ -1590,11 +1708,18 @@ EvdevAddRelValuatorClass(DeviceIntPtr device)
     for (axis = REL_X; axis <= REL_MAX; axis++)
     {
         int axnum = pEvdev->axis_map[axis];
+        int mode = Relative;
 
         if (axnum == -1)
             continue;
+
+#ifndef HAVE_SMOOTH_SCROLLING
+        if (axis == REL_WHEEL || axis == REL_HWHEEL)
+            mode = Absolute;
+#endif
+
         xf86InitValuatorAxisStruct(device, axnum, atoms[axnum], -1, -1, 1, 0, 1,
-                                   Relative);
+                                   mode);
         xf86InitValuatorDefaults(device, axnum);
 #ifdef HAVE_SMOOTH_SCROLLING
         if (axis == REL_WHEEL)
@@ -1606,6 +1731,17 @@ EvdevAddRelValuatorClass(DeviceIntPtr device)
 #endif
     }
 
+#ifndef HAVE_SMOOTH_SCROLLING
+    /* Initialize valuators for scroll wheel Start & End Timestamps */
+    xf86InitValuatorAxisStruct(device, pEvdev->start_time_valuator_index,
+                               atoms[pEvdev->start_time_valuator_index],
+                               0, INT_MAX, 1, 0, 1, Absolute);
+
+    xf86InitValuatorAxisStruct(device, pEvdev->end_time_valuator_index,
+                               atoms[pEvdev->end_time_valuator_index],
+                               0, INT_MAX, 1, 0, 1, Absolute);
+#endif
+
     free(atoms);
 
     return Success;
@@ -1767,6 +1903,9 @@ EvdevInit(DeviceIntPtr device)
     for(i = 0; i < max(ABS_CNT,REL_CNT); i++)
       pEvdev->axis_map[i]=-1;
 
+    pEvdev->start_time_valuator_index = -1;
+    pEvdev->end_time_valuator_index = -1;
+
     if (pEvdev->flags & EVDEV_KEYBOARD_EVENTS)
 	EvdevAddKeyClass(device);
     if (pEvdev->flags & EVDEV_BUTTON_EVENTS)
@@ -2845,6 +2984,7 @@ EvdevInitProperty(DeviceIntPtr dev)
     if (pEvdev->flags & (EVDEV_RELATIVE_EVENTS | EVDEV_ABSOLUTE_EVENTS))
     {
         BOOL invert[2];
+        int axis_accel_conf_val;
         invert[0] = pEvdev->invert_x;
         invert[1] = pEvdev->invert_y;
 
@@ -2891,6 +3031,16 @@ EvdevInitProperty(DeviceIntPtr dev)
 
         XISetDevicePropertyDeletable(dev, prop_swap, FALSE);
 
+        prop_wheel_accel_axes = MakeAtom(EVDEV_PROP_WHEEL_ACCEL_AXES,
+                strlen(EVDEV_PROP_WHEEL_ACCEL_AXES), TRUE);
+        axis_accel_conf_val = xf86SetBoolOption(pInfo->options, EVDEV_PROP_WHEEL_ACCEL_AXES, 0);
+        pEvdev->wheelAccelRec.scroll_axes = axis_accel_conf_val != 0;
+        rc = XIChangeDeviceProperty(dev, prop_wheel_accel_axes, XA_INTEGER, 8,
+                PropModeReplace, 1, &pEvdev->wheelAccelRec.scroll_axes, FALSE);
+        if (rc != Success)
+            return;
+
+        XISetDevicePropertyDeletable(dev, prop_wheel_accel_axes, FALSE);
         /* Axis labelling */
         if ((pEvdev->num_vals > 0) && (prop_axis_label = XIGetKnownProperty(AXIS_LABEL_PROP)))
         {
@@ -2960,6 +3110,13 @@ EvdevSetProperty(DeviceIntPtr dev, Atom atom, XIPropertyValuePtr val,
 
         if (!checkonly)
             pEvdev->swap_axes = *((BOOL*)val->data);
+    } else if (atom == prop_wheel_accel_axes)
+    {
+        if (val->format != 8 || val->type != XA_INTEGER || val->size != 1)
+            return BadMatch;
+
+        if (!checkonly)
+            pEvdev->wheelAccelRec.scroll_axes = *((BOOL*)val->data);
     } else if (atom == prop_axis_label || atom == prop_btn_label ||
                atom == prop_product_id || atom == prop_device ||
                atom == prop_virtual)
diff --git a/src/evdev.h b/src/evdev.h
index b958a83..da32fe2 100644
--- a/src/evdev.h
+++ b/src/evdev.h
@@ -245,6 +245,9 @@ typedef struct {
     unsigned long led_bitmask[NLONGS(LED_CNT)];
     struct input_absinfo absinfo[ABS_CNT];
 
+    int start_time_valuator_index;
+    int end_time_valuator_index;
+
     /* minor/major number */
     dev_t min_maj;
 
@@ -253,6 +256,15 @@ typedef struct {
     EventQueueRec           queue[EVDEV_MAXQUEUE];
 
     enum fkeymode           fkeymode;
+
+    /* Mouse scroll wheel acceleration information. */
+    struct {
+        int lastWheelButtonVertical;
+        int lastWheelButtonHorizontal;
+        double lastWheelClickTimeVertical;
+        double lastWheelClickTimeHorizontal;
+        BOOL scroll_axes; /* 0: off */
+    } wheelAccelRec;
 } EvdevRec, *EvdevPtr;
 
 /* Event posting functions */
-- 
1.7.7.3

