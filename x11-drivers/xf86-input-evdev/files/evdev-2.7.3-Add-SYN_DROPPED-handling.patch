From 06a9a8af3af71f26392ec6658f12e3dbd0369544 Mon Sep 17 00:00:00 2001
From: Chung-yih Wang <cywang@chromium.org>
Date: Tue, 30 Oct 2012 11:11:44 +0800
Subject: [PATCH] x11-drivers/xf86-input-evdev: Add SYN_DROPPED handling

If an evdev client can not consume evdev events in its queue fast enough, the
evdev kernel driver will fill an SYN_DROPPED event and clear the queue
once the client's queue is full. Then the queue will be out of sync with
evdev's state.  The patch tries to handle the SYN_DROPPED event by retrieving
evdev's state with specific ioctl commands in order to make the state of evdev
consistent between kernel and user-space evdev driver.

BUG=chromium-os:35291
TEST=on device; run the platform_TouchscreenSynDrop test
  1. Modify the line in /sbin/xstart.sh to change the nice level from -20 to 19.

     exec nice -n 19 /usr/bin/X -noreset -nolisten tcp vt01 -auth $1 2> /dev/null

  2. Execute the test script to genereate the SYN_DROPPED event and see if it passes the test.
     cd /usr/local/autotest
     bin/autotest tests/platform_TouchscreenSynDrop/control

  3. Test if touchscreen still functions correctly.

Conflicts:

	src/evdev.c
	src/evdev.h
---
 src/evdev.c |  170 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 src/evdev.h |   22 ++++++++
 2 files changed, 187 insertions(+), 5 deletions(-)

diff --git a/src/evdev.c b/src/evdev.c
index 6e3ea24..c6ff853 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -104,6 +104,11 @@
 
 #define AXIS_LABEL_PROP_TOUCH_TIME   "Touch Timestamp"
 
+/* SYN_DROPPED added in kernel v2.6.38-rc4 */
+#ifndef SYN_DROPPED
+#define SYN_DROPPED  3
+#endif
+
 static const char *evdevDefaults[] = {
     "XkbRules",     "evdev",
     "XkbModel",     "evdev",
@@ -137,6 +142,14 @@ static void EvdevInitButtonLabels(EvdevPtr pEvdev, int natoms, Atom *atoms);
 static void EvdevInitProperty(DeviceIntPtr dev);
 static int EvdevSetProperty(DeviceIntPtr dev, Atom atom,
                             XIPropertyValuePtr val, BOOL checkonly);
+static void EvdevSyncState(InputInfoPtr pInfo);
+static void EvdevGetTime(struct timeval *current_time, BOOL use_monotonic);
+static int EvdevProbeKeyState(InputInfoPtr pInfo);
+static int EvdevProbeMTSlot(InputInfoPtr pInfo, MTSlotInfoPtr req);
+static void EvdevMTSlotSync(EvdevPtr pEvdev, MTSlotInfoPtr slot_info);
+static void EvdevMTSlotSet(InputInfoPtr pInfo, int value);
+static int EvdevProbeAbsinfo(InputInfoPtr pInfo, size_t key);
+
 static Atom prop_product_id;
 static Atom prop_invert;
 static Atom prop_calibration;
@@ -1155,11 +1168,15 @@ EvdevProcessSyncEvent(InputInfoPtr pInfo, struct input_event *ev)
 
 /**
  * Process the events from the device; nothing is actually posted to the server
- * until an EV_SYN event is received.
+ * until an EV_SYN event is received. As the SYN_DROPPED event indicates that the
+ * state of evdev driver will be out of sync with the event queue, additional
+ * handling is required for processing the SYN_DROPPED event. The function returns
+ * TRUE if an SYN_DROPPED event is received, false otherwise.
  */
-static void
+static BOOL
 EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
 {
+    BOOL syn_dropped = FALSE;
     switch (ev->type) {
         case EV_REL:
             EvdevProcessRelativeMotionEvent(pInfo, ev);
@@ -1171,7 +1188,12 @@ EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
             EvdevProcessKeyEvent(pInfo, ev);
             break;
         case EV_SYN:
-            EvdevProcessSyncEvent(pInfo, ev);
+            if (ev->code == SYN_DROPPED) {
+                xf86IDrvMsg(pInfo, X_INFO, "+++ SYN_DROPPED +++\n");
+                syn_dropped = TRUE;
+            } else {
+                EvdevProcessSyncEvent(pInfo, ev);
+            }
             break;
     }
 
@@ -1184,6 +1206,7 @@ EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
       pEvdev->debug_buf_tail++;
       pEvdev->debug_buf_tail %= DEBUG_BUF_SIZE;
     }
+    return syn_dropped;
 }
 
 #undef ABS_X_VALUE
@@ -1214,6 +1237,127 @@ EvdevFreeMasks(EvdevPtr pEvdev)
 #endif
 }
 
+static void
+EvdevGetTime(struct timeval *current_time, BOOL use_monotonic) {
+    struct timespec now;
+    clockid_t clockid = (use_monotonic) ? CLOCK_MONOTONIC : CLOCK_REALTIME;
+
+    clock_gettime(clockid, &now);
+    current_time->tv_sec = now.tv_sec;
+    current_time->tv_usec = now.tv_nsec / 1000;
+}
+
+
+static int
+EvdevProbeKeyState(InputInfoPtr pInfo) {
+    EvdevPtr device = pInfo->private;
+    int len = sizeof(device->key_state_bitmask);
+
+    memset(device->key_state_bitmask, 0, len);
+    if (ioctl(pInfo->fd, EVIOCGKEY(len), device->key_state_bitmask) < 0) {
+        xf86IDrvMsg(pInfo, X_ERROR,
+                    "ioctl EVIOCGKEY failed: %s\n", strerror(errno));
+        return !Success;
+    } else {
+        return Success;
+    }
+}
+
+static int
+EvdevProbeMTSlot(InputInfoPtr pInfo, MTSlotInfoPtr req) {
+    if (ioctl(pInfo->fd, EVIOCGMTSLOTS((sizeof(*req))), req) < 0) {
+        xf86IDrvMsg(pInfo, X_ERROR,
+                    "ioctl EVIOCGMTSLOTS(req.code=%d) failed: %s\n",
+                    req->code, strerror(errno));
+        return !Success;
+    } else {
+        return Success;
+    }
+}
+
+static void
+EvdevMTSlotSync(EvdevPtr pEvdev, MTSlotInfoPtr slot_info)
+{
+    int i;
+
+    for (i = 0; i < num_slots(pEvdev); i++) {
+        int map = pEvdev->axis_map[slot_info->code];
+        valuator_mask_set(pEvdev->mt_mask, map, slot_info->values[i]);
+        valuator_mask_set(pEvdev->last_mt_vals[i], map, slot_info->values[i]);
+    }
+}
+
+static void
+EvdevMTSlotSet(InputInfoPtr pInfo, int value)
+{
+    EvdevPtr pEvdev = pInfo->private;
+    int min = pEvdev->absinfo[ABS_MT_SLOT].minimum;
+    if (value < min || value >= min + num_slots(pEvdev)) {
+        pEvdev->cur_slot = -1;
+        xf86IDrvMsg(pInfo, X_WARNING, "MT Slot %d not in range [%d .. %d]\n",
+                    value, min, min + num_slots(pEvdev) - 1);
+    } else {
+        pEvdev->cur_slot = value;
+    }
+}
+
+static int
+EvdevProbeAbsinfo(InputInfoPtr pInfo, size_t key) {
+    EvdevPtr device = pInfo->private;
+    struct input_absinfo* absinfo;
+
+    absinfo = &device->absinfo[key];
+    if (ioctl(pInfo->fd, EVIOCGABS(key), absinfo) < 0) {
+        xf86IDrvMsg(pInfo, X_ERROR, "ioctl EVIOCGABS(%zu) failed: %s\n",
+                    key, strerror(errno));
+        return !Success;
+    } else {
+        return Success;
+    }
+}
+
+/**
+ * Synchronize the current state with kernel evdev driver.
+ */
+static void
+EvdevSyncState(InputInfoPtr pInfo)
+{
+    EvdevPtr device = pInfo->private;
+    int i;
+
+    EvdevGetTime(&device->before_sync_time, device->is_monotonic);
+
+    EvdevProbeKeyState(pInfo);
+
+#ifdef MULTITOUCH
+    /* Get current MT information for each slot */
+    for (i = _ABS_MT_FIRST; i <= _ABS_MT_LAST; i++) {
+        MTSlotInfo req;
+
+        if (!TestBit(i, device->abs_bitmask))
+            continue;
+
+        req.code = i;
+        if (EvdevProbeMTSlot(pInfo, &req) != Success) {
+            continue;
+        }
+        EvdevMTSlotSync(device, &req);
+    }
+
+    /* Get current slot id */
+    if (EvdevProbeAbsinfo(pInfo, ABS_MT_SLOT) == Success)
+        EvdevMTSlotSet(pInfo, device->absinfo[ABS_MT_SLOT].value);
+#endif
+
+    EvdevGetTime(&device->after_sync_time, device->is_monotonic);
+
+    xf86IDrvMsg(pInfo, X_INFO, "Sync_State: before %ld.%ld after %ld.%ld\n",
+                device->before_sync_time.tv_sec,
+                device->before_sync_time.tv_usec,
+                device->after_sync_time.tv_sec,
+                device->after_sync_time.tv_usec);
+}
+
 /* just a magic number to reduce the number of reads */
 #define NUM_EVENTS 16
 
@@ -1222,6 +1366,7 @@ EvdevReadInput(InputInfoPtr pInfo)
 {
     struct input_event ev[NUM_EVENTS];
     int i, len = sizeof(ev);
+    BOOL sync_evdev_state = FALSE;
 
     while (len == sizeof(ev))
     {
@@ -1256,9 +1401,23 @@ EvdevReadInput(InputInfoPtr pInfo)
             break;
         }
 
-        for (i = 0; i < len/sizeof(ev[0]); i++)
-            EvdevProcessEvent(pInfo, &ev[i]);
+        for (i = 0; i < len/sizeof(ev[0]); i++) {
+            if (sync_evdev_state)
+                break;
+            if (timercmp(&ev[i].time, &pEvdev->before_sync_time, <)) {
+              /* Ignore events before last sync time */
+              continue;
+            } else if (timercmp(&ev[i].time, &pEvdev->after_sync_time, >)) {
+              /* Event_Process returns TRUE if SYN_DROPPED detected */
+              sync_evdev_state = EvdevProcessEvent(pInfo, &ev[i]);
+            } else {
+              /* If the event occurred during sync, then sync again */
+              sync_evdev_state = TRUE;
+            }
+        }
     }
+    if (sync_evdev_state)
+        EvdevSyncState(pInfo);
 }
 
 static void
@@ -2037,6 +2196,7 @@ EvdevOn(DeviceIntPtr device)
     pEvdev->flags |= EVDEV_INITIALIZED;
     device->public.on = TRUE;
 
+    EvdevSyncState(pInfo);
     return Success;
 }
 
diff --git a/src/evdev.h b/src/evdev.h
index 2e98632..0adb9ba 100644
--- a/src/evdev.h
+++ b/src/evdev.h
@@ -103,6 +103,16 @@
 
 #define DEBUG_BUF_SIZE 65536
 
+#define _ABS_MT_FIRST       ABS_MT_TOUCH_MAJOR
+#define _ABS_MT_LAST        ABS_MT_DISTANCE
+#define _ABS_MT_CNT         (_ABS_MT_LAST - _ABS_MT_FIRST + 1)
+
+// Implementation of inline bit operations
+static inline int TestBit(int bit, unsigned long* array)
+{
+    return !!(array[bit / LONG_BITS] & (1L << (bit % LONG_BITS)));
+}
+
 /* Function key mode */
 enum fkeymode {
     FKEYMODE_UNKNOWN = 0,
@@ -279,8 +289,20 @@ typedef struct {
     BOOL                    scroll_axes;
     EvdevRelWheelRec        wheel;       /* scroll state for REL_WHEEL */
     EvdevRelWheelRec        hwheel;      /* scroll state for REL_HWHEEL */
+
+    /* Sync timestamps */
+    unsigned long key_state_bitmask[NLONGS(KEY_CNT)];
+    struct timeval before_sync_time;
+    struct timeval after_sync_time;
 } EvdevRec, *EvdevPtr;
 
+#define MAX_SLOT_COUNT  64
+
+typedef struct {
+    unsigned code;
+    int values[MAX_SLOT_COUNT];
+} MTSlotInfo, *MTSlotInfoPtr;
+
 /* Event posting functions */
 void EvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value);
 void EvdevQueueButtonEvent(InputInfoPtr pInfo, int button, int value);
-- 
1.7.7.3

