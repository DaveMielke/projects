From: Chung-yih Wang <cywang@chromium.org>
Subject: [PATCH] Accelerate emulated wheel events

Use the Chromium OS Mouse Wheel acceleration for Emulated Wheel
events.  This acceleration replaces the simpler "accumulated inertia
mapped to number of button clicks" approach.

The main motivation of this change is to send Emulated Wheel events to
Chrome using the scroll valuators instead of legacy button events.
---
 src/emuWheel.c |   48 +++++++++---------------------------------------
 src/evdev.c    |    9 +++++++--
 src/evdev.h    |    4 ++++
 3 files changed, 20 insertions(+), 41 deletions(-)

diff --git a/src/emuWheel.c b/src/emuWheel.c
index ae894fa..3cfa734 100644
--- a/src/emuWheel.c
+++ b/src/emuWheel.c
@@ -50,9 +50,6 @@ static Atom prop_wheel_inertia  = 0;
 static Atom prop_wheel_timeout  = 0;
 static Atom prop_wheel_button   = 0;
 
-/* Local Funciton Prototypes */
-static int EvdevWheelEmuInertia(InputInfoPtr pInfo, WheelAxisPtr axis, int value);
-
 /* Filter mouse button events */
 BOOL
 EvdevWheelEmuFilterButton(InputInfoPtr pInfo, unsigned int button, int value)
@@ -148,8 +145,15 @@ EvdevWheelEmuFilterMotion(InputInfoPtr pInfo, struct input_event *pEv)
 	 */
 	if (pAxis)
 	{
-	    if (EvdevWheelEmuInertia(pInfo, pAxis, value))
-		pOtherAxis->traveled_distance = 0;
+	    if (pAxis->up_button) {
+		/*
+		 * Try to emit an emulated wheel event. For REL_Y, up is -
+		 * and down is + but, for REL_WHEEL, up is + and down is -.
+		 */
+		pEv->code = (pEv->code == REL_Y) ? REL_WHEEL : REL_HWHEEL;
+		pEv->value *= (pEv->code == REL_WHEEL) ? -1 : 1;
+		EvdevProcessRelativeMotionEvent(pInfo, pEv);
+	    }
 	}
 
 	/* Eat motion events while emulateWheel button pressed. */
@@ -159,40 +163,6 @@ EvdevWheelEmuFilterMotion(InputInfoPtr pInfo, struct input_event *pEv)
     return FALSE;
 }
 
-/* Simulate inertia for our emulated mouse wheel.
-   Returns the number of wheel events generated.
- */
-static int
-EvdevWheelEmuInertia(InputInfoPtr pInfo, WheelAxisPtr axis, int value)
-{
-    EvdevPtr pEvdev = (EvdevPtr)pInfo->private;
-    int button;
-    int inertia;
-    int rc = 0;
-
-    /* if this axis has not been configured, just eat the motion */
-    if (!axis->up_button)
-	return rc;
-
-    axis->traveled_distance += value;
-
-    if (axis->traveled_distance < 0) {
-	button = axis->up_button;
-	inertia = -pEvdev->emulateWheel.inertia;
-    } else {
-	button = axis->down_button;
-	inertia = pEvdev->emulateWheel.inertia;
-    }
-
-    /* Produce button press events for wheel motion */
-    while(abs(axis->traveled_distance) > pEvdev->emulateWheel.inertia) {
-	axis->traveled_distance -= inertia;
-	EvdevQueueButtonClicks(pInfo, button, 1);
-	rc++;
-    }
-    return rc;
-}
-
 /* Handle button mapping here to avoid code duplication,
 returns true if a button mapping was found. */
 static BOOL
diff --git a/src/evdev.c b/src/evdev.c
index f7a5ff7..c7b2adc 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -755,7 +755,12 @@ EvdevAccelWheel(InputInfoPtr pInfo, int wheel_button, int value,
         EvdevQueueButtonClicks(pInfo, wheel_button, abs(value));
         return;
     }
-    click_speed = dt == 0 ? 1 : 1/dt;
+    if (dt == 0)
+	dt = 1.0;
+    if (pEvdev->emulateWheel.enabled)
+	click_speed = abs(value) / (pEvdev->emulateWheel.inertia * dt);
+    else
+	click_speed = 1 / dt;
     pixels = EvdevGetPixelsToScroll(click_speed);
     pixels = value > 0 ? pixels : pixels * -1;
     if (pEvdev->wheelAccelRec.scroll_axes)
@@ -774,7 +779,7 @@ EvdevAccelWheel(InputInfoPtr pInfo, int wheel_button, int value,
 /**
  * Take the relative motion input event and process it accordingly.
  */
-static void
+void
 EvdevProcessRelativeMotionEvent(InputInfoPtr pInfo, struct input_event *ev)
 {
     int value;
diff --git a/src/evdev.h b/src/evdev.h
index 2ede36d..f5cf088 100644
--- a/src/evdev.h
+++ b/src/evdev.h
@@ -294,6 +294,10 @@ void EvdevPostAbsoluteMotionEvents(InputInfoPtr pInfo, int num_v, int first_v,
 				   int v[MAX_VALUATORS]);
 unsigned int EvdevUtilButtonEventToButtonNumber(EvdevPtr pEvdev, int code);
 
+/* Event processing functions */
+void EvdevProcessRelativeMotionEvent(InputInfoPtr pInfo,
+				     struct input_event *ev);
+
 /* Middle Button emulation */
 int  EvdevMBEmuTimer(InputInfoPtr);
 BOOL EvdevMBEmuFilterEvent(InputInfoPtr, int, BOOL);
-- 
1.7.7.3

