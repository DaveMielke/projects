diff --git a/crypto/x509/x509_vfy.c b/crypto/x509/x509_vfy.c
index aeb6337..a6781b5 100644
--- a/crypto/x509/x509_vfy.c
+++ b/crypto/x509/x509_vfy.c
@@ -94,6 +94,81 @@ static int x509_subject_cmp(X509 **a, X509 **b)
 	}
 #endif
 
+/* A version of fgets() that returns the first sz - 1 characters of the next
+ * line from 'in'. The rest of the line is discarded. */
+static int gets_trunc(BIO *in, char *buf, int sz)
+{
+	char b;
+	int i = 0;
+
+	while (BIO_read(in, &b, 1)) {
+		if (i < sz - 1)
+			buf[i++] = b;
+		if (!b || b == '\n')
+			break;
+	}
+
+	buf[i] = '\0';
+
+	return i;
+}
+
+/* Converts a byte string into a hex string, null-terminated. The 'out' buffer
+ * must be at least 2 * insize + 1 bytes long. */
+static void hexify(unsigned char *in, char *out, int insize)
+{
+	int i;
+	static const char hex[] = "0123456789abcdef";
+	for (i = 0; i < insize; i++) {
+		out[i * 2] = hex[in[i] >> 4];
+		out[i * 2 + 1] = hex[in[i] & 0xf];
+	}
+	out[i * 2] = '\0';
+}
+
+static int is_blacklisted(X509 *x)
+{
+	unsigned char md[EVP_MAX_MD_SIZE];
+	char hexmd[EVP_MAX_MD_SIZE * 2 + 1];
+	const EVP_MD *hash = EVP_sha256();
+	unsigned int n;
+	char line[SHA256_DIGEST_LENGTH * 2 + 1];
+	BIO *file = BIO_new_file(OPENSSLDIR "/blacklist", "r");
+	int ret = 0;
+
+	if (!file)
+		return 0;
+
+	if (!X509_digest(x, hash, md, &n))
+		goto out;
+	hexify(md, hexmd, SHA256_DIGEST_LENGTH);
+
+	while (gets_trunc(file, line, sizeof(line))) {
+		if (!strcmp(line, hexmd)) {
+			ret = 1;
+			goto out;
+		}
+	}
+
+out:
+	BIO_free(file);
+	return ret;
+}
+
+static int check_blacklist(X509_STORE_CTX *ctx)
+{
+	int i;
+	X509 *x;
+
+	for (i = 0; i < ctx->last_untrusted; i++)
+		{
+		x = sk_X509_value(ctx->chain, i);
+		if (is_blacklisted(x))
+			return 0;
+		}
+	return 1;
+}
+
 int X509_verify_cert(X509_STORE_CTX *ctx)
 	{
 	X509 *x,*xtmp,*chain_ss=NULL;
@@ -251,6 +326,13 @@ int X509_verify_cert(X509_STORE_CTX *ctx)
 
 	/* we now have our chain, lets check it... */
 
+	ok = check_blacklist(ctx);
+
+	if (!ok) {
+		ctx->error = X509_V_ERR_CERT_REJECTED;
+		goto end;
+	}
+
 	/* Is last certificate looked up self signed? */
 	if (!ctx->check_issued(ctx,x,x))
 		{
@@ -378,7 +460,6 @@ static int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
 	else
 		return 0;
 }
-	
 
 /* Check a certificate chains extensions for consistency
  * with the supplied purpose
@@ -1435,6 +1516,11 @@ int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
 	else
 		ctx->cert_crl = cert_crl;
 
+	if (store && store->check_blacklist)
+		ctx->check_blacklist = store->check_blacklist;
+	else
+		ctx->check_blacklist = check_blacklist;
+
 	ctx->check_policy = check_policy;
 
 
diff --git a/crypto/x509/x509_vfy.h b/crypto/x509/x509_vfy.h
index 86ae35f..6c822c9 100644
--- a/crypto/x509/x509_vfy.h
+++ b/crypto/x509/x509_vfy.h
@@ -198,6 +198,7 @@ struct x509_store_st
 	int (*get_crl)(X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x); /* retrieve CRL */
 	int (*check_crl)(X509_STORE_CTX *ctx, X509_CRL *crl); /* Check CRL validity */
 	int (*cert_crl)(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x); /* Check certificate against CRL */
+	int (*check_blacklist)(X509_STORE_CTX *ctx, X509 *x); /* Check certificate against blacklist */
 	int (*cleanup)(X509_STORE_CTX *ctx);
 
 	CRYPTO_EX_DATA ex_data;
@@ -245,6 +246,7 @@ struct x509_store_ctx_st      /* X509_STORE_CTX */
 	int (*get_crl)(X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x); /* retrieve CRL */
 	int (*check_crl)(X509_STORE_CTX *ctx, X509_CRL *crl); /* Check CRL validity */
 	int (*cert_crl)(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x); /* Check certificate against CRL */
+	int (*check_blacklist)(X509_STORE_CTX *ctx, X509 *x); /* Check certificate against blacklist */
 	int (*check_policy)(X509_STORE_CTX *ctx);
 	int (*cleanup)(X509_STORE_CTX *ctx);
 
