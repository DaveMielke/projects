GLXdrawables are both GLX and X drawables, so they get freed twice.
Now the issue is that the first time we don't want to actually free the
struct, because on the second call we'll be accessing freed memory if we do.
Fixes the crash on exit with Xserver 1.9.3.
diff -upr xorg-server-1.9.3.orig/glx/glxext.c xorg-server-1.9.3.work/glx/glxext.c
--- xorg-server-1.9.3.orig/glx/glxext.c	2010-12-22 18:58:56.066431000 -0800
+++ xorg-server-1.9.3.work/glx/glxext.c	2011-02-18 18:26:37.215757000 -0800
@@ -125,14 +125,17 @@ static int glxBlockClients;
 static Bool DrawableGone(__GLXdrawable *glxPriv, XID xid)
 {
     __GLXcontext *c, *next;
+    int have_to_free = 1;
 
     /* If this drawable was created using glx 1.3 drawable
      * constructors, we added it as a glx drawable resource under both
      * its glx drawable ID and it X drawable ID.  Remove the other
      * resource now so we don't a callback for freed memory. */
     if (glxPriv->drawId != glxPriv->pDraw->id) {
-	if (xid == glxPriv->drawId)
+	if (xid == glxPriv->drawId) {
+	    have_to_free = 0;
 	    FreeResourceByType(glxPriv->pDraw->id, __glXDrawableRes, TRUE);
+	}
 	else
 	    FreeResourceByType(glxPriv->drawId, __glXDrawableRes, TRUE);
     }
@@ -170,7 +173,8 @@ static Bool DrawableGone(__GLXdrawable *
 	    __glXFreeContext(c);
     }
 
-    glxPriv->destroy(glxPriv);
+    if (have_to_free)
+	    glxPriv->destroy(glxPriv);
 
     return True;
 }
