From: Daniel Kurtz <djkurtz@chromium.org>
Date: Mon, 12 Nov 2012 14:39:33 +0800
Subject: [PATCH] Experimental per Randr CRTC pointer scaling

Scale pointer motion based on the dimensions of the current "RandR" crtc
for the current pointer position.

The pointer motion is scaled relative to a nominal screen size of 1280x800.
In other words, for screen of 1280x800, there is no scaling (1.0 x 1.0).

This patch implements 6 possible scaling algorithms, and provides an X
command line arg '-pointerscaling <n>' for selecting one:
  0 No scaling
  1 Scale independently
   - changes motion aspect ratio
  2 Scale both by width-ratio
  3 Scale both by height-ratio
  4 Scale by geometric mean of width- & height-ratios
  5 Scale by width- & height ratio closest to 1.0
    - No scaling if either height or width is nominal

The default algorithm is set to 5 (PointerScaling_ClosestToNominal).
To select an alternate algorithm, first add '-pointerscaling N' to the X invocation
line in /sbin/xstart.sh, then restart ui.

This implementation is very hacky since it directly accesses XRandR methods
and datastructures from within the X server proper.  I'm not sure what
the proper way to solve this is.

BUG=chromium-os:30822
TEST=The Pointer should move a similar "percentage of screen" in both X & Y
     For screens of different resolution and/or physical size.
---
 dix/getevents.c |  125 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 dix/globals.c   |    3 +
 include/misc.h  |   24 +++++++++++
 os/utils.c      |    9 ++++
 4 files changed, 161 insertions(+), 0 deletions(-)

diff --git a/dix/getevents.c b/dix/getevents.c
index 7454cb4..b9ecb07 100644
--- a/dix/getevents.c
+++ b/dix/getevents.c
@@ -51,6 +51,7 @@
 #include "inpututils.h"
 #include "mi.h"
 #include "windowstr.h"
+#include "randrstr.h"
 
 #include <X11/extensions/XKBproto.h>
 #include "xkbsrv.h"
@@ -1262,6 +1263,128 @@ QueuePointerEvents(DeviceIntPtr device, int type,
     queueEventList(device, InputEventList, nevents);
 }
 
+/*
+ * Return TRUE if (x, y) is within the bounds of the given X RandR CRTC.
+ * If so, it also returns the CRTC's width and height.
+ */
+static Bool
+RRCrtcContainsPosition(RRCrtcPtr crtc, int x, int y, int *width, int *height)
+{
+    if (!crtc->mode)
+        return FALSE;
+
+    RRCrtcGetScanoutSize(crtc, width, height);
+
+    if (crtc->x <= x && x < crtc->x + *width &&
+        crtc->y <= y && y < crtc->y + *height)
+        return TRUE;
+    return FALSE;
+}
+
+/*
+ * Find the X RandR CRTC (ie display) which contains desktop coordinate (x,y),
+ * and return its width and height.
+ *
+ * Returns FALSE if (x, y) is not on any known X RandR CRTC.
+ */
+static Bool
+RRGetContainingCrtcSize(ScreenPtr pScreen, int x, int y, int *width,
+                        int *height)
+{
+    rrScrPrivPtr rrScrPriv = rrGetScrPriv(pScreen);
+    RRCrtcPtr crtc = rrScrPriv->pointerCrtc;
+    int i;
+
+    /* Check last known CRTC */
+    if (crtc && RRCrtcContainsPosition(crtc, x, y, width, height))
+        return TRUE;
+
+    /* Check all CRTCs */
+    for (i = 0; i < rrScrPriv->numCrtcs; i++) {
+        crtc = rrScrPriv->crtcs[i];
+        if (RRCrtcContainsPosition(crtc, x, y, width, height))
+            return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Scale the motion vector in mask valuators 0 & 1
+ *
+ * Find the RandR CRTC for the current pointer position for this device, and
+ * use its height and weight to scale the motion vector in the valuator mask
+ * relative to a nominal 1280x800 display.
+ *
+ * In other words, modify the motion such that it moves the pointer by the same
+ * percentage of the screen as the on a 1280x800 display, regardles of the
+ * actual displays pitch or size.
+ */
+static void
+scaleMotionPerRRCrtc(DeviceIntPtr dev, ValuatorMask *mask)
+{
+    ScreenPtr pScreen = miPointerGetScreen(dev);
+    double x, y, dx, dy, scale_x, scale_y;
+    const double nominal_width = 1280.0;
+    const double nominal_height = 800.0;
+    int crtc_width, crtc_height;
+
+    x = dev->last.valuators[0];
+    y = dev->last.valuators[1];
+
+    /* Find Size of RandR CRTC containing the current pointer (x, y) */
+    if (!RRGetContainingCrtcSize(pScreen, x, y, &crtc_width, &crtc_height))
+        return;
+
+    switch (PointerScalingAlgorithm) {
+    case PointerScaling_None:
+	    scale_x = 1.0;
+	    scale_y = 1.0;
+	    break;
+    case PointerScaling_WidthAndHeight:
+	    scale_x = (double)crtc_width / nominal_width;
+	    scale_y = (double)crtc_height / nominal_height;
+	    break;
+    case PointerScaling_Width:
+	    scale_x = (double)crtc_width / nominal_width;
+	    scale_y = scale_x;
+	    break;
+    case PointerScaling_Height:
+	    scale_y = (double)crtc_width / nominal_height;
+	    scale_x = scale_y;
+	    break;
+    case PointerScaling_GeometricMean:
+	    scale_x = (double)crtc_width / nominal_width;
+	    scale_y = (double)crtc_height / nominal_height;
+	    scale_x = scale_y = sqrt(scale_x * scale_y);
+	    break;
+    case PointerScaling_ClosestToNominal:
+	    scale_x = (double)crtc_width / nominal_width;
+	    scale_y = (double)crtc_height / nominal_height;
+	    if (scale_x >= 1.0 && scale_y >= 1.0)
+		    scale_x = scale_y = min(scale_x, scale_y);
+	    else if (scale_x < 1.0 && scale_y < 1.0)
+		    scale_x = scale_y = max(scale_x, scale_y);
+	    else if (scale_x >= 1.0 && scale_y < 1.0)
+		    scale_x = scale_y = (scale_x <= 1.0 / scale_y) ? scale_x : scale_y;
+	    else if (scale_x < 1.0 && scale_y >= 1.0)
+		    scale_x = scale_y = (scale_x > 1.0 / scale_y) ? scale_x : scale_y;
+	    else
+		    scale_x = scale_y = 1.0;
+	    break;
+    default:
+	    scale_x = 1.0;
+	    scale_y = 1.0;
+	    break;
+    }
+
+    if (valuator_mask_fetch_double(mask, 0, &dx))
+        valuator_mask_set_double(mask, 0, dx * scale_x);
+
+    if (valuator_mask_fetch_double(mask, 1, &dy))
+        valuator_mask_set_double(mask, 1, dy * scale_y);
+}
+
+
 /**
  * Helper function for GetPointerEvents, which only generates motion and
  * raw motion events for the slave device: does not update the master device.
@@ -1368,6 +1491,8 @@ fill_pointer_events(InternalEvent *events, DeviceIntPtr pDev, int type,
         if ((flags & POINTER_NORAW) == 0)
             set_raw_valuators(raw, &mask, raw->valuators.data);
 
+        scaleMotionPerRRCrtc(pDev, &mask);
+
         moveRelative(pDev, &mask);
     }
 
diff --git a/dix/globals.c b/dix/globals.c
index c0cae15..69d7386 100644
--- a/dix/globals.c
+++ b/dix/globals.c
@@ -131,3 +131,6 @@ char *display;
 char *ConnectionInfo;
 
 CARD32 TimeOutValue = DEFAULT_TIMEOUT * MILLI_PER_SECOND;
+
+enum PointerScalingAlgorithms PointerScalingAlgorithm =
+		PointerScaling_ClosestToNominal;
diff --git a/include/misc.h b/include/misc.h
index 41c1333..6203a57 100644
--- a/include/misc.h
+++ b/include/misc.h
@@ -381,4 +381,28 @@ extern _X_EXPORT unsigned long serverGeneration;
 
 #define BUG_WARN(cond)  __BUG_WARN_MSG(cond, 0, NULL)
 
+/*
+ * Some Pointer Scaling Algorithms to try:
+ *  0 No scaling
+ *  1 Scale independently
+ *    - changes motion aspect ratio
+ *  2 Scale both by width-ratio
+ *  3 Scale both by height-ratio
+ *  4 Scale by geometric mean of width- & height-ratios
+ *  5 Scale by width- & height ratio closest to 1.0
+ *    - No scaling if either height or width is nominal
+ *
+ *  To try an algorithm, restart X server with -pointerscaling commandline arg:
+ *    /usr/bin/X -pointerscaling <algorithm>
+ */
+enum PointerScalingAlgorithms {
+    PointerScaling_None = 0,
+    PointerScaling_WidthAndHeight = 1,
+    PointerScaling_Width = 2,
+    PointerScaling_Height = 3,
+    PointerScaling_GeometricMean = 4,
+    PointerScaling_ClosestToNominal = 5,
+};
+extern enum PointerScalingAlgorithms PointerScalingAlgorithm;
+
 #endif                          /* MISC_H */
diff --git a/os/utils.c b/os/utils.c
index b715924..38ede9f 100644
--- a/os/utils.c
+++ b/os/utils.c
@@ -512,6 +512,7 @@ UseMsg(void)
     ErrorF("-reset                 reset after last client exists\n");
     ErrorF("-p #                   screen-saver pattern duration (minutes)\n");
     ErrorF("-pn                    accept failure to listen on all ports\n");
+    ErrorF("-pointerscaling #      per-CRTC pointer scaling algorithm\n");
     ErrorF("-nopn                  reject failure to listen on all ports\n");
     ErrorF("-r                     turns off auto-repeat\n");
     ErrorF("r                      turns on auto-repeat \n");
@@ -780,6 +781,14 @@ ProcessCommandLine(int argc, char *argv[])
         else if (strcmp(argv[i], "-pogo") == 0) {
             dispatchException = DE_TERMINATE;
         }
+        else if (strcmp(argv[i], "-pointerscaling") == 0) {
+            if (++i < argc) {
+                PointerScalingAlgorithm = atoi(argv[i]);
+                ErrorF("Using Pointer Scaling Algorithm %d\n",
+                       PointerScalingAlgorithm);
+            } else
+                UseMsg();
+        }
         else if (strcmp(argv[i], "-pn") == 0)
             PartialNetwork = TRUE;
         else if (strcmp(argv[i], "-nopn") == 0)
-- 
1.7.7.3

