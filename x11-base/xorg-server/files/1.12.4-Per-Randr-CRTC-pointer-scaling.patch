From 5dfb771f6e690b0a2f558f1b2c9d0787bc885587 Mon Sep 17 00:00:00 2001
From: Daniel Kurtz <djkurtz@chromium.org>
Date: Mon, 12 Nov 2012 14:39:33 +0800
Subject: [PATCH] Per Randr CRTC pointer scaling

Scale pointer motion based on the pixel density of the current "RandR" crtc
and whether or not it's internal.

This implementation is very hacky since it directly accesses XRandR methods
and datastructures from within the X server proper.  I'm not sure what
the proper way to solve this is.

BUG=chromium-os:30822
TEST=Tested on Link, Lucas w/ external display that pointer scaled
properly in each.
---
 dix/getevents.c |  114 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 114 insertions(+), 0 deletions(-)

diff --git a/dix/getevents.c b/dix/getevents.c
index 7454cb4..5f00584 100644
--- a/dix/getevents.c
+++ b/dix/getevents.c
@@ -51,6 +51,7 @@
 #include "inpututils.h"
 #include "mi.h"
 #include "windowstr.h"
+#include "randrstr.h"
 
 #include <X11/extensions/XKBproto.h>
 #include "xkbsrv.h"
@@ -72,6 +73,8 @@
 /* Number of motion history events to store. */
 #define MOTION_HISTORY_SIZE 256
 
+#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))
+
 /**
  * InputEventList is the storage for input events generated by
  * QueuePointerEvents, QueueKeyboardEvents, and QueueProximityEvents.
@@ -1262,6 +1265,115 @@ QueuePointerEvents(DeviceIntPtr device, int type,
     queueEventList(device, InputEventList, nevents);
 }
 
+/*
+ * Return TRUE if (x, y) is within the bounds of the given X RandR CRTC.
+ * If so, it also returns whether the display is high DPI and/or internal.
+ */
+static Bool
+RRCrtcContainsPosition(RRCrtcPtr crtc, int x, int y,
+                       int *isHighDPI, int *isInternal)
+{
+    int i;
+    int width, height;
+    const float maxLowDPmm = 160.0 / 25.4;  /* 160 DPI / 25.4 mm/inch */
+    const char * const integratedPrefixes[] = { "LVDS", "eDP" };
+
+    if (!crtc->mode)
+        return FALSE;
+
+    RRCrtcGetScanoutSize(crtc, &width, &height);
+
+    if (crtc->x <= x && x < crtc->x + width &&
+        crtc->y <= y && y < crtc->y + height) {
+        /* Use the first output for extra return values */
+        if (crtc->numOutputs) {
+            RROutputPtr output = crtc->outputs[0];
+            /* Only consider HighDPI if the output has a mmWidth. */
+            *isHighDPI = output->mmWidth &&
+                width > maxLowDPmm * output->mmWidth;
+            *isInternal = FALSE;
+            for (i = 0; i < ARRAY_SIZE(integratedPrefixes); i++) {
+                if (!strncmp(integratedPrefixes[i], output->name,
+                             strlen(integratedPrefixes[i]))) {
+                    *isInternal = TRUE;
+                    break;
+                }
+            }
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Find the X RandR CRTC (ie display) which contains desktop coordinate (x,y),
+ * and return whether it's high DPI and/or internal.
+ *
+ * Returns FALSE if (x, y) is not on any known X RandR CRTC.
+ */
+static Bool
+RRGetContainingCrtcInfo(ScreenPtr pScreen, int x, int y,
+                        int *isHighDPI, int *isInternal)
+{
+    rrScrPrivPtr rrScrPriv = rrGetScrPriv(pScreen);
+    RRCrtcPtr crtc = rrScrPriv->pointerCrtc;
+    int i;
+
+    /* Check last known CRTC */
+    if (crtc && RRCrtcContainsPosition(crtc, x, y, isHighDPI, isInternal)) {
+        return TRUE;
+    }
+
+    /* Check all CRTCs */
+    for (i = 0; i < rrScrPriv->numCrtcs; i++) {
+        crtc = rrScrPriv->crtcs[i];
+        if (RRCrtcContainsPosition(crtc, x, y, isHighDPI, isInternal)) {
+            rrScrPriv->pointerCrtc = crtc;
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+/*
+ * Scale the motion vector in mask valuators 0 & 1
+ *
+ * Find the RandR CRTC for the current pointer position for this device, and
+ * use its pixel density and whether or not it's integrated to scale pointer
+ * motion. Specifically: double all motion on High-DPI displays, add 20% more
+ * motion on non-integrated displays.
+ */
+static void
+scaleMotionPerRRCrtc(DeviceIntPtr dev, ValuatorMask *mask)
+{
+    ScreenPtr pScreen = miPointerGetScreen(dev);
+    double x, y, dx, dy, scale;
+    int isHighDPI = FALSE;
+    int isInternal = FALSE;
+
+    x = dev->last.valuators[0];
+    y = dev->last.valuators[1];
+
+    /* Find Size of RandR CRTC containing the current pointer (x, y) */
+    if (!RRGetContainingCrtcInfo(pScreen, x, y, &isHighDPI, &isInternal))
+        return;
+
+    scale = 1.0;
+    if (isHighDPI)
+        scale *= 2.0;
+    if (!isInternal)
+        scale *= 1.2;
+
+    if (scale != 1.0) {
+        if (valuator_mask_fetch_double(mask, 0, &dx))
+            valuator_mask_set_double(mask, 0, dx * scale);
+
+        if (valuator_mask_fetch_double(mask, 1, &dy))
+            valuator_mask_set_double(mask, 1, dy * scale);
+    }
+}
+
+
 /**
  * Helper function for GetPointerEvents, which only generates motion and
  * raw motion events for the slave device: does not update the master device.
@@ -1368,6 +1480,8 @@ fill_pointer_events(InternalEvent *events, DeviceIntPtr pDev, int type,
         if ((flags & POINTER_NORAW) == 0)
             set_raw_valuators(raw, &mask, raw->valuators.data);
 
+        scaleMotionPerRRCrtc(pDev, &mask);
+
         moveRelative(pDev, &mask);
     }
 
-- 
1.7.7.3

