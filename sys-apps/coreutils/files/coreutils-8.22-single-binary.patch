Add the --enable-single-binary option to the configure file.
When enabled, this option builds a single binary file containing
the selected tools.  Which tool gets executed depends on the value
of argv[0] which can be set implicitly through symlinks to the
single program.
--- 

diff --git a/build-aux/gen-lists-of-programs.sh b/build-aux/gen-lists-of-programs.sh
index bf63ee3..c95e598 100755
--- a/build-aux/gen-lists-of-programs.sh
+++ b/build-aux/gen-lists-of-programs.sh
@@ -17,6 +17,7 @@ set -e
 # use "--enable-install-program=A,B" when invoking configure.
 disabled_by_default_progs='
     arch
+    coreutils
     hostname
 '
 
@@ -178,6 +179,12 @@ END
       echo default__progs += $progsdir/$p
     done
     ;;
+  1,--list-progs)
+    for p in $disabled_by_default_progs $build_if_possible_progs \
+        $normal_progs; do
+      echo $p
+    done
+    ;;
   *)
     echo "$0: invalid usage" >&2; exit 2
     ;;
diff --git a/build-aux/gen-single-binary.sh b/build-aux/gen-single-binary.sh
new file mode 100755
index 0000000..f3958bb
--- /dev/null
+++ b/build-aux/gen-single-binary.sh
@@ -0,0 +1,110 @@
+#!/bin/sh
+
+# Generate the list of rules for the single-binary option based on all the other
+# binaries found in src/local.mk.
+#
+# We need to duplicate the specific rules to build each program into a new
+# static library target. We can't reuse the existing target since we need to
+# create a .a file instead of linking the program. We can't do this at
+# ./configure since the file names need to available when automake runs to let
+# it generate all the required rules in Makefile.in. The configure step will
+# select which ones will be used to build, but they need to be generated
+# beforehand.
+#
+# Instead of maintaining a duplicated list of rules, we generate the
+# single-binary required rules based on the normal configuration found on
+# src/local.mk with this script.
+
+if test "x$1" = "x"; then
+  echo "Usage: $0 path/to/src/local.mk" >&2
+  exit 1
+fi
+
+set -e
+
+LOCAL_MK=$1
+GEN_LISTS_OF_PROGRAMS="`dirname "$0"`/gen-lists-of-programs.sh"
+
+ALL_PROGRAMS=$($GEN_LISTS_OF_PROGRAMS --list-progs \
+    | grep -v -F -e coreutils -e libstdbuf.so \
+    | tr '[' '_')
+
+# Compute default SOURCES. automake will assume the source file for the
+# src_${cmd} target to be src/${cmd}.c, but we will add rules to generate
+# the lib src_libsinglebin_${cmd}_a which won't match the autogenerated source
+# file. This loop will initialize the default source file and will be reset
+# later if needed.
+for cmd in $ALL_PROGRAMS; do
+  eval "src_${cmd}_SOURCES=src/${cmd}.c"
+done
+
+# Load actual values from src/local.mk. This will read all the variables from
+# the local.mk matching the src_${cmd}_... case.
+while read l; do
+  if echo "$l" | grep -E '^src_\w+ +\+?=' > /dev/null; then
+    var=$(echo $l | cut -f 1 -d ' ')
+    value=$(echo $l | cut -f 2- -d =)
+    if [ "$value" != " \$(LDADD)" ]; then
+      oldvalue=""
+      if echo $l | grep -F '+=' >/dev/null; then
+        eval "oldvalue=\${$var}"
+      fi
+      eval "$var='$oldvalue "${value//\'/\'\"\'\"\'}"'"
+    fi
+  fi
+done < $LOCAL_MK
+
+me=`echo "$0" | sed 's,.*/,,'`
+echo "## Automatically generated by $me.  DO NOT EDIT BY HAND!"
+
+# Override the sources for dir and vdir. We use a smaller version of dir and
+# vdir that relies on the ls main.
+src_dir_SOURCES="src/coreutils-dir.c"
+src_dir_LDADD+=" src/libsinglebin_ls.a"
+echo src_libsinglebin_dir_a_DEPENDENCIES = src/libsinglebin_ls.a
+src_vdir_SOURCES="src/coreutils-vdir.c"
+src_vdir_LDADD+=" src/libsinglebin_ls.a"
+echo src_libsinglebin_vdir_a_DEPENDENCIES = src/libsinglebin_ls.a
+
+# Override the sources for arch likewise, using the main from uname.
+src_arch_SOURCES="src/coreutils-arch.c"
+src_arch_LDADD+=" src/libsinglebin_uname.a"
+echo src_libsinglebin_arch_a_DEPENDENCIES = src/libsinglebin_uname.a
+
+for cmd in $ALL_PROGRAMS; do
+  echo "# Command $cmd"
+  echo noinst_LIBRARIES += src/libsinglebin_${cmd}.a
+  base="src_libsinglebin_${cmd}_a"
+  # SOURCES
+  var=src_${cmd}_SOURCES
+  eval "value=\$$var"
+  echo "${base}_SOURCES = $value"
+
+  # LDADD
+  var=src_${cmd}_LDADD
+  eval "value=\$$var"
+  if [ "x$value" != "x" ]; then
+    echo "${base}_ldadd = $value"
+  fi
+
+  # CFLAGS
+  # Hack any other program defining a main() replacing its main by
+  # _single_binary_main_$PROGRAM_NAME.
+  echo "${base}_CFLAGS = \"-Dmain=_single_binary_main_${cmd}(int, char**) " \
+       "ATTRIBUTE_NORETURN; int _single_binary_main_${cmd}\" " \
+       "-Dusage=_usage_${cmd} \$(src_coreutils_CFLAGS)"
+  var=src_${cmd}_CFLAGS
+  eval "value=\$$var"
+  if [ "x$value" != "x" ]; then
+    echo "${base}_CFLAGS += $value"
+  fi
+
+  # CPPFLAGS
+  var=src_${cmd}_CPPFLAGS
+  eval "value=\$$var"
+  if [ "x$value" != "x" ]; then
+    echo "${base}_CPPFLAGS = $value"
+  fi
+done
+
+exit 0
diff --git a/configure.ac b/configure.ac
index 01098cf..27caffd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -213,6 +213,30 @@ if test "$gl_gcc_warnings" = yes; then
   AC_SUBST([GNULIB_TEST_WARN_CFLAGS])
 fi
 
+AC_ARG_ENABLE([single-binary],
+  [AS_HELP_STRING([--enable-single-binary=[shebangs|symlinks]],
+     [Compile all the tools in a single binary, reducing the overall size.
+      When compiled this way, shebangs (default when enabled) or symlinks are
+      installed for each tool that points to the single binary.])],
+  [gl_single_binary=no ;
+   case $enableval in
+     yes) gl_single_binary=shebangs ;;
+     no|shebangs|symlinks) gl_single_binary=$enableval ;;
+     *)      AC_MSG_ERROR([bad value $enableval for single-binary option.
+                           Options are: symlinks, shebangs, no.]) ;;
+   esac],
+  [gl_single_binary=no]
+)
+AC_ARG_ENABLE([single-binary-exceptions],
+  [AS_HELP_STRING([--enable-single-binary-exceptions=PROG_LIST],
+     [When used with --enable-single-binary, exclude the PROG_LIST from
+      it, so these programs are compiled as separated files
+      (comma-separated, default none))])],
+  [gl_single_binary_exceptions=$enableval],
+  [gl_single_binary_exceptions=]
+)
+AM_CONDITIONAL([SINGLE_BINARY], [test "$gl_single_binary" != no])
+
 AC_FUNC_FORK
 
 optional_bin_progs=
@@ -479,6 +503,51 @@ man1_MANS=`
 # a distribution tarball.
 EXTRA_MANS=`for p in $no_install_progs_default; do echo man/$p.1; done`
 
+# Replace all the programs by the single binary and symlinks if specified.
+single_binary_progs=
+single_binary_libs=
+single_binary_deps=
+single_binary_install_type=
+if test "$gl_single_binary" != no; then
+  # Convert the list to a space separated list
+  gl_single_binary_exceptions=`echo $gl_single_binary_exceptions | tr ',' ' '`
+
+  single_binary_progs=`echo $optional_bin_progs`
+  optional_bin_progs="coreutils"
+  for prog in $gl_single_binary_exceptions; do
+    # Fail if requested to exclude a program than was not part of coreutils.
+    case " $single_binary_progs " in
+      *" $prog "*)
+        gl_REMOVE_PROG([single_binary_progs], [$prog]) ;
+        gl_ADD_PROG([optional_bin_progs], [$prog]) ;;
+      *) AC_MSG_ERROR(['$prog' is not being compiled.]) ;;
+    esac
+  done
+
+  # single_binary_libs holds the list of libs required by the selected
+  # programs, such as for example -lrt.
+  single_binary_libs=`
+    for p in $single_binary_progs; do
+      # Convert '[' to '_'
+      test x"$p" = x'@<:@' && p='_'
+      printf '$(src_libsinglebin_%s_a_ldadd) ' "$p"
+    done`
+  # single_binary_deps holds the list of libsinglebin_*.a files that have the
+  # compiled code of each selected program in a "library" format.
+  single_binary_deps=`
+    for p in $single_binary_progs; do
+      # Convert '[' to '_'
+      test x"$p" = x'@<:@' && p='_'
+      printf 'src/libsinglebin_%s.a ' "$p"
+    done`
+  single_binary_install_type="$gl_single_binary"
+fi
+AC_SUBST([single_binary_progs], [$single_binary_progs])
+AC_SUBST([single_binary_libs], [$single_binary_libs])
+AC_SUBST([single_binary_deps], [$single_binary_deps])
+AC_SUBST([single_binary_install_type], [$single_binary_install_type])
+
+
 # The programs built and installed by "make && make install".
 # Since this is AC_SUBST'd, Automake won't be able to perform rewrite
 # with $(EXEEXT) appending on it, so we have to do it ourselves -- in
diff --git a/man/coreutils.x b/man/coreutils.x
new file mode 100644
index 0000000..a7a4879
--- /dev/null
+++ b/man/coreutils.x
@@ -0,0 +1,4 @@
+[NAME]
+coreutils \- single binary for coreutils programs
+[DESCRIPTION]
+.\" Add any additional description here
diff --git a/src/coreutils-arch.c b/src/coreutils-arch.c
new file mode 100644
index 0000000..899cc93
--- /dev/null
+++ b/src/coreutils-arch.c
@@ -0,0 +1,32 @@
+/* arch -- wrapper to uname with the right uname_mode.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Alex Deymo <deymo@chromium.org>.  */
+
+#include <config.h>
+#include "system.h"
+
+#include "uname.h"
+/* Ensure that the main for uname is declared even if the tool is not being
+   built in this single-binary. */
+int _single_binary_main_uname (int argc, char** argv) ATTRIBUTE_NORETURN;
+int _single_binary_main_arch (int argc, char** argv) ATTRIBUTE_NORETURN;
+
+int _single_binary_main_arch (int argc, char** argv)
+{
+  uname_mode = UNAME_ARCH;
+  _single_binary_main_uname (argc, argv);
+}
diff --git a/src/coreutils-dir.c b/src/coreutils-dir.c
new file mode 100644
index 0000000..4b488f4
--- /dev/null
+++ b/src/coreutils-dir.c
@@ -0,0 +1,32 @@
+/* dir -- wrapper to ls with the right ls_mode.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Alex Deymo <deymo@chromium.org>.  */
+
+#include <config.h>
+#include "system.h"
+
+#include "ls.h"
+/* Ensure that the main for ls is declared even if the tool is not being built
+   in this single-binary. */
+int _single_binary_main_ls (int argc, char** argv) ATTRIBUTE_NORETURN;
+int _single_binary_main_dir (int argc, char** argv) ATTRIBUTE_NORETURN;
+
+int _single_binary_main_dir (int argc, char** argv)
+{
+  ls_mode = LS_MULTI_COL;
+  _single_binary_main_ls (argc, argv);
+}
diff --git a/src/coreutils-vdir.c b/src/coreutils-vdir.c
new file mode 100644
index 0000000..036367f
--- /dev/null
+++ b/src/coreutils-vdir.c
@@ -0,0 +1,32 @@
+/* vdir -- wrapper to ls with the right ls_mode.
+   Copyright (C) 2014 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Alex Deymo <deymo@chromium.org>.  */
+
+#include <config.h>
+#include "system.h"
+
+#include "ls.h"
+/* Ensure that the main for ls is declared even if the tool is not being built
+   in this single-binary. */
+int _single_binary_main_ls (int argc, char** argv) ATTRIBUTE_NORETURN;
+int _single_binary_main_vdir (int argc, char** argv) ATTRIBUTE_NORETURN;
+
+int _single_binary_main_vdir (int argc, char** argv)
+{
+  ls_mode = LS_LONG_FORMAT;
+  _single_binary_main_ls (argc, argv);
+}
diff --git a/src/coreutils.c b/src/coreutils.c
new file mode 100644
index 0000000..f54f85d
--- /dev/null
+++ b/src/coreutils.c
@@ -0,0 +1,167 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* coreutils.c aggregates the functionality of every other tool into a single
+   binary multiplexed by the value of argv[0]. This is enabled by passing
+   --enable-single-binary to configure.
+
+   Written by Alex Deymo <deymo@chromium.org>.  */
+
+#include <config.h>
+#include <getopt.h>
+#include <stdio.h>
+#if HAVE_PRCTL
+# include <sys/prctl.h>
+#endif
+
+#include "system.h"
+#include "error.h"
+
+/* Declare the main function on each one of the selected tools.  This name
+   needs to match the one passed as CFLAGS on single-binary.mk (generated
+   by gen-single-binary.sh). */
+#define SINGLE_BINARY_PROGRAM(prog_name_str, main_name) \
+  int _single_binary_main_##main_name (int, char**) ATTRIBUTE_NORETURN;
+#include "coreutils.h"
+#undef SINGLE_BINARY_PROGRAM
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "coreutils"
+
+#define AUTHORS \
+  proper_name ("Alex Deymo")
+
+void
+launch_program (const char *prog_name, int prog_argc, char **prog_argv);
+
+static struct option const long_options[] =
+{
+  {GETOPT_HELP_OPTION_DECL},
+  {GETOPT_VERSION_OPTION_DECL},
+  {NULL, 0, NULL, 0}
+};
+
+
+void
+usage (int status)
+{
+  if (status != EXIT_SUCCESS)
+    emit_try_help ();
+  else
+    {
+      printf (_("\
+Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"),
+              program_name);
+      fputs (_("\
+Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n\
+\n"), stdout);
+      fputs (HELP_OPTION_DESCRIPTION, stdout);
+      fputs (VERSION_OPTION_DESCRIPTION, stdout);
+
+      printf ("\n\
+Built-in programs:\n"
+#define SINGLE_BINARY_PROGRAM(prog_name_str, main_name) " " prog_name_str
+#include "coreutils.h"
+#undef SINGLE_BINARY_PROGRAM
+  "\n");
+
+      printf (_("\
+\n\
+Try: '%s PROGRAM_NAME --help' for help on the particular program.\n"),
+              program_name);
+      emit_ancillary_info ();
+    }
+  exit (status);
+}
+
+void
+launch_program (const char *prog_name, int prog_argc, char **prog_argv)
+{
+  int (*prog_main)(int, char **) = NULL;
+
+  /* Ensure that at least one parameter was passed.  */
+  if (!prog_argc || !prog_argv || !prog_argv[0] || !prog_name)
+    return;
+
+  /* Lookup the right main program.  */
+#define SINGLE_BINARY_PROGRAM(prog_name_str, main_name) \
+  if (STREQ (prog_name_str, prog_name)) \
+    prog_main = _single_binary_main_##main_name;
+#include "coreutils.h"
+#undef SINGLE_BINARY_PROGRAM
+
+  if (!prog_main)
+    return;
+
+#if HAVE_PRCTL && defined PR_SET_NAME
+  /* Not being able to set the program name is not a fatal error.  */
+  prctl (PR_SET_NAME, prog_name);
+#endif
+#if HAVE_PRCTL && defined PR_SET_MM_ARG_START
+  /* Shift the beginning of the command line to prog_argv[0] (if set) so
+     /proc/pid/cmdline reflects the right value.  */
+  prctl (PR_SET_MM_ARG_START, prog_argv[0]);
+#endif
+
+  exit ((*prog_main) (prog_argc, prog_argv));
+}
+
+int
+main (int argc, char **argv)
+{
+  char *prog_name = last_component (argv[0]);
+  int optc;
+
+  /* If this program is called directly as "coreutils" or if the value of
+     argv[0] is an unknown tool (which "coreutils" is), we proceed and parse
+     the options.  */
+  launch_program (prog_name, argc, argv);
+
+  /* No known program was selected via argv[0].  Try parsing the first
+     argument as --coreutils-prog=PROGRAM to determine the program.  The
+     invocation for this case should be:
+       path/to/coreutils --coreutils-prog=someprog someprog ...
+     The third argument is what the program will see as argv[0].  */
+
+  if (argc >= 2 && STRPREFIX (argv[1], "--coreutils-prog="))
+    {
+      prog_name = argv[1] + strlen ("--coreutils-prog=");
+      launch_program (prog_name, argc - 2, argv + 2);
+    }
+
+  /* No known program was selected.  From here on, we behave like any other
+     coreutils program.  */
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  atexit (close_stdout);
+
+  if ((optc = getopt_long (argc, argv, "", long_options, NULL)) != -1)
+    switch (optc)
+      {
+      case_GETOPT_HELP_CHAR;
+
+      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
+      }
+
+  /* Only print the error message when no options have been passed
+     to coreutils.  */
+  if (optind == 1 && prog_name && !STREQ (prog_name, "coreutils"))
+    error (0, ENOENT, _("program %s"), prog_name);
+
+  usage (EXIT_FAILURE);
+}
diff --git a/src/kill.c b/src/kill.c
index 4ab86a4..724667e 100644
--- a/src/kill.c
+++ b/src/kill.c
@@ -306,7 +306,7 @@ main (int argc, char **argv)
       usage (EXIT_FAILURE);
     }
 
-  return (list
-          ? list_signals (table, optind < argc ? argv + optind : NULL)
-          : send_signals (signum, argv + optind));
+  exit (list
+        ? list_signals (table, optind < argc ? argv + optind : NULL)
+        : send_signals (signum, argv + optind));
 }
diff --git a/src/readlink.c b/src/readlink.c
index d63f07b..f46d948 100644
--- a/src/readlink.c
+++ b/src/readlink.c
@@ -174,5 +174,5 @@ main (int argc, char **argv)
         }
     }
 
-  return status;
+  exit (status);
 }
diff --git a/src/shuf.c b/src/shuf.c
index 915f7b7..2505be6 100644
--- a/src/shuf.c
+++ b/src/shuf.c
@@ -622,5 +622,5 @@ main (int argc, char **argv)
     }
 #endif
 
-  return EXIT_SUCCESS;
+  exit (EXIT_SUCCESS);
 }
diff --git a/src/timeout.c b/src/timeout.c
index 23d8941..68baa23 100644
--- a/src/timeout.c
+++ b/src/timeout.c
@@ -440,7 +440,7 @@ main (int argc, char **argv)
   if (monitored_pid == -1)
     {
       error (0, errno, _("fork system call failed"));
-      return EXIT_CANCELED;
+      exit (EXIT_CANCELED);
     }
   else if (monitored_pid == 0)
     {                           /* child */
@@ -455,7 +455,7 @@ main (int argc, char **argv)
       /* exit like sh, env, nohup, ...  */
       exit_status = (errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE);
       error (0, errno, _("failed to run command %s"), quote (argv[0]));
-      return exit_status;
+      exit (exit_status);
     }
   else
     {
@@ -500,8 +500,8 @@ main (int argc, char **argv)
         }
 
       if (timed_out && !preserve_status)
-        return EXIT_TIMEDOUT;
+        exit (EXIT_TIMEDOUT);
       else
-        return status;
+        exit (status);
     }
 }
diff --git a/src/truncate.c b/src/truncate.c
--- a/src/truncate.c
+++ b/src/truncate.c
@@ -420,5 +420,5 @@
         }
     }
 
-  return errors ? EXIT_FAILURE : EXIT_SUCCESS;
+  exit (errors ? EXIT_FAILURE : EXIT_SUCCESS);
 }
