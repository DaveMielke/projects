commit a710e15d39d43a5662d44d98eabaff76236cf518
Author: David James <davidjames@chromium.org>
Date:   Tue May 3 11:14:24 2011 -0700

    emerge: add --rebuild and --norebuild-atoms opts
    
    Rebuild when build-time/run-time deps are upgraded.
    
    If pkgA has been updated, and pkgB depends on pkgA at both
    build-time and run-time, pkgB needs to be rebuilt. This
    feature ensures that all packages are consistent when
    dependencies that are used at both runtime and build time
    are changed.
    
    This feature only rebuilds packages one layer deep. That
    means that if you upgrade libcros, for example, packages
    that depend directly on libcros will be rebuilt and
    reinstalled, but indirect dependencies will not be rebuilt.
    
    BUG=chromium-os:14296
    
    TEST=Test whether packages rebuilding a bunch of packages.
    
    Change-Id: Idbc0532b4b1de28fd9e5a0abe3b7dbe1a3abd2c8
    (cherry-picked from commit 470871eeafa89a05486d4eb6f3f7626c1f813e4d)
    
    Review URL: http://codereview.chromium.org/6905107
    
    depgraph: ignore unwanted virtuals
    
    This fixes an unwanted side-effect from commit
    470871eeafa89a05486d4eb6f3f7626c1f813e4d.
    (cherry picked from commit b26576b2d4b3b5f99dde4d33003192be973401ce)
    
    depgraph: traverse bdeps in complete mode
    
    This makes the graph as complete as possible, and can help --rebuild to
    find more rebuilds.
    (cherry picked from commit a524f21fc85e899455d13301c3d435077c694ece)
    
    trigger_rebuilds: handle circular deps
    (cherry picked from commit dd794a5e94fa846975b440824534aeffd629f60b)
    
    depgraph: queue ignored deps for later traversal
    
    This will fix an issue with some build-time deps being ignored by
    --complete-graph in cases when --with-bdeps is not enabled. It
    should help --rebuild to find more rebuilds in this case.
    (cherry picked from commit 60564a32c71ce9362e9329c7fd87783699c2c4b4)
    
    Conflicts:
    
    	pym/_emerge/depgraph.py
    
    Change-Id: I93ae064b3adb5b14cf6e6a29f81336b2f0f82a0c
    
    depgraph: autounmask account for optional deps
    (cherry picked from commit 5f9dedaa14bbb704e055f2fa616821b79f9c6914)
    
    emerge: rename --no*-atoms to --*-exclude
    (cherry picked from commit c522bc7e2c2c116a061eca24a1697841947bc433)
    
    rebuild_config: propagate runtime deps to parents
    
    Update rebuild option to propagate runtime deps to parents.
    
    Suggested by SebastianLuther@gmx.de
    
    BUG=chromium-os:14858
    TEST=Added unit test. Ran unit tests.
    
    Change-Id: I7228a8558eddd1956c590de39430172476c66228
    
    Review URL: http://gerrit.chromium.org/gerrit/202
    (cherry picked from commit 5d26fe64b1f8b56f1f3e588921f33bc9df4da78d)
    
    Add --rebuild-ignore flag.
    
    A space separated list of package names or slot atoms. Emerge will not rebuild
    packages that depend on matching packages due to \fB\-\-rebuild\fR.
    
    Change-Id: Ia58fe632ed06c97a22413da0341d7f8da2d65ba8
    
    Review URL: http://gerrit.chromium.org/gerrit/209
    (cherry picked from commit 9a3a1c4b2d182bef0579166589475df93247a009)
    
    emerge: replace --rebuild with finer grained opts
    
    Replace --rebuild option with --rebuild-if-* options.
    
    --rebuild-if-new-rev [ y | n ]
      Rebuild packages when dependencies that are used at both build-time and
      run-time are built, if the dependency is not already installed with the
      same version and revision.
    
    --rebuild-if-new-ver [ y | n ]
      Rebuild packages when dependencies that are used at both build-time and
      run-time are built, if the dependency is not already installed with the
      same version. Revision numbers are ignored.
    
    --rebuild-if-unbuilt [ y | n ]
      Rebuild packages when dependencies that are used at both build-time and
      run-time are built.
    
    Change-Id: Ia50c1702bfe1b98a8d1891740e7bbb045921a905
    
    Review URL: http://gerrit.chromium.org/gerrit/280
    (cherry picked from commit e4297ca1075342ec89e089802cd25ae0817f3d5b)
    
    Conflicts:
    
    	pym/_emerge/depgraph.py
    
    test_rebuild: test --rebuild-if-new-rev more
    (cherry picked from commit 9b697efa947ef88effc15ee86f766af68ec6097a)

diff --git a/man/emerge.1 b/man/emerge.1
index ae65c70..0450d7a 100644
--- a/man/emerge.1
+++ b/man/emerge.1
@@ -469,10 +469,18 @@ may have changed.
 Disables the spinner for the session.  The spinner is active when the
 terminal device is determined to be a TTY.  This flag disables it regardless.
 .TP
-.BR "\-\-nousepkg\-atoms " ATOMS
+.BR "\-\-usepkg\-exclude " ATOMS
 A space separated list of package names or slot atoms. Emerge will ignore
 matching binary packages.
 .TP
+.BR "\-\-rebuild\-exclude " ATOMS
+A space separated list of package names or slot atoms. Emerge will not rebuild
+matching packages due to \fB\-\-rebuild\fR.
+.TP
+.BR "\-\-rebuild\-ignore " ATOMS
+A space separated list of package names or slot atoms. Emerge will not rebuild
+packages that depend on matching packages due to \fB\-\-rebuild\fR.
+.TP
 .BR "\-\-oneshot " (\fB\-1\fR)
 Emerge as normal, but do not add the packages to the world file
 for later updating.
@@ -522,6 +530,20 @@ Disable the warning message that's shown prior to
 to be set in the \fBmake.conf\fR(5)
 \fBEMERGE_DEFAULT_OPTS\fR variable.
 .TP
+.BR "\-\-rebuild\-if\-new\-rev [ y | n ]"
+Rebuild packages when dependencies that are used at both build\-time and
+run\-time are built, if the dependency is not already installed with the
+same version and revision.
+.TP
+.BR "\-\-rebuild\-if\-new\-ver [ y | n ]"
+Rebuild packages when dependencies that are used at both build\-time and
+run\-time are built, if the dependency is not already installed with the
+same version. Revision numbers are ignored.
+.TP
+.BR "\-\-rebuild\-if\-unbuilt [ y | n ]"
+Rebuild packages when dependencies that are used at both build\-time and
+run\-time are built.
+.TP
 .BR "\-\-rebuilt\-binaries [ y | n ]"
 Replace installed packages with binary packages that have
 been rebuilt. Rebuilds are detected by comparison of
diff --git a/pym/_emerge/DepPriority.py b/pym/_emerge/DepPriority.py
index f99b726..b08ffe5 100644
--- a/pym/_emerge/DepPriority.py
+++ b/pym/_emerge/DepPriority.py
@@ -4,7 +4,7 @@
 from _emerge.AbstractDepPriority import AbstractDepPriority
 class DepPriority(AbstractDepPriority):
 
-	__slots__ = ("satisfied", "optional", "rebuild")
+	__slots__ = ("satisfied", "optional", "rebuild", "ignored")
 
 	def __int__(self):
 		"""
@@ -24,17 +24,19 @@ class DepPriority(AbstractDepPriority):
 
 		"""
 
+		if self.optional:
+			return -3
 		if self.buildtime:
 			return 0
 		if self.runtime:
 			return -1
 		if self.runtime_post:
 			return -2
-		if self.optional:
-			return -3
 		return -4
 
 	def __str__(self):
+		if self.ignored:
+			return "ignored"
 		if self.optional:
 			return "optional"
 		if self.buildtime:
diff --git a/pym/_emerge/DepPriorityNormalRange.py b/pym/_emerge/DepPriorityNormalRange.py
index 259a1df..808c950 100644
--- a/pym/_emerge/DepPriorityNormalRange.py
+++ b/pym/_emerge/DepPriorityNormalRange.py
@@ -33,7 +33,7 @@ class DepPriorityNormalRange(object):
 	def _ignore_runtime(cls, priority):
 		if priority.__class__ is not DepPriority:
 			return False
-		return not priority.buildtime
+		return bool(priority.optional or not priority.buildtime)
 
 	ignore_medium      = _ignore_runtime
 	ignore_medium_soft = _ignore_runtime_post
diff --git a/pym/_emerge/DepPrioritySatisfiedRange.py b/pym/_emerge/DepPrioritySatisfiedRange.py
index aa32d8f..589afde 100644
--- a/pym/_emerge/DepPrioritySatisfiedRange.py
+++ b/pym/_emerge/DepPrioritySatisfiedRange.py
@@ -80,6 +80,7 @@ class DepPrioritySatisfiedRange(object):
 		if priority.__class__ is not DepPriority:
 			return False
 		return bool(priority.satisfied or \
+			priority.optional or \
 			not priority.buildtime)
 
 	ignore_medium      = _ignore_runtime
diff --git a/pym/_emerge/Dependency.py b/pym/_emerge/Dependency.py
index 63b2a1b..d5d519d 100644
--- a/pym/_emerge/Dependency.py
+++ b/pym/_emerge/Dependency.py
@@ -5,11 +5,16 @@ from _emerge.DepPriority import DepPriority
 from _emerge.SlotObject import SlotObject
 class Dependency(SlotObject):
 	__slots__ = ("atom", "blocker", "child", "depth",
-		"parent", "onlydeps", "priority", "root")
+		"parent", "onlydeps", "priority", "root",
+		"collapsed_parent", "collapsed_priority")
 	def __init__(self, **kwargs):
 		SlotObject.__init__(self, **kwargs)
 		if self.priority is None:
 			self.priority = DepPriority()
 		if self.depth is None:
 			self.depth = 0
+		if self.collapsed_parent is None:
+			self.collapsed_parent = self.parent
+		if self.collapsed_priority is None:
+			self.collapsed_priority = self.priority
 
diff --git a/pym/_emerge/UnmergeDepPriority.py b/pym/_emerge/UnmergeDepPriority.py
index 0f67f3b..db4836e 100644
--- a/pym/_emerge/UnmergeDepPriority.py
+++ b/pym/_emerge/UnmergeDepPriority.py
@@ -3,7 +3,7 @@
 
 from _emerge.AbstractDepPriority import AbstractDepPriority
 class UnmergeDepPriority(AbstractDepPriority):
-	__slots__ = ("optional", "satisfied",)
+	__slots__ = ("ignored", "optional", "satisfied",)
 	"""
 	Combination of properties           Priority  Category
 
@@ -32,6 +32,8 @@ class UnmergeDepPriority(AbstractDepPriority):
 		return -2
 
 	def __str__(self):
+		if self.ignored:
+			return "ignored"
 		myvalue = self.__int__()
 		if myvalue > self.SOFT:
 			return "hard"
diff --git a/pym/_emerge/create_depgraph_params.py b/pym/_emerge/create_depgraph_params.py
index d60259e..44dceda 100644
--- a/pym/_emerge/create_depgraph_params.py
+++ b/pym/_emerge/create_depgraph_params.py
@@ -17,6 +17,10 @@ def create_depgraph_params(myopts, myaction):
 	# rebuilt_binaries: replace installed packages with rebuilt binaries
 	myparams = {"recurse" : True}
 
+	bdeps = myopts.get("--with-bdeps")
+	if bdeps is not None:
+		myparams["bdeps"] = bdeps
+
 	if myaction == "remove":
 		myparams["remove"] = True
 		myparams["complete"] = True
@@ -33,7 +37,8 @@ def create_depgraph_params(myopts, myaction):
 	deep = myopts.get("--deep")
 	if deep is not None and deep != 0:
 		myparams["deep"] = deep
-	if "--complete-graph" in myopts:
+	if ("--complete-graph" in myopts or "--rebuild-if-new-rev" in myopts or
+		"--rebuild-if-new-ver" in myopts or "--rebuild-if-unbuilt" in myopts):
 		myparams["complete"] = True
 	if "--emptytree" in myopts:
 		myparams["empty"] = True
diff --git a/pym/_emerge/depgraph.py b/pym/_emerge/depgraph.py
index a3eae01..9811e14 100644
--- a/pym/_emerge/depgraph.py
+++ b/pym/_emerge/depgraph.py
@@ -9,6 +9,7 @@ import logging
 import re
 import sys
 import textwrap
+from collections import deque
 from itertools import chain
 
 import portage
@@ -29,6 +30,7 @@ from portage._sets.base import InternalPackageSet
 from portage.util import cmp_sort_key, writemsg, writemsg_stdout
 from portage.util import writemsg_level
 from portage.util.digraph import digraph
+from portage.versions import catpkgsplit
 
 from _emerge.AtomArg import AtomArg
 from _emerge.Blocker import Blocker
@@ -122,10 +124,18 @@ class _frozen_depgraph_config(object):
 		self.excluded_pkgs = _wildcard_set(atoms)
 		atoms = ' '.join(myopts.get("--reinstall-atoms", [])).split()
 		self.reinstall_atoms = _wildcard_set(atoms)
-		atoms = ' '.join(myopts.get("--nousepkg-atoms", [])).split()
-		self.nousepkg_atoms = _wildcard_set(atoms)
+		atoms = ' '.join(myopts.get("--usepkg-exclude", [])).split()
+		self.usepkg_exclude = _wildcard_set(atoms)
 		atoms = ' '.join(myopts.get("--useoldpkg-atoms", [])).split()
 		self.useoldpkg_atoms = _wildcard_set(atoms)
+		atoms = ' '.join(myopts.get("--rebuild-exclude", [])).split()
+		self.rebuild_exclude = _wildcard_set(atoms)
+		atoms = ' '.join(myopts.get("--rebuild-ignore", [])).split()
+		self.rebuild_ignore = _wildcard_set(atoms)
+
+		self.rebuild_if_new_rev = "--rebuild-if-new-rev" in myopts
+		self.rebuild_if_new_ver = "--rebuild-if-new-ver" in myopts
+		self.rebuild_if_unbuilt = "--rebuild-if-unbuilt" in myopts
 
 class _depgraph_sets(object):
 	def __init__(self):
@@ -138,10 +148,202 @@ class _depgraph_sets(object):
 		self.atoms = InternalPackageSet()
 		self.atom_arg_map = {}
 
+class _rebuild_config(object):
+	def __init__(self, frozen_config, rebuild_list, reinstall_list):
+		self._graph = digraph()
+		self._frozen_config = frozen_config
+		self.rebuild_list = (rebuild_list or set()).copy()
+		self.orig_rebuild_list = self.rebuild_list.copy()
+		self.reinstall_list = (reinstall_list or set()).copy()
+		self.rebuild_if_new_rev = frozen_config.rebuild_if_new_rev
+		self.rebuild_if_new_ver = frozen_config.rebuild_if_new_ver
+		self.rebuild_if_unbuilt = frozen_config.rebuild_if_unbuilt
+		self.rebuild = (self.rebuild_if_new_rev or self.rebuild_if_new_ver or
+			self.rebuild_if_unbuilt)
+
+	def add(self, dep_pkg, dep):
+		parent = dep.collapsed_parent
+		priority = dep.collapsed_priority
+		rebuild_exclude = self._frozen_config.rebuild_exclude
+		rebuild_ignore = self._frozen_config.rebuild_ignore
+		if (self.rebuild and isinstance(parent, Package) and
+			parent.built and (priority.buildtime or priority.runtime) and
+			isinstance(dep_pkg, Package) and
+			not rebuild_exclude.findAtomForPackage(parent) and
+			not rebuild_ignore.findAtomForPackage(dep_pkg)):
+			self._graph.add(dep_pkg, parent, priority)
+
+	def _needs_rebuild(self, dep_pkg):
+		"""Check whether packages that depend on dep_pkg need to be rebuilt."""
+		dep_root_slot = (dep_pkg.root, dep_pkg.slot_atom)
+		if dep_pkg.built or dep_root_slot in self.orig_rebuild_list:
+			return False
+
+		if self.rebuild_if_unbuilt:
+			# dep_pkg is being installed from source, so binary
+			# packages for parents are invalid. Force rebuild
+			return True
+
+		trees = self._frozen_config.trees
+		vardb = trees[dep_pkg.root]["vartree"].dbapi
+		if self.rebuild_if_new_rev:
+			# Parent packages are valid if a package with the same
+			# cpv is already installed.
+			return dep_pkg.cpv not in vardb.match(dep_pkg.slot_atom)
+
+		# Otherwise, parent packages are valid if a package with the same
+		# version (excluding revision) is already installed.
+		assert self.rebuild_if_new_ver
+		cpv_norev = catpkgsplit(dep_pkg.cpv)[:-1]
+		for inst_cpv in vardb.match(dep_pkg.slot_atom):
+			inst_cpv_norev = catpkgsplit(inst_cpv)[:-1]
+			if inst_cpv_norev == cpv_norev:
+				return False
+
+		return True
+
+	def _trigger_rebuild(self, parent, build_deps, runtime_deps):
+		root_slot = (parent.root, parent.slot_atom)
+		if root_slot in self.rebuild_list:
+			return False
+		trees = self._frozen_config.trees
+		children = set(build_deps).intersection(runtime_deps)
+		reinstall = False
+		for slot_atom in children:
+			kids = set([build_deps[slot_atom], runtime_deps[slot_atom]])
+			for dep_pkg in kids:
+				dep_root_slot = (dep_pkg.root, slot_atom)
+				if self._needs_rebuild(dep_pkg):
+					self.rebuild_list.add(root_slot)
+					return True
+				elif ("--usepkg" in self._frozen_config.myopts and
+					(dep_root_slot in self.reinstall_list or
+					dep_root_slot in self.rebuild_list or
+					not dep_pkg.installed)):
+
+					# A direct rebuild dependency is being installed. We
+					# should update the parent as well to the latest binary,
+					# if that binary is valid.
+					#
+					# To validate the binary, we check whether all of the
+					# rebuild dependencies are present on the same binhost.
+					#
+					# 1) If parent is present on the binhost, but one of its
+					#    rebuild dependencies is not, then the parent should
+					#    be rebuilt from source.
+					# 2) Otherwise, the parent binary is assumed to be valid,
+					#    because all of its rebuild dependencies are
+					#    consistent.
+					bintree = trees[parent.root]["bintree"]
+					uri = bintree.get_pkgindex_uri(parent.cpv)
+					dep_uri = bintree.get_pkgindex_uri(dep_pkg.cpv)
+					bindb = bintree.dbapi
+					if self.rebuild_if_new_ver and uri and uri != dep_uri:
+						cpv_norev = catpkgsplit(dep_pkg.cpv)[:-1]
+						for cpv in bindb.match(dep_pkg.slot_atom):
+							if cpv_norev == catpkgsplit(cpv)[:-1]:
+								dep_uri = bintree.get_pkgindex_uri(cpv)
+								if uri == dep_uri:
+									break
+					if uri and uri != dep_uri:
+						# 1) Remote binary package is invalid because it was
+						#    built without dep_pkg. Force rebuild.
+						self.rebuild_list.add(root_slot)
+						return True
+					elif (parent.installed and
+						root_slot not in self.reinstall_list):
+						inst_build_time = parent.metadata.get("BUILD_TIME")
+						try:
+							bin_build_time, = bindb.aux_get(parent.cpv,
+								["BUILD_TIME"])
+						except KeyError:
+							continue
+						if bin_build_time != inst_build_time:
+							# 2) Remote binary package is valid, and local package
+							#    is not up to date. Force reinstall.
+							reinstall = True
+		if reinstall:
+			self.reinstall_list.add(root_slot)
+		return reinstall
+
+	def trigger_rebuilds(self):
+		"""
+		Trigger rebuilds where necessary. If pkgA has been updated, and pkgB
+		depends on pkgA at both build-time and run-time, pkgB needs to be
+		rebuilt.
+		"""
+		need_restart = False
+		graph = self._graph
+		build_deps = {}
+		runtime_deps = {}
+		leaf_nodes = deque(graph.leaf_nodes())
+
+		def ignore_non_runtime(priority):
+			return not priority.runtime
+
+		def ignore_non_buildtime(priority):
+			return not priority.buildtime
+
+		# Trigger rebuilds bottom-up (starting with the leaves) so that parents
+		# will always know which children are being rebuilt.
+		while not graph.empty():
+			if not leaf_nodes:
+				# We're interested in intersection of buildtime and runtime,
+				# so ignore edges that do not contain both.
+				leaf_nodes.extend(graph.leaf_nodes(
+					ignore_priority=ignore_non_runtime))
+				if not leaf_nodes:
+					leaf_nodes.extend(graph.leaf_nodes(
+						ignore_priority=ignore_non_buildtime))
+					if not leaf_nodes:
+						# We'll have to drop an edge that is both
+						# buildtime and runtime. This should be
+						# quite rare.
+						leaf_nodes.append(graph.order[-1])
+
+			node = leaf_nodes.popleft()
+			if node not in graph:
+				# This can be triggered by circular dependencies.
+				continue
+			slot_atom = node.slot_atom
+
+			# Remove our leaf node from the graph, keeping track of deps.
+			parents = graph.nodes[node][1].items()
+			graph.remove(node)
+			node_build_deps = build_deps.get(node, {})
+			node_runtime_deps = runtime_deps.get(node, {})
+			for parent, priorities in parents:
+				if parent == node:
+					# Ignore a direct cycle.
+					continue
+				parent_bdeps = build_deps.setdefault(parent, {})
+				parent_rdeps = runtime_deps.setdefault(parent, {})
+				for priority in priorities:
+					if priority.buildtime:
+						parent_bdeps[slot_atom] = node
+					if priority.runtime:
+						parent_rdeps[slot_atom] = node
+				if slot_atom in parent_bdeps and slot_atom in parent_rdeps:
+					parent_rdeps.update(node_runtime_deps)
+				if not graph.child_nodes(parent):
+					leaf_nodes.append(parent)
+
+			# Trigger rebuilds for our leaf node. Because all of our children
+			# have been processed, build_deps and runtime_deps will be
+			# completely filled in, and self.rebuild_list / self.reinstall_list
+			# will tell us whether any of our children need to be rebuilt or
+			# reinstalled.
+			if self._trigger_rebuild(node, node_build_deps, node_runtime_deps):
+				need_restart = True
+
+		return need_restart
+
+
 class _dynamic_depgraph_config(object):
 
 	def __init__(self, depgraph, myparams, allow_backtracking,
-		runtime_pkg_mask, needed_unstable_keywords, needed_use_config_changes, needed_license_changes):
+		runtime_pkg_mask, needed_unstable_keywords, needed_use_config_changes, needed_license_changes,
+		rebuild_list=None, reinstall_list=None):
 		self.myparams = myparams.copy()
 		self._vdb_loaded = False
 		self._allow_backtracking = allow_backtracking
@@ -239,6 +441,7 @@ class _dynamic_depgraph_config(object):
 		# For conditions that always require user intervention, such as
 		# unsatisfied REQUIRED_USE (currently has no autounmask support).
 		self._skip_restart = False
+		self._traverse_ignored_deps = False
 
 		for myroot in depgraph._frozen_config.trees:
 			self.sets[myroot] = _depgraph_sets()
@@ -318,7 +521,8 @@ class depgraph(object):
 	
 	def __init__(self, settings, trees, myopts, myparams, spinner,
 		frozen_config=None, runtime_pkg_mask=None, needed_unstable_keywords=None, \
-			needed_use_config_changes=None, needed_license_changes=None, allow_backtracking=False):
+			needed_use_config_changes=None, needed_license_changes=None, allow_backtracking=False,
+			rebuild_list=None, reinstall_list=None):
 		if frozen_config is None:
 			frozen_config = _frozen_depgraph_config(settings, trees,
 			myopts, spinner)
@@ -326,6 +530,8 @@ class depgraph(object):
 		self._dynamic_config = _dynamic_depgraph_config(self, myparams,
 			allow_backtracking, runtime_pkg_mask, needed_unstable_keywords, \
 			needed_use_config_changes, needed_license_changes)
+		self._rebuild = _rebuild_config(frozen_config, rebuild_list,
+			reinstall_list)
 
 		self._select_atoms = self._select_atoms_highest_available
 		self._select_package = self._select_pkg_highest_available
@@ -691,6 +897,8 @@ class depgraph(object):
 		if dep.blocker:
 			if not buildpkgonly and \
 				not nodeps and \
+				not dep.collapsed_priority.ignored and \
+				not dep.collapsed_priority.optional and \
 				dep.parent not in self._dynamic_config._slot_collision_nodes:
 				if dep.parent.onlydeps:
 					# It's safe to ignore blockers if the
@@ -715,9 +923,9 @@ class depgraph(object):
 				dep.root].get(dep_pkg.slot_atom)
 
 		if not dep_pkg:
-			if dep.priority.optional:
-				# This could be an unnecessary build-time dep
-				# pulled in by --with-bdeps=y.
+			if (dep.collapsed_priority.optional or
+				dep.collapsed_priority.ignored):
+				# This is an unnecessary build-time dep.
 				return 1
 			if allow_unsatisfied:
 				self._dynamic_config._unsatisfied_deps.append(dep)
@@ -762,7 +970,11 @@ class depgraph(object):
 
 			return 0
 
-		if not self._add_pkg(dep_pkg, dep):
+		self._rebuild.add(dep_pkg, dep)
+
+		ignore = dep.collapsed_priority.ignored and \
+			not self._dynamic_config._traverse_ignored_deps
+		if not ignore and not self._add_pkg(dep_pkg, dep):
 			return 0
 		return 1
 
@@ -1129,8 +1341,9 @@ class depgraph(object):
 			edepend["RDEPEND"] = ""
 			edepend["PDEPEND"] = ""
 
+		ignore_build_time_deps = False
 		if pkg.built and not removal_action:
-			if self._frozen_config.myopts.get("--with-bdeps", "n") == "y":
+			if self._dynamic_config.myparams.get("bdeps", "n") == "y":
 				# Pull in build time deps as requested, but marked them as
 				# "optional" since they are not strictly required. This allows
 				# more freedom in the merge order calculation for solving
@@ -1140,11 +1353,10 @@ class depgraph(object):
 				# failing.
 				pass
 			else:
-				# built packages do not have build time dependencies.
-				edepend["DEPEND"] = ""
+				ignore_build_time_deps = True
 
-		if removal_action and self._frozen_config.myopts.get("--with-bdeps", "y") == "n":
-			edepend["DEPEND"] = ""
+		if removal_action and self._dynamic_config.myparams.get("bdeps", "y") == "n":
+			ignore_build_time_deps = True
 
 		if removal_action:
 			depend_root = myroot
@@ -1155,13 +1367,14 @@ class depgraph(object):
 				if root_deps is True:
 					depend_root = myroot
 				elif root_deps == "rdeps":
-					edepend["DEPEND"] = ""
+					ignore_build_time_deps = True
 
 		deps = (
 			(depend_root, edepend["DEPEND"],
-				self._priority(buildtime=(not pkg.built),
-				optional=pkg.built),
-				pkg.built),
+				self._priority(buildtime=True,
+				optional=(pkg.built or ignore_build_time_deps),
+				ignored=ignore_build_time_deps),
+				pkg.built or ignore_build_time_deps),
 			(myroot, edepend["RDEPEND"],
 				self._priority(runtime=True),
 				False),
@@ -1232,6 +1445,20 @@ class depgraph(object):
 
 	def _add_pkg_dep_string(self, pkg, dep_root, dep_priority, dep_string,
 		allow_unsatisfied, ignore_blockers=False):
+		_autounmask_backup = self._dynamic_config._autounmask
+		if dep_priority.optional or dep_priority.ignored:
+			# Temporarily disable autounmask for deps that
+			# don't necessarily need to be satisfied.
+			self._dynamic_config._autounmask = False
+		try:
+			return self._wrapped_add_pkg_dep_string(
+				pkg, dep_root, dep_priority, dep_string,
+				allow_unsatisfied, ignore_blockers=ignore_blockers)
+		finally:
+			self._dynamic_config._autounmask = _autounmask_backup
+
+	def _wrapped_add_pkg_dep_string(self, pkg, dep_root, dep_priority,
+		dep_string, allow_unsatisfied, ignore_blockers=False):
 		depth = pkg.depth + 1
 		deep = self._dynamic_config.myparams.get("deep", 0)
 		recurse_satisfied = deep is True or depth <= deep
@@ -1285,6 +1512,7 @@ class depgraph(object):
 
 			mypriority = dep_priority.copy()
 			if not atom.blocker:
+				root_slot = (pkg.root, pkg.slot_atom)
 				inst_pkgs = [inst_pkg for inst_pkg in vardb.match_pkgs(atom)
 					if not reinstall_atoms.findAtomForPackage(inst_pkg,
 							modified_use=self._pkg_use_enabled(inst_pkg))]
@@ -1337,11 +1565,17 @@ class depgraph(object):
 					self._dynamic_config._ignored_deps.append(dep)
 
 			if not ignored:
-				if not self._add_dep(dep,
-					allow_unsatisfied=allow_unsatisfied):
-					return 0
-				if is_virt and dep.child is not None:
-					traversed_virt_pkgs.add(dep.child)
+				if dep_priority.ignored:
+					if is_virt and dep.child is not None:
+						traversed_virt_pkgs.add(dep.child)
+					dep.child = None
+					self._dynamic_config._ignored_deps.append(dep)
+				else:
+					if not self._add_dep(dep,
+						allow_unsatisfied=allow_unsatisfied):
+						return 0
+					if is_virt and dep.child is not None:
+						traversed_virt_pkgs.add(dep.child)
 
 		selected_atoms.pop(pkg)
 
@@ -1361,8 +1595,9 @@ class depgraph(object):
 					(virt_pkg.cpv, [str(x) for x in atoms]),
 					noiselevel=-1, level=logging.DEBUG)
 
-			if not self._add_pkg(virt_pkg, virt_dep):
-				return 0
+			if not dep_priority.ignored:
+				if not self._add_pkg(virt_pkg, virt_dep):
+					return 0
 
 			for atom, child in self._minimize_children(
 				pkg, self._priority(runtime=True), root_config, atoms):
@@ -1394,7 +1629,8 @@ class depgraph(object):
 				# same depth as the virtual itself.
 				dep = Dependency(atom=atom,
 					blocker=atom.blocker, child=child, depth=virt_dep.depth,
-					parent=virt_pkg, priority=mypriority, root=dep_root)
+					parent=virt_pkg, priority=mypriority, root=dep_root,
+					collapsed_parent=pkg, collapsed_priority=dep_priority)
 
 				ignored = False
 				if not atom.blocker and \
@@ -1421,11 +1657,17 @@ class depgraph(object):
 						self._dynamic_config._ignored_deps.append(dep)
 
 				if not ignored:
-					if not self._add_dep(dep,
-						allow_unsatisfied=allow_unsatisfied):
-						return 0
-					if is_virt and dep.child is not None:
-						traversed_virt_pkgs.add(dep.child)
+					if dep_priority.ignored:
+						if is_virt and dep.child is not None:
+							traversed_virt_pkgs.add(dep.child)
+						dep.child = None
+						self._dynamic_config._ignored_deps.append(dep)
+					else:
+						if not self._add_dep(dep,
+							allow_unsatisfied=allow_unsatisfied):
+							return 0
+						if is_virt and dep.child is not None:
+							traversed_virt_pkgs.add(dep.child)
 
 		if debug:
 			writemsg_level("Exiting... %s\n" % (pkg,),
@@ -1946,9 +2188,12 @@ class depgraph(object):
 		pkgsettings = self._frozen_config.pkgsettings[myroot]
 		pprovideddict = pkgsettings.pprovideddict
 		virtuals = pkgsettings.getvirtuals()
-		for arg in self._expand_set_args(
-			self._dynamic_config._initial_arg_list,
-			add_to_digraph=True):
+		args = self._dynamic_config._initial_arg_list[:]
+		for root, atom in chain(self._rebuild.rebuild_list,
+			self._rebuild.reinstall_list):
+			args.append(AtomArg(arg=atom, atom=atom,
+				root_config=self._frozen_config.roots[root]))
+		for arg in self._expand_set_args(args, add_to_digraph=True):
 			for atom in arg.pset.getAtoms():
 				self._spinner_update()
 				dep = Dependency(atom=atom, onlydeps=onlydeps,
@@ -2063,6 +2308,10 @@ class depgraph(object):
 			#We failed if the user needs to change the configuration
 			return False, myfavorites
 
+		if self._rebuild.trigger_rebuilds():
+			self._dynamic_config._need_restart = True
+			return False, myfavorites
+
 		# We're true here unless we are missing binaries.
 		return (True, myfavorites)
 
@@ -2543,7 +2792,12 @@ class depgraph(object):
 							pkg.iuse.is_valid_flag):
 							required_use_unsatisfied.append(pkg)
 							continue
-					if pkg.built and not mreasons:
+					root_slot = (pkg.root, pkg.slot_atom)
+					if pkg.built and root_slot in self._rebuild.rebuild_list:
+						mreasons = ["need to rebuild from source"]
+					elif pkg.installed and root_slot in self._rebuild.reinstall_list:
+						mreasons = ["need to rebuild from source"]
+					elif pkg.built and not mreasons:
 						mreasons = ["use flag configuration mismatch"]
 				masked_packages.append(
 					(root_config, pkgsettings, cpv, metadata, mreasons))
@@ -3145,7 +3399,7 @@ class depgraph(object):
 		use_ebuild_visibility = self._frozen_config.myopts.get(
 			'--use-ebuild-visibility', 'n') != 'n'
 		reinstall_atoms = self._frozen_config.reinstall_atoms
-		nousepkg_atoms = self._frozen_config.nousepkg_atoms
+		usepkg_exclude = self._frozen_config.usepkg_exclude
 		useoldpkg_atoms = self._frozen_config.useoldpkg_atoms
 		matched_oldpkg = []
 		# Behavior of the "selective" parameter depends on
@@ -3181,13 +3435,19 @@ class depgraph(object):
 					if pkg in self._dynamic_config._runtime_pkg_mask:
 						# The package has been masked by the backtracking logic
 						continue
+					root_slot = (pkg.root, pkg.slot_atom)
+					if pkg.built and root_slot in self._rebuild.rebuild_list:
+						continue
+					if (pkg.installed and
+						root_slot in self._rebuild.reinstall_list):
+						continue
 
 					if not pkg.installed and \
 						self._frozen_config.excluded_pkgs.findAtomForPackage(pkg, \
 							modified_use=self._pkg_use_enabled(pkg)):
 						continue
 
-					if built and not installed and nousepkg_atoms.findAtomForPackage(pkg, \
+					if built and not installed and usepkg_exclude.findAtomForPackage(pkg, \
 						modified_use=self._pkg_use_enabled(pkg)):
 						break
 
@@ -3641,6 +3901,10 @@ class depgraph(object):
 			self._select_package = self._select_pkg_from_installed
 		else:
 			self._select_package = self._select_pkg_from_graph
+			# Make the graph as complete as possible by traversing build-time
+			# dependencies if they happen to be installed already.
+			self._dynamic_config.myparams["bdeps"] = "y"
+			self._dynamic_config._traverse_ignored_deps = True
 		already_deep = self._dynamic_config.myparams.get("deep") is True
 		if not already_deep:
 			self._dynamic_config.myparams["deep"] = True
@@ -5576,6 +5840,10 @@ class depgraph(object):
 				self._dynamic_config._needed_unstable_keywords.copy(), \
 			"runtime_pkg_mask":
 				self._dynamic_config._runtime_pkg_mask.copy(),
+			"rebuild_list":
+				self._rebuild.rebuild_list.copy(),
+			"reinstall_list":
+				self._rebuild.reinstall_list.copy(),
 			"needed_use_config_changes":
 				self._dynamic_config._needed_use_config_changes.copy(),
 			"needed_license_changes":
diff --git a/pym/_emerge/help.py b/pym/_emerge/help.py
index ffc81e9..afce96e 100644
--- a/pym/_emerge/help.py
+++ b/pym/_emerge/help.py
@@ -550,12 +550,25 @@ def help(myopts, havecolor=1):
 		print("       "+green("--nospinner"))
 		print("              Disables the spinner regardless of terminal type.")
 		print()
-		print("       " + green("--nousepkg-atoms") + " " + turquoise("ATOMS"))
+		print("       " + green("--usepkg-exclude") + " " + turquoise("ATOMS"))
 		desc = "A space separated list of package names or slot atoms." + \
 			" Emerge will ignore matching binary packages."
 		for line in wrap(desc, desc_width):
 			print(desc_indent + line)
 		print()
+		print("       " + green("--rebuild-exclude") + " " + turquoise("ATOMS"))
+		desc = "A space separated list of package names or slot atoms." + \
+			" Emerge will not rebuild matching packages due to --rebuild."
+		for line in wrap(desc, desc_width):
+			print(desc_indent + line)
+		print()
+		print("       " + green("--rebuild-ignore") + " " + turquoise("ATOMS"))
+		desc = "A space separated list of package names or slot atoms." + \
+			" Emerge will not rebuild packages that depend on matching " + \
+			" packages due to --rebuild."
+		for line in wrap(desc, desc_width):
+			print(desc_indent + line)
+		print()
 		print("       "+green("--oneshot")+" ("+green("-1")+" short option)")
 		print("              Emerge as normal, but don't add packages to the world profile.")
 		print("              This package will only be updated if it is depended upon by")
@@ -607,6 +620,31 @@ def help(myopts, havecolor=1):
 		for line in wrap(desc, desc_width):
 			print(desc_indent + line)
 		print()
+		print("       " + green("--rebuild-if-new-rev") + " [ %s | %s ]" % \
+			(turquoise("y"), turquoise("n")))
+		desc = "Rebuild packages when dependencies that are " + \
+			"used at both build-time and run-time are built, " + \
+			"if the dependency is not already installed with the " + \
+			"same version and revision."
+		for line in wrap(desc, desc_width):
+			print(desc_indent + line)
+		print()
+		print("       " + green("--rebuild-if-new-ver") + " [ %s | %s ]" % \
+			(turquoise("y"), turquoise("n")))
+		desc = "Rebuild packages when dependencies that are " + \
+			"used at both build-time and run-time are built, " + \
+			"if the dependency is not already installed with the " + \
+			"same version. Revision numbers are ignored."
+		for line in wrap(desc, desc_width):
+			print(desc_indent + line)
+		print()
+		print("       " + green("--rebuild-if-unbuilt") + " [ %s | %s ]" % \
+			(turquoise("y"), turquoise("n")))
+		desc = "Rebuild packages when dependencies that are " + \
+			"used at both build-time and run-time are built."
+		for line in wrap(desc, desc_width):
+			print(desc_indent + line)
+		print()
 		print("       " + green("--rebuilt-binaries") + " [ %s | %s ]" % \
 			(turquoise("y"), turquoise("n")))
 		desc = "Replace installed packages with binary packages that have " + \
diff --git a/pym/_emerge/main.py b/pym/_emerge/main.py
index 86824cb..37c4995 100644
--- a/pym/_emerge/main.py
+++ b/pym/_emerge/main.py
@@ -438,6 +438,9 @@ def insert_optional_args(args):
 		'--package-moves'        : y_or_n,
 		'--quiet'                : y_or_n,
 		'--quiet-build'          : y_or_n,
+		'--rebuild-if-new-rev'   : y_or_n,
+		'--rebuild-if-new-ver'   : y_or_n,
+		'--rebuild-if-unbuilt'   : y_or_n,
 		'--rebuilt-binaries'     : y_or_n,
 		'--root-deps'  : ('rdeps',),
 		'--select'               : y_or_n,
@@ -726,13 +729,29 @@ def parse_opts(tmpcmdline, silent=False):
 			"choices"  : true_y_or_n
 		},
 
-		"--nousepkg-atoms": {
+		"--usepkg-exclude": {
 			"help"   :"A space separated list of package names or slot atoms. " + \
 				"Emerge will ignore matching binary packages. ",
 
 			"action" : "append",
 		},
 
+		"--rebuild-exclude": {
+			"help"   :"A space separated list of package names or slot atoms. " + \
+				"Emerge will not rebuild these packages due to the " + \
+				"--rebuild flag. ",
+
+			"action" : "append",
+		},
+
+		"--rebuild-ignore": {
+			"help"   :"A space separated list of package names or slot atoms. " + \
+				"Emerge will not rebuild packages that depend on matching " + \
+				"packages due to the --rebuild flag. ",
+
+			"action" : "append",
+		},
+
 		"--package-moves": {
 			"help"     : "perform package moves when necessary",
 			"type"     : "choice",
@@ -752,6 +771,31 @@ def parse_opts(tmpcmdline, silent=False):
 			"choices"  : true_y_or_n
 		},
 
+		"--rebuild-if-new-rev": {
+			"help"     : "Rebuild packages when dependencies that are " + \
+				"used at both build-time and run-time are built, " + \
+				"if the dependency is not already installed with the " + \
+				"same version and revision.",
+			"type"     : "choice",
+			"choices"  : true_y_or_n
+		},
+
+		"--rebuild-if-new-ver": {
+			"help"     : "Rebuild packages when dependencies that are " + \
+				"used at both build-time and run-time are built, " + \
+				"if the dependency is not already installed with the " + \
+				"same version. Revision numbers are ignored.",
+			"type"     : "choice",
+			"choices"  : true_y_or_n
+		},
+
+		"--rebuild-if-unbuilt": {
+			"help"     : "Rebuild packages when dependencies that are " + \
+				"used at both build-time and run-time are built.",
+			"type"     : "choice",
+			"choices"  : true_y_or_n
+		},
+
 		"--rebuilt-binaries": {
 			"help"     : "replace installed packages with binary " + \
 			             "packages that have been rebuilt",
@@ -902,10 +946,22 @@ def parse_opts(tmpcmdline, silent=False):
 			parser.error("Invalid Atom(s) in --reinstall-atoms parameter: '%s' (only package names and slot atoms (with wildcards) allowed)\n" % \
 				(",".join(bad_atoms),))
 
-	if myoptions.nousepkg_atoms:
-		bad_atoms = _find_bad_atoms(myoptions.nousepkg_atoms)
+	if myoptions.rebuild_exclude:
+		bad_atoms = _find_bad_atoms(myoptions.rebuild_exclude)
 		if bad_atoms and not silent:
-			parser.error("Invalid Atom(s) in --nousepkg-atoms parameter: '%s' (only package names and slot atoms (with wildcards) allowed)\n" % \
+			parser.error("Invalid Atom(s) in --rebuild-exclude parameter: '%s' (only package names and slot atoms (with wildcards) allowed)\n" % \
+				(",".join(bad_atoms),))
+
+	if myoptions.rebuild_ignore:
+		bad_atoms = _find_bad_atoms(myoptions.rebuild_ignore)
+		if bad_atoms and not silent:
+			parser.error("Invalid Atom(s) in --rebuild-ignore parameter: '%s' (only package names and slot atoms (with wildcards) allowed)\n" % \
+				(",".join(bad_atoms),))
+
+	if myoptions.usepkg_exclude:
+		bad_atoms = _find_bad_atoms(myoptions.usepkg_exclude)
+		if bad_atoms and not silent:
+			parser.error("Invalid Atom(s) in --usepkg-exclude parameter: '%s' (only package names and slot atoms (with wildcards) allowed)\n" % \
 				(",".join(bad_atoms),))
 
 	if myoptions.useoldpkg_atoms:
@@ -945,6 +1001,24 @@ def parse_opts(tmpcmdline, silent=False):
 	else:
 		myoptions.quiet_build = None
 
+	if myoptions.rebuild_if_new_ver in true_y:
+		myoptions.rebuild_if_new_ver = True
+	else:
+		myoptions.rebuild_if_new_ver = None
+
+	if myoptions.rebuild_if_new_rev in true_y:
+		myoptions.rebuild_if_new_rev = True
+		myoptions.rebuild_if_new_ver = None
+	else:
+		myoptions.rebuild_if_new_rev = None
+
+	if myoptions.rebuild_if_unbuilt in true_y:
+		myoptions.rebuild_if_unbuilt = True
+		myoptions.rebuild_if_new_rev = None
+		myoptions.rebuild_if_new_ver = None
+	else:
+		myoptions.rebuild_if_unbuilt = None
+
 	if myoptions.rebuilt_binaries in true_y:
 		myoptions.rebuilt_binaries = True
 
diff --git a/pym/portage/dbapi/bintree.py b/pym/portage/dbapi/bintree.py
index 29c8783..66fd172 100644
--- a/pym/portage/dbapi/bintree.py
+++ b/pym/portage/dbapi/bintree.py
@@ -228,6 +228,7 @@ class binarytree(object):
 			self.invalids = []
 			self.settings = settings
 			self._pkg_paths = {}
+			self._pkgindex_uri = {}
 			self._populating = False
 			self._all_directory = os.path.isdir(
 				os.path.join(self.pkgdir, "All"))
@@ -874,8 +875,9 @@ class binarytree(object):
 				# Organize remote package list as a cpv -> metadata map.
 				remotepkgs = _pkgindex_cpv_map_latest_build(pkgindex)
 				remote_base_uri = pkgindex.header.get("URI", base_url)
-				for remote_metadata in remotepkgs.values():
+				for cpv, remote_metadata in remotepkgs.items():
 					remote_metadata["BASE_URI"] = remote_base_uri
+					self._pkgindex_uri[cpv] = url
 				self._remotepkgs.update(remotepkgs)
 				self._remote_has_index = True
 				for cpv in remotepkgs:
@@ -1225,6 +1227,10 @@ class binarytree(object):
 		# package is downloaded, state is updated by self.inject().
 		return True
 
+	def get_pkgindex_uri(self, pkgname):
+		"""Returns the URI to the Packages file for a given package."""
+		return self._pkgindex_uri.get(pkgname)
+
 	def gettbz2(self, pkgname):
 		"""Fetches the package from a remote site, if necessary.  Attempts to
 		resume if the file appears to be partially downloaded."""
diff --git a/pym/portage/tests/resolver/test_rebuild.py b/pym/portage/tests/resolver/test_rebuild.py
new file mode 100644
index 0000000..70630fb
--- /dev/null
+++ b/pym/portage/tests/resolver/test_rebuild.py
@@ -0,0 +1,135 @@
+from portage.tests import TestCase
+from portage.tests.resolver.ResolverPlayground import (ResolverPlayground,
+	ResolverPlaygroundTestCase)
+
+class RebuildTestCase(TestCase):
+
+	def testRebuild(self):
+		"""
+		Rebuild packages when dependencies that are used at both build-time and
+		run-time are upgraded.
+		"""
+
+		ebuilds = {
+			"sys-libs/x-1": { },
+			"sys-libs/x-1-r1": { },
+			"sys-libs/x-2": { },
+			"sys-apps/a-1": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/a-2": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/b-1": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/b-2": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/c-1": { "DEPEND"  : "sys-libs/x", "RDEPEND" : ""},
+			"sys-apps/c-2": { "DEPEND"  : "sys-libs/x", "RDEPEND" : ""},
+			"sys-apps/d-1": { "RDEPEND" : "sys-libs/x"},
+			"sys-apps/d-2": { "RDEPEND" : "sys-libs/x"},
+			"sys-apps/e-2": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/f-2": { "DEPEND"  : "sys-apps/a", "RDEPEND" : "sys-apps/a"},
+			"sys-apps/g-2": { "DEPEND"  : "sys-apps/b sys-libs/x",
+				"RDEPEND" : "sys-apps/b"},
+			}
+
+		installed = {
+			"sys-libs/x-1": { },
+			"sys-apps/a-1": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/b-1": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/c-1": { "DEPEND"  : "sys-libs/x", "RDEPEND" : ""},
+			"sys-apps/d-1": { "RDEPEND" : "sys-libs/x"},
+			"sys-apps/e-1": { "DEPEND"  : "sys-libs/x", "RDEPEND" : "sys-libs/x"},
+			"sys-apps/f-1": { "DEPEND"  : "sys-apps/a", "RDEPEND" : "sys-apps/a"},
+			"sys-apps/g-1": { "DEPEND"  : "sys-apps/b sys-libs/x",
+				"RDEPEND" : "sys-apps/b"},
+			}
+
+		world = ["sys-apps/a", "sys-apps/b", "sys-apps/c", "sys-apps/d",
+			"sys-apps/e", "sys-apps/f", "sys-apps/g"]
+
+		test_cases = (
+				ResolverPlaygroundTestCase(
+					["sys-libs/x"],
+					options = {"--rebuild-if-unbuilt" : True,
+						"--rebuild-exclude" : ["sys-apps/b"]},
+					mergelist = ['sys-libs/x-2', 'sys-apps/a-2', 'sys-apps/e-2'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["sys-libs/x"],
+					options = {"--rebuild-if-unbuilt" : True},
+					mergelist = ['sys-libs/x-2', 'sys-apps/a-2', 'sys-apps/b-2',
+						'sys-apps/e-2', 'sys-apps/g-2'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["sys-libs/x"],
+					options = {"--rebuild-if-unbuilt" : True,
+						"--rebuild-ignore" : ["sys-libs/x"]},
+					mergelist = ['sys-libs/x-2'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["sys-libs/x"],
+					options = {"--rebuild-if-unbuilt" : True,
+						"--rebuild-ignore" : ["sys-apps/b"]},
+					mergelist = ['sys-libs/x-2', 'sys-apps/a-2', 'sys-apps/b-2',
+						'sys-apps/e-2'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["=sys-libs/x-1-r1"],
+					options = {"--rebuild-if-unbuilt" : True},
+					mergelist = ['sys-libs/x-1-r1', 'sys-apps/a-2',
+						'sys-apps/b-2', 'sys-apps/e-2', 'sys-apps/g-2'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["=sys-libs/x-1-r1"],
+					options = {"--rebuild-if-new-rev" : True},
+					mergelist = ['sys-libs/x-1-r1', 'sys-apps/a-2',
+						'sys-apps/b-2', 'sys-apps/e-2', 'sys-apps/g-2'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["=sys-libs/x-1-r1"],
+					options = {"--rebuild-if-new-ver" : True},
+					mergelist = ['sys-libs/x-1-r1'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["sys-libs/x"],
+					options = {"--rebuild-if-new-ver" : True},
+					mergelist = ['sys-libs/x-2', 'sys-apps/a-2',
+						'sys-apps/b-2', 'sys-apps/e-2', 'sys-apps/g-2'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["=sys-libs/x-1"],
+					options = {"--rebuild-if-new-rev" : True},
+					mergelist = ['sys-libs/x-1'],
+					ignore_mergelist_order = True,
+					success = True),
+
+				ResolverPlaygroundTestCase(
+					["=sys-libs/x-1"],
+					options = {"--rebuild-if-unbuilt" : True},
+					mergelist = ['sys-libs/x-1', 'sys-apps/a-2',
+						'sys-apps/b-2', 'sys-apps/e-2', 'sys-apps/g-2'],
+					ignore_mergelist_order = True,
+					success = True),
+			)
+
+		playground = ResolverPlayground(ebuilds=ebuilds,
+			installed=installed, world=world)
+
+		try:
+			for test_case in test_cases:
+				playground.run_TestCase(test_case)
+				self.assertEqual(test_case.test_success, True, test_case.fail_msg)
+		finally:
+			playground.cleanup()
