From 1c1c1f15d776ef5feb016304ce378123991ee03f Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Thu, 7 Jul 2011 11:51:29 -0700
Subject: [PATCH 11/11] Add --default option to dtget, to handle missing properties


Signed-off-by: Simon Glass <sjg@chromium.org>
---
 dtget.c                |   44 ++++++++++++++++++++++++++++++--------------
 tests/dtget-runtest.sh |    7 ++++++-
 tests/run_tests.sh     |    4 ++++
 utilfdt.c              |   30 ++++++++++++++++++++++++++----
 4 files changed, 66 insertions(+), 19 deletions(-)

diff --git a/dtget.c b/dtget.c
index 0bf6e46..13e4eca 100644
--- a/dtget.c
+++ b/dtget.c
@@ -133,10 +133,12 @@ static int list_children(const void *blob, int node)
 }
 
 static int show_data_for_key(const void *blob, const char *format, int type,
-			     int list, int properties, char *key)
+			     int list, int properties, const char *default_val,
+			     char *key)
 {
 	char *prop;
 	int node, guess_node = 0;
+	int any_node;	/* interpret the key as not containing a property */
 	const void *value;
 	int len;
 
@@ -146,27 +148,33 @@ static int show_data_for_key(const void *blob, const char *format, int type,
 		return 7;
 	}
 	value = fdt_getprop(blob, node, prop, &len);
+	any_node = guess_node ? guess_node : node;
 	if (value) {
 		show_data(format, type, value, len);
 		printf("\n");
-	} else if (properties) {
-		list_properties(blob, node);
-	} else if (list) {
-		if (guess_node)
-			node = guess_node;
-		list_children(blob, node);
+	} else if (any_node >= 0 && properties) {
+		list_properties(blob, any_node);
+	} else if (any_node >= 0 && list) {
+		list_children(blob, any_node);
+	} else if (default_val) {
+		puts(default_val);
 	} else {
 		report_error(prop, len);
-		if (guess_node)
+		if (guess_node) {
+			const char *name = fdt_get_name(blob, guess_node, NULL);
+
 			fprintf(stderr, "(Node %s exists but you didn't "
-				"specify a property to print)\n", key);
+				"specify a property to print)\n",
+				name ? name : "/");
+		}
 		return 8;
 	}
 	return 0;
 }
 
 static int do_dtget(const char *filename, const char *format, int type,
-		    int list, int properties, char **key, int key_count)
+		    int list, int properties, const char *default_val,
+		    char **key, int key_count)
 {
 	char *blob;
 	int i, ret;
@@ -177,7 +185,7 @@ static int do_dtget(const char *filename, const char *format, int type,
 
 	for (i = 0; i < key_count; i++) {
 		ret = show_data_for_key(blob, format, type, list,
-					properties, key[i]);
+					properties, default_val, key[i]);
 		if (ret)
 			return ret;
 	}
@@ -197,6 +205,8 @@ static void usage(const char *msg)
 		"(s), int(i) or byte(b)\n");
 	fprintf(stderr, "\t-l, --list\t\tList children of a node\n");
 	fprintf(stderr, "\t-p, --properties\t\tList properties in a node\n");
+	fprintf(stderr, "\t-d, --default\t\tDefault value to display when "
+		"the property is missing\n");
 	fprintf(stderr, "\t-h, --help\t\tPrint this help\n\n");
 	fprintf(stderr, "\t<key> is <node>/<property>, for example "
 		"/lcd/width for the width\n");
@@ -211,17 +221,19 @@ int main(int argc, char *argv[])
 	char *format = NULL;
 	int type = 0, list = 0, properties = 0;
 	char *filename = NULL;
+	char *default_val = NULL;
 	static struct option long_options[] = {
 		{"format", 1, 0, 'f'},
 		{"help", 1, 0, 'h'},
 		{"type", 1, 0, 't'},
 		{"list", 1, 0, 'l'},
 		{"properties", 1, 0, 'p'},
+		{"default", 1, 0, 'd'},
 		{0, 0, 0, 0}
 	};
 
 	for (;;) {
-		c = getopt_long(argc, argv, "f:ht:lp", long_options, NULL);
+		c = getopt_long(argc, argv, "f:ht:lpd:", long_options, NULL);
 		if (c == -1)
 			break;
 
@@ -245,6 +257,10 @@ int main(int argc, char *argv[])
 		case 'p':
 			properties = 1;
 			break;
+
+		case 'd':
+			default_val = optarg;
+			break;
 		}
 	}
 
@@ -255,7 +271,7 @@ int main(int argc, char *argv[])
 	if (optind == argc)
 		usage("Missing key(s)");
 
-	ret = do_dtget(filename, format, type, list, properties, argv + optind,
-		       argc - optind);
+	ret = do_dtget(filename, format, type, list, properties, default_val,
+		       argv + optind, argc - optind);
 	return ret;
 }
diff --git a/tests/dtget-runtest.sh b/tests/dtget-runtest.sh
index aa2b744..9d6621e 100755
--- a/tests/dtget-runtest.sh
+++ b/tests/dtget-runtest.sh
@@ -7,12 +7,17 @@ EXPECT="tmp.expect.$$"
 
 rm -f $TMPFILE $LOG
 
-echo "$1" >$EXPECT
+expect="$1"
+echo "$expect" >$EXPECT
 shift
 
 verbose_run_log "$LOG" $VALGRIND "$DTGET" "$@"
 ret="$?"
 
+if [ "$expect" = "ERR" ]; then
+	PASS
+fi
+
 if [ "$ret" -gt 127 ]; then
     signame=$(kill -l $[ret - 128])
     FAIL "Killed by SIG$signame"
diff --git a/tests/run_tests.sh b/tests/run_tests.sh
index 71cfab3..d0d0b54 100755
--- a/tests/run_tests.sh
+++ b/tests/run_tests.sh
@@ -428,6 +428,10 @@ dtget_tests () {
 	$file "/randomnode/blob"
     run_dtget_test "Integer list short" "a0b0c0d deeaadbe ef000000" -f %x \
 	-t i $file "/randomnode/blob"
+    run_dtget_test "Missing property" ERR -f %x \
+	-t i $file "/randomnode/doctor-who"
+    run_dtget_test "Missing property default" "<the dead silence>" -f %x \
+	-t i -d "<the dead silence>" $file "/randomnode/doctor-who"
 }
 
 dtput_tests () {
diff --git a/utilfdt.c b/utilfdt.c
index 3cbd566..7ed71b2 100644
--- a/utilfdt.c
+++ b/utilfdt.c
@@ -87,6 +87,29 @@ int util_write_fdt(const char *buf, const char *filename)
 	return 0;
 }
 
+/*
+ * Decode a key into its node and property name
+ *
+ * The key looks like this:
+ *
+ *	/path/to/node/property
+ *
+ * We decode the /path/to/node and return that value, then return a pointer to
+ * the property name.
+ *
+ * Sometimes there is a valid node but no property is specified. In that case
+ * we set guess_node to the valid node that we found, even though we return
+ * an error. This might help the caller produce a sensible error message.
+ *
+ * This function does not check whether the property exists in the node or not.
+ *
+ * \param blob		fd blob
+ * \param key		key string
+ * \param prop		returns pointer to property, if no error
+ * \param guess_node	returns node found by including the property in the
+ *			node name, or < 0 if none
+ * \return node offset if found (and *prop set up), <0 on error
+ */
 int util_decode_key(const char *blob, char *key, char **prop, int *guess_node)
 {
 	int node;
@@ -100,10 +123,9 @@ int util_decode_key(const char *blob, char *key, char **prop, int *guess_node)
 		return -FDT_ERR_NOTFOUND;
 	}
 
-	if (ptr == key) {
-		*guess_node = fdt_path_offset(blob, key);
-		node = fdt_path_offset(blob, "/");
-	} else {
+	*guess_node = fdt_path_offset(blob, key);
+	node = 0;
+	if (ptr != key) {
 		*ptr = '\0';
 		node = fdt_path_offset(blob, key);
 		*ptr = '/';
-- 
1.7.3.1

