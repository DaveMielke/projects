From a6167d6c8dd3afc8554e3dd0cbcff4f4f71ee82f Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Wed, 6 Jul 2011 21:13:22 -0700
Subject: [PATCH 10/11] Add --list and --properties to list children and properties


Signed-off-by: Simon Glass <sjg@chromium.org>
---
 dtget.c |  113 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 files changed, 104 insertions(+), 9 deletions(-)

diff --git a/dtget.c b/dtget.c
index cbcd4d2..0bf6e46 100644
--- a/dtget.c
+++ b/dtget.c
@@ -4,6 +4,12 @@
  *
  * is_printable_string from ftdump.c
  * Contributed by Pantelis Antoniou <pantelis.antoniou AT gmail.com>
+ *
+ * Portions from U-Boot cmd_fdt.c (C) Copyright 2007
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ * Based on code written by:
+ *   Pantelis Antoniou <pantelis.antoniou@gmail.com> and
+ *   Matthew McClintock <msm@freescale.com>
  */
 
 #include <stdio.h>
@@ -58,8 +64,76 @@ static void show_data(const char *format, int type, const char *data, int len)
 	}
 }
 
+/* List all properties in a node, one per line */
+static int list_properties(const void *blob, int node)
+{
+	const struct fdt_property *data;
+	const char *name;
+	int prop;
+
+	prop = fdt_first_property_offset(blob, node);
+	do {
+		if (prop < 0)
+			return prop == -FDT_ERR_NOTFOUND ? 0 : prop;
+		data = fdt_get_property_by_offset(blob, prop, NULL);
+		name = fdt_string(blob, fdt32_to_cpu(data->nameoff));
+		if (name)
+			puts(name);
+		prop = fdt_next_property_offset(blob, prop);
+	} while (1);
+}
+
+#define MAX_LEVEL	32		/* how deeply nested we will go */
+
+/* List all children in a node, one per line */
+static int list_children(const void *blob, int node)
+{
+	int  nextoffset;	/* next node offset from libfdt */
+	uint32_t tag;		/* tag */
+	int  level = 0;		/* keep track of nesting level */
+	const char *pathp;
+	int depth = 1;
+
+	while (level >= 0) {
+		tag = fdt_next_tag(blob, node, &nextoffset);
+		switch (tag) {
+		case FDT_BEGIN_NODE:
+			pathp = fdt_get_name(blob, node, NULL);
+			if (level <= depth) {
+				if (pathp == NULL)
+					pathp = "/* NULL pointer error */";
+				if (*pathp == '\0')
+					pathp = "/";	/* root is nameless */
+				if (level == 1)
+					puts(pathp);
+			}
+			level++;
+			if (level >= MAX_LEVEL) {
+				printf("Nested too deep, aborting.\n");
+				return 1;
+			}
+			break;
+		case FDT_END_NODE:
+			level--;
+			if (level == 0)
+				level = -1;		/* exit the loop */
+			break;
+		case FDT_END:
+			return 1;
+		case FDT_PROP:
+			break;
+		default:
+			if (level <= depth)
+				printf("Unknown tag 0x%08X\n", tag);
+			return 1;
+		}
+		node = nextoffset;
+	}
+	return 0;
+}
+
 static int show_data_for_key(const void *blob, const char *format, int type,
-			     char *key)
+			     int list, int properties, char *key)
 {
 	char *prop;
 	int node, guess_node = 0;
@@ -72,20 +146,27 @@ static int show_data_for_key(const void *blob, const char *format, int type,
 		return 7;
 	}
 	value = fdt_getprop(blob, node, prop, &len);
-	if (!value) {
+	if (value) {
+		show_data(format, type, value, len);
+		printf("\n");
+	} else if (properties) {
+		list_properties(blob, node);
+	} else if (list) {
+		if (guess_node)
+			node = guess_node;
+		list_children(blob, node);
+	} else {
 		report_error(prop, len);
 		if (guess_node)
 			fprintf(stderr, "(Node %s exists but you didn't "
 				"specify a property to print)\n", key);
 		return 8;
 	}
-	show_data(format, type, value, len);
-	printf("\n");
 	return 0;
 }
 
 static int do_dtget(const char *filename, const char *format, int type,
-		    char **key, int key_count)
+		    int list, int properties, char **key, int key_count)
 {
 	char *blob;
 	int i, ret;
@@ -95,7 +176,8 @@ static int do_dtget(const char *filename, const char *format, int type,
 		return 10;
 
 	for (i = 0; i < key_count; i++) {
-		ret = show_data_for_key(blob, format, type, key[i]);
+		ret = show_data_for_key(blob, format, type, list,
+					properties, key[i]);
 		if (ret)
 			return ret;
 	}
@@ -113,6 +195,8 @@ static void usage(const char *msg)
 		"for value\n");
 	fprintf(stderr, "\t-t, --type <typechar>\tForce type to be string "
 		"(s), int(i) or byte(b)\n");
+	fprintf(stderr, "\t-l, --list\t\tList children of a node\n");
+	fprintf(stderr, "\t-p, --properties\t\tList properties in a node\n");
 	fprintf(stderr, "\t-h, --help\t\tPrint this help\n\n");
 	fprintf(stderr, "\t<key> is <node>/<property>, for example "
 		"/lcd/width for the width\n");
@@ -125,17 +209,19 @@ int main(int argc, char *argv[])
 	int c;
 	int ret;
 	char *format = NULL;
-	int type = 0;
+	int type = 0, list = 0, properties = 0;
 	char *filename = NULL;
 	static struct option long_options[] = {
 		{"format", 1, 0, 'f'},
 		{"help", 1, 0, 'h'},
 		{"type", 1, 0, 't'},
+		{"list", 1, 0, 'l'},
+		{"properties", 1, 0, 'p'},
 		{0, 0, 0, 0}
 	};
 
 	for (;;) {
-		c = getopt_long(argc, argv, "f:ht:", long_options, NULL);
+		c = getopt_long(argc, argv, "f:ht:lp", long_options, NULL);
 		if (c == -1)
 			break;
 
@@ -151,6 +237,14 @@ int main(int argc, char *argv[])
 		case 't':
 			type = *optarg;
 			break;
+
+		case 'l':
+			list = 1;
+			break;
+
+		case 'p':
+			properties = 1;
+			break;
 		}
 	}
 
@@ -161,6 +255,7 @@ int main(int argc, char *argv[])
 	if (optind == argc)
 		usage("Missing key(s)");
 
-	ret = do_dtget(filename, format, type, argv + optind, argc - optind);
+	ret = do_dtget(filename, format, type, list, properties, argv + optind,
+		       argc - optind);
 	return ret;
 }
-- 
1.7.3.1

