#!/bin/bash
. ../brltty/git/main/brltty-prologue.bash
shopt -s extglob

addProgramOption k string.key owmKeyValue "the key for the application performing the query" "the first line in the key file"
addProgramOption K string.path owmKeyFile "the file containing the application key"

owmSetKey() {
   local parametersArray="${1}"

   [ -n "${owmKeyValue}" ] || {
      if [ -n "${owmKeyFile}" ]
      then
         verifyInputFile "${owmKeyFile}"
      elif ! findProgramConfigurationFile owmKeyFile "key"
      then
         semanticError "no API key file"
      fi

      read <"${owmKeyFile}" owmKeyValue
   }

   [ -n "${owmKeyValue}" ] || semanticError "API key not specified"
   setElement "${parametersArray}" "appid" "${owmKeyValue}"
}

owmAddQueryParameter() {
   local name="${1}"
   local value="${2}"
   curlOptions+=(--data-urlencode "${name}=${value}")
}

owmQuery() {
   local resultArray="${1}"
   local parametersArray="${2}"
   shift 2

   local curlOptions=(--silent --show-error --get)
   local curlLocation="https://api.OpenWeatherMap.org"

   local -A owmParameters=()
   getElements owmParameters "${parametersArray}"
   owmSetKey owmParameters
   forElements owmParameters owmAddQueryParameter

   local owmComponent
   for owmComponent in "${@}"
   do
      curlLocation+="/${owmComponent}"
   done

   local owmResponse
   owmResponse="$(curl "${curlOptions[@]}" -- "${curlLocation}")" || exit "${?}"

   local owmMessage
   owmMessage="$(jq -r '.message?' <<<"${owmResponse}")"
   [ "${owmMessage}" = "null" ] && owmMessage=""
   [ "${owmMessage}" = "0" ] && owmMessage=""
   [ -n "${owmMessage}" ] && semanticError "${owmMessage}"

   local owmName="${programName}.${1}-${3}"
   "${saveResponses}" && jq . <<<"${owmResponse}" >"${owmName}.json"

   local jqScript="${programDirectory}/${owmName}.jq"
   local jqOptions=(--raw-output --from-file "${jqScript}")

   local jqResponse
   jqResponse="$(jq "${jqOptions[@]}" <<<"${owmResponse}")" || exit "${?}"

   local name value
   while read name value
   do
      [ "${value}" = "null" ] && value=""
      setElement "${resultArray}" "${name}" "${value}"
   done <<<"${jqResponse}"
}

owmQueryCity() {
   local citiesArray="${1}"
   local city="${2}"

   local -A parameters=(
      q "${city}"
      limit 5
   )

   owmQuery "${citiesArray}" parameters geo 1.0 direct
}

owmQueryLocation() {
   local locationsArray="${1}"
   local latitude="${2}"
   local longitude="${3}"

   local -A parameters=(
      lat "${latitude}"
      lon "${longitude}"
      limit 5
   )

   owmQuery "${locationsArray}" parameters geo 1.0 reverse
}

owmQueryForecast() {
   local forecastArray="${1}"
   local latitude="${2}"
   local longitude="${3}"

   local -A parameters=(
      lat "${latitude}"
      lon "${longitude}"
      units metric
   )

   owmQuery "${forecastArray}" parameters data 2.5 forecast
}

owmQueryWeather() {
   local WeatherArray="${1}"
   local latitude="${2}"
   local longitude="${3}"

   local -A parameters=(
      lat "${latitude}"
      lon "${longitude}"
      units metric
   )

   owmQuery "${WeatherArray}" parameters data 2.5 weather
}

declare -a queryArguments=()

processExtraProgramParameters() {
   queryArguments=("${@}")
}

showProgramUsageNotes() {
cat <<END_OF_PROGRAM_USAGE_NOTES

Queries:
  city [name]
  location [latitude longitude]
  forecast [latitude longitude]
  weather [latitude longitude]

The -c option may be used to specify a city in lieu of its identifying arguments.
A city is specified as name[[,state],country] - the name may be abbreviated.
The optional two-letter ISO 3166 country code must be last.
The optional two-letter state code only applies to the United States.
END_OF_PROGRAM_USAGE_NOTES
}

noMoreQueryArguments() {
   [ "${#queryArguments[*]}" -eq 0 ] || syntaxError "too many ${queryType} arguments"
}

getQueryArgument() {
   local resultVariable="${1}"
   local label="${2}"

   set -- "${queryArguments[@]}"
   [ "${#}" -gt 0 ] || syntaxError "${label} not specified"
   setVariable "${resultVariable}" "${1}"
   shift 1
   queryArguments=("${@}")
}

getCityName() {
   local nameVariable="${1}"
   local citiesArray="${2}"
   local index="${3}"

   local name=""
   local field

   for field in name region country
   do
      local value
      getElement value "${citiesArray}" "${index},${field}"
      [ -n "${value}" ] || continue

      [  -n "${name}" ] && name+=", "
      name+="${value}"
   done

   setVariable "${nameVariable}" "${name}"
}

getCityCoordinates() {
   local latitudeVariable="${1}"
   local longitudeVariable="${2}"
   local city="${3}"

   local -A cities=()
   owmQueryCity cities "${city}"
   local cityCount="${cities["count"]}"

   if [ "${cityCount}" -eq 1 ]
   then
      local cityName
      getCityName cityName cities 0

      local cityLatitude="${cities["0,latitude"]}"
      [ -n "${cityLatitude}" ] || semanticError "city latitude not known: ${cityName}"
      setVariable "${latitudeVariable}" "${cityLatitude}"

      local cityLongitude="${cities["0,longitude"]}"
      [ -n "${cityLongitude}" ] || semanticError "city longitude not known: ${cityName}"
      setVariable "${longitudeVariable}" "${cityLongitude}"
   elif [ "${cityCount}" -eq 0 ]
   then
      semanticError "city not found: ${city}"
   else
      local cityNames=""
      local cityIndex=0

      while [ "${cityIndex}" -lt "${cityCount}" ]
      do
         local cityName
         getCityName cityName cities "${cityIndex}"

         [ -n "${cityNames}" ] && cityNames+="; "
         cityNames+="${cityName}"

         let "cityIndex += 1"
      done

      semanticError "more than one city: ${cityNames}"
   fi
}

testCoordinateSpecification() {
   local valueVariable="${1}"
   local maximumValue="${2}"
   local positiveSuffix="${3}"
   local negativeSuffix="${4}"

   local value="${!valueVariable}"
   local pattern='^([-+])?(0|[1-9][0-9]*)?(\.[0-9]+)?([A-Za-z])?$'

   [[ "${value}" =~ ${pattern} ]] || return 1
   local sign="${BASH_REMATCH[1]}"
   local integer="${BASH_REMATCH[2]}"
   local fraction="${BASH_REMATCH[3]}"
   local suffix="${BASH_REMATCH[4]}"

   if [ "${integer}" -eq "${maximumValue}" ]
   then
      fraction="${fraction##.*(0)}"
      [ -n "${fraction}" ] && return 1
   elif [ "${integer}" -gt "${maximumValue}" ]
   then
      return 1
   fi

   local negativeSign=false
   [ "${sign}" = "-" ] && negativeSign=true

   [ -n "${suffix}" ] && {
      if [ "${suffix}" = "${negativeSuffix}" ]
      then
         "${negativeSign}" && negativeSign=false || negativeSign=true
      elif [ "${suffix}" != "${positiveSuffix}" ]
      then
         return 1
      fi
   }

   value="${integer:-0}${fraction}"
   "${negativeSign}" && value="-${value}"
   setVariable "${valueVariable}" "${value}"
   return 0
}

getCoordinateArgument() {
   local resultVariable="${1}"
   local label="${2}"
   local maximumValue="${3}"
   local positiveSuffix="${4}"
   local negativeSuffix="${5}"

   local coordinate
   getQueryArgument coordinate "${label}"

   testCoordinateSpecification coordinate "${maximumValue}" "${positiveSuffix}" "${negativeSuffix}" || {
      syntaxError "invalid ${label}: ${coordinate}"
   }

   setVariable "${resultVariable}" "${coordinate}"
}

getLatitudeArgument() {
   getCoordinateArgument "${1}" latitude 90 N S
}

getLongitudeArgument() {
   getCoordinateArgument "${1}" longitude 180 E W
}

getCoordinatesArguments() {
   local latitudeVariable="${1}"
   local longitudeVariable="${2}"

   if [ -n "${cityDescriptor}" ]
   then
      getCityCoordinates "${latitudeVariable}" "${longitudeVariable}" "${cityDescriptor}"
   else
      getLatitudeArgument "${latitudeVariable}"
      getLongitudeArgument "${longitudeVariable}"
   fi
}

showCities() {
   local citiesArray="${1}"
   local cityIdentifier="${2}"

   local cityCount
   getElement cityCount "${citiesArray}" "count"

   [ "${cityCount}" -gt 0 ] || semanticError "city not found: ${cityIdentifier}"
   local cityIndex=0

   while [ "${cityIndex}" -lt "${cityCount}" ]
   do
      local cityName
      getCityName cityName "${citiesArray}" "${cityIndex}"

      local cityLatitude
      getElement cityLatitude "${citiesArray}" "${cityIndex},latitude"

      local cityLongitude
      getElement cityLongitude "${citiesArray}" "${cityIndex},longitude"

      echo "${cityName}: ${cityLatitude} ${cityLongitude}"
      let "cityIndex += 1"
   done
}

performQuery_city() {
   [ -n "${cityDescriptor}" ] || getQueryArgument cityDescriptor "city"
   noMoreQueryArguments

   local -A cities=()
   owmQueryCity cities "${cityDescriptor}"
   showCities cities "${cityDescriptor}"
}

performQuery_location() {
   local latitude longitude
   getCoordinatesArguments latitude longitude
   noMoreQueryArguments

   local -A locations=()
   owmQueryLocation locations "${latitude}" "${longitude}"
   showCities locations "[${latitude}, ${longitude}]"
}

showLines() {
   local text="" line

   for line
   do
      text+="${line}"
      text+=$'\n'
   done

   echo -n "${text}"
}

showWeather() {
   local weatherArray="${1}"

   local timeFormat="%H:%M on %A, %B %d"
   local windDirections=(N NNE NE ENE E ESE SE SSE S SSW SW WSW W WNW NW NNW)
   local lines=() line

   local time offset
   getElement time "${weatherArray}" "time"
   getElement offset "${weatherArray}" "time,offset"
   printf -v line "as of %(${timeFormat})T" "${time}"
   lines+=("${line}")

   local name description general
   getElement name "${weatherArray}" "name"
   getElement description "${weatherArray}" "weather,description"
   getElement general "${weatherArray}" "weather,general"
   [ -n "${description}" ] || description="${general}"
   printf -v line "%s: %s" "${name}" "${description}"
   lines+=("${line}")

   local temperature feelsLike
   getElement temperature "${weatherArray}" "temperature"
   getElement feelsLike "${weatherArray}" "temperature,feels"
   temperature="${temperature%.*}"
   feelsLike="${feelsLike%.*}"
   line="temperature is ${temperature}C"
   [ "${feelsLike}" = "${temperature}" ] || line+=" (feels like ${feelsLike}C)"
   lines+=("${line}")

   local speed angle
   getElement speed "${weatherArray}" "wind,speed"
   getElement angle "${weatherArray}" "wind,direction"
   local direction=$(( ((((angle * 4) + 45) % 1440) / 90) ))
   direction="${windDirections[direction]}"
   printf -v line "wind is %dM/s from the %s (%d°)" "${speed%.*}" "${direction}" "${angle}"
   lines+=("${line}")

   local humidity pressure
   getElement humidity "${weatherArray}" "humidity"
   getElement pressure "${weatherArray}" "pressure"
   printf -v line "%d%% humidity, pressure is %dhPa" "${humidity}" "${pressure}"
   lines+=("${line}")

   local clouds visibility
   getElement clouds "${weatherArray}" "clouds,percent"
   getElement visibility "${weatherArray}" "visibility"
   line="${clouds}% clouds, "

   if [ "${visibility}" -lt 10000 ]
   then
      local unit="M"

      [ "${visibility}" -lt 1000 ] || {
         unit="K${unit}"
         local fraction="${visibility: -3:1}"
         let "visibility /= 1000"
         visibility+=".${fraction}"
      }

      line+="${visibility}${unit} visibility"
   else
      line+="clear"
   fi

   lines+=("${line}")
   showLines "${lines[@]}"
}

performQuery_forecast() {
   local latitude longitude
   getCoordinatesArguments latitude longitude
   noMoreQueryArguments

   local -A forecast=()
   owmQueryForecast forecast "${latitude}" "${longitude}"
   listElements forecast
}

performQuery_weather() {
   local latitude longitude
   getCoordinatesArguments latitude longitude
   noMoreQueryArguments

   local -A weather=()
   owmQueryWeather weather "${latitude}" "${longitude}"
   showWeather weather
}

addProgramOption c string.city cityDescriptor "the specification of a city - see below"
addProgramOption R flag saveResponses "save the Open Weather Map API responses"
addProgramParameter query queryType "the type of query to perform"
optionalProgramParameters "arg" "arguments for the query"
parseProgramArguments "${@}"

verifyChoice "query type" queryType city location forecast weather
"performQuery_${queryType}"
exit 0
