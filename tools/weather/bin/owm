#!/bin/bash
. brltty-prologue.bash
shopt -s extglob

readonly windDirections=(N NNE NE ENE E ESE SE SSE S SSW SW WSW W WNW NW NNW)
toWindDirection() {
   local directionVariable="${1}"
   local degrees="${2}"

   local direction=$(( ((((degrees * 4) + 45) % 1440) / 90) ))
   direction="${windDirections[direction]}"
   setVariable "${directionVariable}" "${direction}"
}

parseCoordinate() {
   local valueVariable="${1}"
   local maximumValue="${2}"
   local positiveSuffix="${3}"
   local negativeSuffix="${4}"

   local value="${!valueVariable}"
   local pattern='^([-+])?(0|[1-9][0-9]*)?(\.[0-9]+)?([A-Za-z])?$'

   [[ "${value}" =~ ${pattern} ]] || return 1
   local sign="${BASH_REMATCH[1]}"
   local integer="${BASH_REMATCH[2]}"
   local fraction="${BASH_REMATCH[3]}"
   local suffix="${BASH_REMATCH[4]}"

   if [ "${integer}" -eq "${maximumValue}" ]
   then
      fraction="${fraction##.*(0)}"
      [ -n "${fraction}" ] && return 1
   elif [ "${integer}" -gt "${maximumValue}" ]
   then
      return 1
   fi

   local negativeSign=false
   [ "${sign}" = "-" ] && negativeSign=true

   [ -n "${suffix}" ] && {
      if [ "${suffix}" = "${negativeSuffix}" ]
      then
         "${negativeSign}" && negativeSign=false || negativeSign=true
      elif [ "${suffix}" != "${positiveSuffix}" ]
      then
         return 1
      fi
   }

   value="${integer:-0}${fraction}"
   "${negativeSign}" && value="-${value}"
   setVariable "${valueVariable}" "${value}"
   return 0
}

readonly latitudeSetting="latitude"
readonly latitudePositiveSuffix="N"
readonly latitudeNegativeSuffix="S"

parseLatitude() {
   local latitudeVariable="${1}"

   parseCoordinate "${latitudeVariable}" 90 "${latitudePositiveSuffix}" "${latitudeNegativeSuffix}" || return 1
   return 0
}

readonly longitudeSetting="longitude"
readonly longitudePositiveSuffix="E"
readonly longitudeNegativeSuffix="W"

parseLongitude() {
   local longitudeVariable="${1}"

   parseCoordinate "${longitudeVariable}" 180 "${longitudePositiveSuffix}" "${longitudeNegativeSuffix}" || return 1
   return 0
}

convertUnit() {
   local resultVariable="${1}"
   local from="${2}"
   local to="${3}"
   local precision="${4}"

   local toValue
   setVariable toValue "$(units --terse --output-format "%.${precision:-0}f" "${from}" "${to}")"

   [ "${toValue}" = "${toValue%.*}" ] || {
      toValue="${toValue%%*(0)}"
      toValue="${toValue%.}"
   }

   setVariable "${resultVariable}" "${toValue}"
}

convertSimpleUnit() {
   local resultVariable="${1}"
   local fromValue="${2}"
   local fromUnit="${3}"
   local toUnit="${4}"
   local precision="${5}"

   convertUnit "${resultVariable}" "${fromValue}${fromUnit}" "${toUnit}" "${precision}"
}

formatSimpleUnit() {
   local variable="${1}"
   local fromUnit="${2}"
   local toUnit="${3}"
   local precision="${4}"

   local value="${!variable}"
   convertSimpleUnit value "${value}" "${fromUnit}" "${toUnit}" "${precision}"
   setVariable "${variable}" "${value}${toUnit}"
}

convertComplexUnit() {
   local resultVariable="${1}"
   local fromValue="${2}"
   local fromUnit="${3}"
   local toUnit="${4}"
   local unitType="${5}"
   local precision="${6}"

   convertUnit "${resultVariable}" "${unitType}${fromUnit}(${fromValue})" "${unitType}${toUnit}" "${precision}"
}

formatComplexUnit() {
   local variable="${1}"
   local fromUnit="${2}"
   local toUnit="${3}"
   local unitType="${4}"
   local precision="${5}"

   local value="${!variable}"
   convertComplexUnit value "${value}" "${fromUnit}" "${toUnit}" "${unitType}" "${precision}"
   setVariable "${variable}" "${value}${toUnit}"
}

readonly clockModes=(24hours 12hours)
readonly defaultClockMode="${clockModes[0]}"
readonly clockModeSetting="clock-mode"
addProgramOption C string.mode clockMode "the clock mode to display time in (${clockModes[*]})" "${defaultClockMode}"

readonly -A timeFormats=(
  24hours "%H:%M"
  12hours "%l:%M%p"
)

readonly distanceUnits=(m km ft mi)
readonly defaultDistanceUnit="${distanceUnits[0]}"
readonly distanceUnitSetting="distance-unit"
addProgramOption D string.unit distanceUnit "the unit to display visibility in (${distanceUnits[*]})" "${defaultDistanceUnit}"

readonly pressureUnits=(hpa kpa mb inHg)
readonly defaultPressureUnit="${pressureUnits[0]}"
readonly pressureUnitSetting="pressure-unit"
addProgramOption P string.unit pressureUnit "the unit to display atmospheric pressure in (${pressureUnits[*]})" "${defaultPressureUnit}"

readonly speedUnits=(m/s km/hr mph)
readonly defaultSpeedUnit="${speedUnits[0]}"
readonly speedUnitSetting="speed-unit"
addProgramOption S string.unit speedUnit "the unit to display wind speed in (${speedUnits[*]})" "${defaultSpeedUnit}"

readonly temperatureUnits=(C F K R)
readonly defaultTemperatureUnit="${temperatureUnits[0]}"
readonly temperatureUnitSetting="temperature-unit"
addProgramOption T string.unit temperatureUnit "the unit to display temperaturse in (${temperatureUnits[*]})" "${defaultTemperatureUnit}"

getSetting() {
   local -n value="${1}"
   local default="${2}"
   local setting="${3}"

   [ -n "${value}" ] || {
      getPersistentProgramSetting value "${setting}"

      [ -n "${value}" ] || {
         value="${default}"
      }
   }
}

verifyClockMode() {
   getSetting clockMode "${defaultClockMode}" "${clockModeSetting}"
   verifyChoice "clock mode" clockMode "${clockModes[@]}"
}

verifyDistanceUnit() {
   getSetting distanceUnit "${defaultDistanceUnit}" "${distanceUnitSetting}"
   verifyChoice "distance unit" distanceUnit "${distanceUnits[@]}"
}

verifyPressureUnit() {
   getSetting pressureUnit "${defaultPressureUnit}" "${pressureUnitSetting}"
   verifyChoice "pressure unit" pressureUnit "${pressureUnits[@]}"
}

verifySpeedUnit() {
   getSetting speedUnit "${defaultSpeedUnit}" "${speedUnitSetting}"
   verifyChoice "speed unit" speedUnit "${speedUnits[@]}"
}

verifyTemperatureUnit() {
   getSetting temperatureUnit "${defaultTemperatureUnit}" "${temperatureUnitSetting}"
   verifyChoice "temperature unit" temperatureUnit "${temperatureUnits[@]}"
}

formatTime() {
   local variable="${1}"

   local text
   printf -v text "%(${timeFormat})T" "${!variable}"
   text="${text//+( )/ }"

   setVariable "${variable}" "${text}"
}

formatDistance() {
   local variable="${1}"
   local precision="${2}"

   local value unit="${distanceUnit}"
   convertSimpleUnit value "${!variable}" "${defaultDistanceUnit}" "${unit}" "${precision:-1}"

   [ "${value}" = "0" ] && {
      [ -n "${precision}" ] || {
         case "${unit}"
         in
            k*) unit="${unit#?}";;
            mi) unit="ft";;
         esac

         [ "${unit}" = "${distanceUnit}" ] || {
            convertSimpleUnit value "${!variable}" "${defaultDistanceUnit}" "${unit}" "${precision}"
         }
      }
   }

   setVariable "${variable}" "${value}${unit}"
}

formatPressure() {
   local variable="${1}"
   local precision="${2}"

   formatSimpleUnit "${variable}" "${defaultPressureUnit}" "${pressureUnit}" "${precision:-1}"
}

formatSpeed() {
   local variable="${1}"
   local precision="${2}"

   formatSimpleUnit "${variable}" "${defaultSpeedUnit}" "${speedUnit}" "${precision}"
}

formatTemperature() {
   local variable="${1}"
   local precision="${2}"

   formatComplexUnit "${variable}" "${defaultTemperatureUnit}" "${temperatureUnit}" temp "${precision}"
}

addProgramOption k string.key owmKeyValue "the key for the application performing the query" "the first line in the key file"
addProgramOption K string.path owmKeyFile "the file containing the application key"
addProgramOption R flag owmSaveResponses "save the Open Weather Map API responses"

owmSetKey() {
   local parametersArray="${1}"

   [ -n "${owmKeyValue}" ] || {
      if [ -n "${owmKeyFile}" ]
      then
         verifyInputFile "${owmKeyFile}"
      elif ! findProgramConfigurationFile owmKeyFile "key"
      then
         semanticError "no API key file"
      fi

      read <"${owmKeyFile}" owmKeyValue
   }

   [ -n "${owmKeyValue}" ] || semanticError "API key not specified"
   setElement "${parametersArray}" "appid" "${owmKeyValue}"
}

owmAddQueryParameter() {
   local name="${1}"
   local value="${2}"
   curlOptions+=(--data-urlencode "${name}=${value}")
}

owmQuery() {
   local resultArray="${1}"
   local parametersArray="${2}"
   shift 2

   local curlOptions=(--silent --show-error --get)
   local curlLocation="https://api.OpenWeatherMap.org"

   local -A owmParameters=()
   getElements owmParameters "${parametersArray}"
   owmSetKey owmParameters
   forElements owmParameters owmAddQueryParameter

   local owmComponent
   for owmComponent in "${@}"
   do
      curlLocation+="/${owmComponent}"
   done

   local owmResponse
   owmResponse="$(curl "${curlOptions[@]}" -- "${curlLocation}")" || exit "${?}"

   local owmMessage
   owmMessage="$(jq -r '.message?' <<<"${owmResponse}")"
   [ "${owmMessage}" = "null" ] && owmMessage=""
   [ "${owmMessage}" = "0" ] && owmMessage=""
   [ -n "${owmMessage}" ] && semanticError "${owmMessage}"

   local owmName="${1}-${3}"
   "${owmSaveResponses}" && jq . <<<"${owmResponse}" >"${programName}.${owmName}.json"

   local jqPath
   findProgramComponent jqPath "${owmName}" jq || {
      semanticError "API response parser not found: ${owmName}"
   }

   local jqOptions=(--from-file "${jqPath}")
   jqOptions+=(--raw-output)

   local jqResponse
   jqResponse="$(jq "${jqOptions[@]}" <<<"${owmResponse}")" || exit "${?}"

   local name value
   while read name value
   do
      [ "${value}" = "null" ] && value=""
      setElement "${resultArray}" "${name}" "${value}"
   done <<<"${jqResponse}"

  #listElements "${resultArray}"
}

owmQueryLocation() {
   local locationsArray="${1}"
   local name="${2}"

   local -A parameters=(
      q "${name}"
      limit 5
   )

   owmQuery "${locationsArray}" parameters geo 1.0 direct
}

owmQueryCoordinates() {
   local locationsArray="${1}"
   local latitude="${2}"
   local longitude="${3}"

   local -A parameters=(
      lat "${latitude}"
      lon "${longitude}"
      limit 5
   )

   owmQuery "${locationsArray}" parameters geo 1.0 reverse
}

owmQueryForecast() {
   local forecastArray="${1}"
   local latitude="${2}"
   local longitude="${3}"

   local -A parameters=(
      lat "${latitude}"
      lon "${longitude}"
      units metric
   )

   owmQuery "${forecastArray}" parameters data 2.5 forecast
}

owmQueryWeather() {
   local WeatherArray="${1}"
   local latitude="${2}"
   local longitude="${3}"

   local -A parameters=(
      lat "${latitude}"
      lon "${longitude}"
      units metric
   )

   owmQuery "${WeatherArray}" parameters data 2.5 weather
}

showProgramUsageNotes() {
cat <<END_OF_PROGRAM_USAGE_NOTES

Queries:
  location [name]
  coordinates [latitude longitude]
  forecast [latitude longitude]
  weather [latitude longitude]

The -l option may be used to specify a location in lieu of its coordinates.
A location is specified as name[[,state],country] - the name may be abbreviated.
The optional two-letter ISO 3166 country code must be last.
The optional two-letter state code only applies to the United States.
END_OF_PROGRAM_USAGE_NOTES
}

declare -a queryArguments=()

processExtraProgramParameters() {
   queryArguments=("${@}")
}

haveMoreQueryArguments() {
   [ "${#queryArguments[*]}" -gt 0 ] || return 1
   return 0
}

noMoreQueryArguments() {
   haveMoreQueryArguments && syntaxError "too many ${queryType} arguments"
}

getQueryArgument() {
   local resultVariable="${1}"
   local label="${2}"

   set -- "${queryArguments[@]}"
   [ "${#}" -gt 0 ] || syntaxError "${label} not specified"
   setVariable "${resultVariable}" "${1}"
   shift 1
   queryArguments=("${@}")
}

makeLocationName() {
   local nameVariable="${1}"
   local locationsArray="${2}"
   local index="${3}"

   local name=""
   local field

   for field in name region country
   do
      local value
      getElement value "${locationsArray}" "${index},${field}"
      [ -n "${value}" ] || continue

      [  -n "${name}" ] && name+=", "
      name+="${value}"
   done

   setVariable "${nameVariable}" "${name}"
}

getLocationCoordinates() {
   local latitudeVariable="${1}"
   local longitudeVariable="${2}"
   local name="${3}"

   local -A locations=()
   owmQueryLocation locations "${name}"
   local locationCount="${locations["count"]}"

   if [ "${locationCount}" -eq 1 ]
   then
      local locationName
      makeLocationName locationName locations 0

      local locationLatitude="${locations["0,latitude"]}"
      [ -n "${locationLatitude}" ] || semanticError "latitude not known: ${locationName}"
      setVariable "${latitudeVariable}" "${locationLatitude}"

      local locationLongitude="${locations["0,longitude"]}"
      [ -n "${locationLongitude}" ] || semanticError "longitude not known: ${locationName}"
      setVariable "${longitudeVariable}" "${locationLongitude}"
   elif [ "${locationCount}" -eq 0 ]
   then
      semanticError "location not found: ${name}"
   else
      local locationNames=""
      local locationIndex=0

      while [ "${locationIndex}" -lt "${locationCount}" ]
      do
         local locationName
         makeLocationName locationName locations "${locationIndex}"

         [ -n "${locationNames}" ] && locationNames+="; "
         locationNames+="${locationName}"

         let "locationIndex += 1"
      done

      semanticError "more than one location: ${locationNames}"
   fi
}

getLatitudeArgument() {
   local resultVariable="${1}"

   local coordinate label="latitude"
   getQueryArgument coordinate "${label}"

   parseLatitude coordinate || {
      syntaxError "invalid ${label}: ${coordinate}"
   }

   setVariable "${resultVariable}" "${coordinate}"
}

getLongitudeArgument() {
   local resultVariable="${1}"

   local coordinate label="longitude"
   getQueryArgument coordinate "${label}"

   parseLongitude coordinate || {
      syntaxError "invalid ${label}: ${coordinate}"
   }

   setVariable "${resultVariable}" "${coordinate}"
}

getLocation() {
   local latitudeVariable="${1}"
   local longitudeVariable="${2}"

   if [ -n "${locationName}" ]
   then
      getLocationCoordinates "${latitudeVariable}" "${longitudeVariable}" "${locationName}"
   elif haveMoreQueryArguments
   then
      getLatitudeArgument "${latitudeVariable}"
      getLongitudeArgument "${longitudeVariable}"
   else
      getPersistentProgramSetting "${latitudeVariable}" "${latitudeSetting}"
      getPersistentProgramSetting "${longitudeVariable}" "${longitudeSetting}"
   fi

   "${saveLocation}" && {
      changePersistentProgramSetting "${latitudeSetting}" "${!latitudeVariable}"
      changePersistentProgramSetting "${longitudeSetting}" "${!longitudeVariable}"
   }
}

showLines() {
   local text="" line

   for line
   do
      text+="${line}"
      text+=$'\n'
   done

   echo -n "${text}"
}

showLocations() {
   local locationsArray="${1}"
   local name="${2}"

   local locationCount
   getElement locationCount "${locationsArray}" "count"

   [ "${locationCount}" -gt 0 ] || semanticError "location not found: ${name}"
   local locationIndex=0

   while [ "${locationIndex}" -lt "${locationCount}" ]
   do
      local locationName
      makeLocationName locationName "${locationsArray}" "${locationIndex}"

      local locationLatitude
      getElement locationLatitude "${locationsArray}" "${locationIndex},latitude"

      local locationLongitude
      getElement locationLongitude "${locationsArray}" "${locationIndex},longitude"

      echo "${locationName}: ${locationLatitude} ${locationLongitude}"
      let "locationIndex += 1"
   done
}

performQuery_location() {
   [ -n "${locationName}" ] || getQueryArgument locationName "location"
   noMoreQueryArguments

   local -A locations=()
   owmQueryLocation locations "${locationName}"
   showLocations locations "${locationName}"
}

performQuery_coordinates() {
   local latitude longitude
   getLocation latitude longitude
   noMoreQueryArguments

   local -A locations=()
   owmQueryCoordinates locations "${latitude}" "${longitude}"
   showLocations locations "[${latitude}, ${longitude}]"
}

performQuery_forecast() {
   local latitude longitude
   getLocation latitude longitude
   noMoreQueryArguments

   local -A forecast=()
   owmQueryForecast forecast "${latitude}" "${longitude}"
}

showWeather() {
   local weatherArray="${1}"

   local timeFormat="${timeFormats["${clockMode}"]}, %A, %B %e"
   local lines=() line

   local time offset
   getElement time "${weatherArray}" "time"
   getElement offset "${weatherArray}" "time,offset"
   formatTime time
   printf -v line "as at %s" "${time}"
   lines+=("${line}")

   local name description general
   getElement name "${weatherArray}" "location,name"
   getElement description "${weatherArray}" "weather,description"
   getElement general "${weatherArray}" "weather,general"
   [ -n "${description}" ] || description="${general}"
   printf -v line "%s: %s" "${name}" "${description}"
   lines+=("${line}")

   local temperature feelsLike
   getElement temperature "${weatherArray}" "temperature"
   getElement feelsLike "${weatherArray}" "temperature,feels"
   formatTemperature temperature
   formatTemperature feelsLike
   line="temperature: ${temperature}"
   [ "${feelsLike}" = "${temperature}" ] || line+=" (feels like ${feelsLike})"
   lines+=("${line}")

   local windSpeed windDegrees windDirection
   getElement windSpeed "${weatherArray}" "wind,speed"
   getElement windDegrees "${weatherArray}" "wind,degrees"
   formatSpeed windSpeed
   toWindDirection windDirection "${windDegrees}"
   printf -v line "wind: %s from the %s (%d°)" "${windSpeed}" "${windDirection}" "${windDegrees}"
   lines+=("${line}")

   local humidity pressure
   getElement humidity "${weatherArray}" "humidity"
   getElement pressure "${weatherArray}" "pressure"
   formatPressure pressure
   printf -v line "%d%% humidity, pressure is %s" "${humidity}" "${pressure}"
   lines+=("${line}")

   local clouds visibility
   getElement clouds "${weatherArray}" "clouds,percent"
   getElement visibility "${weatherArray}" "visibility"
   line="${clouds}% clouds"

   [ "${visibility}" -lt 10000 ] && {
      formatDistance visibility
      line+=", visibility is ${visibility}"
   }

   lines+=("${line}")
   showLines "${lines[@]}"
}

performQuery_weather() {
   local latitude longitude
   getLocation latitude longitude
   noMoreQueryArguments

   local -A weather=()
   owmQueryWeather weather "${latitude}" "${longitude}"
   showWeather weather
}

addProgramOption l string.location locationName "the name of a location (see below)"
addProgramOption L flag saveLocation "save the specified location"
addProgramOption U flag saveUnits "save the specified units"
addProgramParameter query queryType "the type of query to perform"
optionalProgramParameters "arg" "arguments for the query"
parseProgramArguments "${@}"

restorePersistentProgramSettins
verifyClockMode
verifyDistanceUnit
verifyPressureUnit
verifySpeedUnit
verifyTemperatureUnit

"${saveUnits}" && {
   changePersistentProgramSetting "${clockModeSetting}" "${clockMode}"
   changePersistentProgramSetting "${distanceUnitSetting}" "${distanceUnit}"
   changePersistentProgramSetting "${pressureUnitSetting}" "${pressureUnit}"
   changePersistentProgramSetting "${speedUnitSetting}" "${speedUnit}"
   changePersistentProgramSetting "${temperatureUnitSetting}" "${temperatureUnit}"
}

verifyChoice "query type" queryType location coordinates forecast weather
"performQuery_${queryType}"

savePersistentProgramSettins
exit 0
