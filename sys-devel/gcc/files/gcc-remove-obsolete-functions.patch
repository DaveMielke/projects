From 7d6142d56df70d6e38ee456eac08757a84224675 Mon Sep 17 00:00:00 2001
From: Caroline Tice <cmtice@google.com>
Date: Fri, 15 Dec 2017 14:32:09 -0800
Subject: [PATCH] Remove the mpatch-functions* stuff added by google3.

BUG=None
TEST=None

Change-Id: Idcd3fe2fd3208547d7e36a7995c4de7a2cdc10f2
---

diff --git a/gcc-4.9/gcc/config/i386/i386-protos.h b/gcc-4.9/gcc/config/i386/i386-protos.h
index fc0eb53..3ae0d6d 100644
--- a/gcc-4.9/gcc/config/i386/i386-protos.h
+++ b/gcc-4.9/gcc/config/i386/i386-protos.h
@@ -28,16 +28,6 @@
 extern bool ix86_can_use_return_insn_p (void);
 extern void ix86_setup_frame_addresses (void);
 
-/* Section names for function patch prologue and epilogue section. See
-   ix86_output_function_nops_prologue_epilogue() in i386.c for details.  */
-#define FUNCTION_PATCH_PROLOGUE_SECTION "_function_patch_prologue"
-#define FUNCTION_PATCH_EPILOGUE_SECTION "_function_patch_epilogue"
-
-extern bool ix86_output_function_nops_prologue_epilogue (FILE *,
-                                                         const char *,
-                                                         const char *,
-                                                         int);
-
 extern HOST_WIDE_INT ix86_initial_elimination_offset (int, int);
 extern void ix86_expand_prologue (void);
 extern void ix86_maybe_emit_epilogue_vzeroupper (void);
diff --git a/gcc-4.9/gcc/config/i386/i386.c b/gcc-4.9/gcc/config/i386/i386.c
index 614b8db..e2fb1da 100644
--- a/gcc-4.9/gcc/config/i386/i386.c
+++ b/gcc-4.9/gcc/config/i386/i386.c
@@ -11835,11 +11835,6 @@
   m->fs = frame_state_save;
 }
 
-
-/* True if the current function should be patched with nops at prologue and
-   returns.  */
-static bool patch_current_function_p = false;
-
 static inline bool
 has_attribute (const char* attribute_name)
 {
@@ -11847,234 +11842,6 @@
                            DECL_ATTRIBUTES (current_function_decl)) != NULL;
 }
 
-/* Return true if we patch the current function. By default a function
-   is patched if it has loops or if the number of insns is greater than
-   patch_functions_min_instructions (number of insns roughly translates
-   to number of instructions).  */
-
-static bool
-check_should_patch_current_function (void)
-{
-  int num_insns = 0;
-  rtx insn;
-  const char *func_name = NULL;
-  struct loops *loops;
-  int num_loops = 0;
-  int min_functions_instructions;
-
-  /* If a function has an attribute forcing patching on or off, do as it
-     indicates.  */
-  if (has_attribute ("always_patch_for_instrumentation"))
-    return true;
-  else if (has_attribute ("never_patch_for_instrumentation"))
-    return false;
-
-  /* Patch the function if it has at least a loop.  */
-  if (!patch_functions_ignore_loops)
-    {
-      if (DECL_STRUCT_FUNCTION (current_function_decl)->cfg)
-        {
-          loops = flow_loops_find (NULL);
-          num_loops = loops->larray->length();
-          /* FIXME - Deallocating the loop causes a seg-fault.  */
-#if 0
-          flow_loops_free (loops);
-#endif
-          /* We are not concerned with the function body as a loop.  */
-          if (num_loops > 1)
-            return true;
-        }
-    }
-
-  /* Else, check if function has more than patch_functions_min_instrctions.  */
-
-  /* Borrowed this code from rest_of_handle_final() in final.c.  */
-  func_name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
-  if (!patch_functions_dont_always_patch_main &&
-      func_name &&
-      strcmp("main", func_name) == 0)
-    return true;
-
-  min_functions_instructions =
-      PARAM_VALUE (PARAM_FUNCTION_PATCH_MIN_INSTRUCTIONS);
-  if (min_functions_instructions > 0)
-    {
-      /* Calculate the number of instructions in this function and only emit
-         function patch for instrumentation if it is greater than
-         patch_functions_min_instructions.  */
-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
-        {
-          if (NONDEBUG_INSN_P (insn))
-            ++num_insns;
-        }
-      if (num_insns < min_functions_instructions)
-        return false;
-    }
-
-  return true;
-}
-
-/* Emit the 11-byte patch space for the function prologue for functions that
-   qualify.  */
-
-static void
-ix86_output_function_prologue (FILE *file,
-                               HOST_WIDE_INT size ATTRIBUTE_UNUSED)
-{
-  /* Only for 64-bit target.  */
-  if (TARGET_64BIT && patch_functions_for_instrumentation)
-    {
-      patch_current_function_p = check_should_patch_current_function();
-      /* Emit the instruction 'jmp 09' followed by 9 bytes to make it 11-bytes
-         of nop.  */
-      ix86_output_function_nops_prologue_epilogue (
-          file,
-          FUNCTION_PATCH_PROLOGUE_SECTION,
-          ASM_BYTE"0xeb,0x09",
-          9);
-    }
-}
-
-/* Emit the nop bytes at function prologue or return (including tail call
-   jumps). The number of nop bytes generated is at least 8.
-   Also emits a section named SECTION_NAME, which is a backpointer section
-   holding the addresses of the nop bytes in the text section.
-   SECTION_NAME is either '_function_patch_prologue' or
-   '_function_patch_epilogue'. The backpointer section can be used to navigate
-   through all the function entry and exit points which are patched with nops.
-   PRE_INSTRUCTIONS are the instructions, if any, at the start of the nop byte
-   sequence. NUM_REMAINING_NOPS are the number of nop bytes to fill,
-   excluding the number of bytes in PRE_INSTRUCTIONS.
-   Returns true if the function was patched, false otherwise.  */
-
-bool
-ix86_output_function_nops_prologue_epilogue (FILE *file,
-                                             const char *section_name,
-                                             const char *pre_instructions,
-                                             int num_remaining_nops)
-{
-  static int labelno = 0;
-  char label[32], section_label[32];
-  section *section = NULL;
-  int num_actual_nops = num_remaining_nops - sizeof(void *);
-  unsigned int section_flags = SECTION_RELRO;
-  char *section_name_comdat = NULL;
-  const char *decl_section_name = NULL;
-  const char *func_name = NULL;
-  char *section_name_function_sections = NULL;
-  size_t len;
-
-  gcc_assert (num_remaining_nops >= 0);
-
-  if (!patch_current_function_p)
-    return false;
-
-  ASM_GENERATE_INTERNAL_LABEL (label, "LFPEL", labelno);
-  ASM_GENERATE_INTERNAL_LABEL (section_label, "LFPESL", labelno++);
-
-  /* Align the start of nops to 2-byte boundary so that the 2-byte jump
-     instruction can be patched atomically at run time.  */
-  ASM_OUTPUT_ALIGN (file, 1);
-
-  /* Emit nop bytes. They look like the following:
-       $LFPEL0:
-         <pre_instruction>
-         0x90 (repeated num_actual_nops times)
-         .quad $LFPESL0 - .
-     followed by section 'section_name' which contains the address
-     of instruction at 'label'.
-   */
-  ASM_OUTPUT_INTERNAL_LABEL (file, label);
-  if (pre_instructions)
-    fprintf (file, "%s\n", pre_instructions);
-
-  while (num_actual_nops-- > 0)
-    asm_fprintf (file, ASM_BYTE"0x90\n");
-
-  fprintf (file, ASM_QUAD);
-  /* Output "section_label - ." for the relative address of the entry in
-     the section 'section_name'.  */
-  assemble_name_raw (file, section_label);
-  fprintf (file, " - .");
-  fprintf (file, "\n");
-
-  /* Emit the backpointer section. For functions belonging to comdat group,
-     we emit a different section named '<section_name>.foo' where 'foo' is
-     the name of the comdat section. This section is later renamed to
-     '<section_name>' by ix86_elf_asm_named_section().
-     We emit a unique section name for the back pointer section for comdat
-     functions because otherwise the 'get_section' call may return an existing
-     non-comdat section with the same name, leading to references from
-     non-comdat section to comdat functions.
-  */
-  if (current_function_decl != NULL_TREE &&
-      DECL_ONE_ONLY (current_function_decl) &&
-      HAVE_COMDAT_GROUP)
-    {
-      decl_section_name =
-          TREE_STRING_POINTER (DECL_SECTION_NAME (current_function_decl));
-      len = strlen (decl_section_name) + strlen (section_name) + 2;
-      section_name_comdat = (char *) alloca (len);
-      sprintf (section_name_comdat, "%s.%s", section_name, decl_section_name);
-      section_name = section_name_comdat;
-      section_flags |= SECTION_LINKONCE;
-    }
-  else if (flag_function_sections)
-    {
-      func_name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
-      if (func_name)
-        {
-          len = strlen (func_name) + strlen (section_name) + 2;
-          section_name_function_sections = (char *) alloca (len);
-          sprintf (section_name_function_sections, "%s.%s", section_name,
-                   func_name);
-          section_name = section_name_function_sections;
-        }
-    }
-  section = get_section (section_name, section_flags, current_function_decl);
-  switch_to_section (section);
-  /* Align the section to 8-byte boundary.  */
-  ASM_OUTPUT_ALIGN (file, 3);
-
-  /* Emit address of the start of nop bytes in the section:
-       $LFPESP0:
-         .quad $LFPEL0
-   */
-  ASM_OUTPUT_INTERNAL_LABEL (file, section_label);
-  fprintf(file, ASM_QUAD);
-  assemble_name_raw (file, label);
-  fprintf (file, "\n");
-
-  /* Switching back to text section.  */
-  switch_to_section (current_function_section ());
-  return true;
-}
-
-/* Strips the characters after '_function_patch_prologue' or
-   '_function_patch_epilogue' and emits the section.  */
-
-static void
-ix86_elf_asm_named_section (const char *name, unsigned int flags,
-                            tree decl)
-{
-  const char *section_name = name;
-  if (!flag_function_sections && HAVE_COMDAT_GROUP && flags & SECTION_LINKONCE)
-    {
-      const int prologue_section_name_length =
-          sizeof(FUNCTION_PATCH_PROLOGUE_SECTION) - 1;
-      const int epilogue_section_name_length =
-          sizeof(FUNCTION_PATCH_EPILOGUE_SECTION) - 1;
-
-      if (strncmp (name, FUNCTION_PATCH_PROLOGUE_SECTION,
-                   prologue_section_name_length) == 0)
-        section_name = FUNCTION_PATCH_PROLOGUE_SECTION;
-      else if (strncmp (name, FUNCTION_PATCH_EPILOGUE_SECTION,
-                        epilogue_section_name_length) == 0)
-        section_name = FUNCTION_PATCH_EPILOGUE_SECTION;
-    }
-  default_elf_asm_named_section (section_name, flags, decl);
-}
-
 /* Reset from the function's potential modifications.  */
 
 static void
@@ -25335,15 +25102,6 @@
       else
 	xasm = "jmp\t%A0";
 
-      /* Just before the sibling call, add 11-bytes of nops to patch function
-         exit: 2 bytes for 'jmp 09' and remaining 9 bytes.  */
-      if (TARGET_64BIT && patch_functions_for_instrumentation)
-        ix86_output_function_nops_prologue_epilogue (
-            asm_out_file,
-            FUNCTION_PATCH_EPILOGUE_SECTION,
-            ASM_BYTE"0xeb, 0x09",
-            9);
-
       output_asm_insn (xasm, &call_op);
       return "";
     }
@@ -47385,15 +47143,9 @@
 #undef TARGET_BUILTIN_RECIPROCAL
 #define TARGET_BUILTIN_RECIPROCAL ix86_builtin_reciprocal
 
-#undef TARGET_ASM_FUNCTION_PROLOGUE
-#define TARGET_ASM_FUNCTION_PROLOGUE ix86_output_function_prologue
-
 #undef TARGET_ASM_FUNCTION_EPILOGUE
 #define TARGET_ASM_FUNCTION_EPILOGUE ix86_output_function_epilogue
 
-#undef TARGET_ASM_NAMED_SECTION
-#define TARGET_ASM_NAMED_SECTION ix86_elf_asm_named_section
-
 #undef TARGET_ENCODE_SECTION_INFO
 #ifndef SUBTARGET_ENCODE_SECTION_INFO
 #define TARGET_ENCODE_SECTION_INFO ix86_encode_section_info
diff --git a/gcc-4.9/gcc/config/i386/i386.md b/gcc-4.9/gcc/config/i386/i386.md
index 2369e4b..d3caabf 100644
--- a/gcc-4.9/gcc/config/i386/i386.md
+++ b/gcc-4.9/gcc/config/i386/i386.md
@@ -11583,18 +11583,7 @@
 (define_insn "simple_return_internal"
   [(simple_return)]
   "reload_completed"
-{
-  if (TARGET_64BIT && patch_functions_for_instrumentation)
-    {
-      /* Emit 10 nop bytes after ret.  */
-      if (ix86_output_function_nops_prologue_epilogue (asm_out_file,
-      	 					       FUNCTION_PATCH_EPILOGUE_SECTION,
-						       "\tret",
-						       10))
-	return "";
-    }
-  return "ret";
-}
+  "ret"
   [(set_attr "length" "1")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
@@ -11607,18 +11596,7 @@
   [(simple_return)
    (unspec [(const_int 0)] UNSPEC_REP)]
   "reload_completed"
-{
-  if (TARGET_64BIT && patch_functions_for_instrumentation)
-    {
-      /* Emit 9 nop bytes after rep;ret.  */
-      if (ix86_output_function_nops_prologue_epilogue (asm_out_file,
-						       FUNCTION_PATCH_EPILOGUE_SECTION,
-						       "\trep\;ret",
-						       9))
-	return "";
-    }
-  return "rep\;ret";
-}
+  "rep\;ret"
   [(set_attr "length" "2")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
diff --git a/gcc-4.9/gcc/config/i386/i386.opt b/gcc-4.9/gcc/config/i386/i386.opt
index f64a9e1..0f463a2 100644
--- a/gcc-4.9/gcc/config/i386/i386.opt
+++ b/gcc-4.9/gcc/config/i386/i386.opt
@@ -781,18 +781,6 @@
 Target Report Mask(ISA_RTM) Var(ix86_isa_flags) Save
 Support RTM built-in functions and code generation
 
-mpatch-functions-for-instrumentation
-Target RejectNegative Report Var(patch_functions_for_instrumentation) Save
-Patch function prologue and epilogue with custom NOPs for dynamic instrumentation. By default, functions with loops (controlled by -mpatch-functions-without-loop) or functions having instructions more than -mpatch-functions-min-instructions are patched.
-
-mpatch-functions-ignore-loops
-Target RejectNegative Report Var(patch_functions_ignore_loops) Save
-Ignore loops when deciding whether to patch a function for instrumentation (for use with -mpatch-functions-for-instrumentation).
-
-mno-patch-functions-main-always
-Target Report RejectNegative Var(patch_functions_dont_always_patch_main) Save
-Treat 'main' as any other function and only patch it if it meets the criteria for loops and minimum number of instructions (for use with -mpatch-functions-for-instrumentation).
-
 mstack-protector-guard=
 Target RejectNegative Joined Enum(stack_protector_guard) Var(ix86_stack_protector_guard) Init(SSP_TLS)
 Use given stack-protector guard
diff --git a/gcc-4.9/gcc/params.def b/gcc-4.9/gcc/params.def
index 518d379..31bd13d 100644
--- a/gcc-4.9/gcc/params.def
+++ b/gcc-4.9/gcc/params.def
@@ -1338,15 +1338,6 @@
 	  "strength reduction",
 	  50, 1, 999999)
 
-/* Parameters to be used with -mpatch-functions-for-instrumentation.
-   See config/i386/i386.opt  */
-DEFPARAM (PARAM_FUNCTION_PATCH_MIN_INSTRUCTIONS,
-          "function-patch-min-instructions",
-          "Minimum number of instructions in the function without loop before "
-          "the function is qualified for patching for instrumentation (for use "
-          "with -mpatch-functions-for-instrumentation)",
-          200, 0, 0)
-
 DEFPARAM (PARAM_ASAN_STACK,
          "asan-stack",
          "Enable asan stack protection",
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-1.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-1.c
deleted file mode 100644
index aa1f424..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-1.c
+++ /dev/null
@@ -1,23 +0,0 @@
-/* Verify -mpatch-functions-for-instrumentation works.  */
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation" } */
-
-/* Check nop-bytes at beginning.  */
-/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* Check nop-bytes at end.  */
-/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-__attribute__ ((noinline))
-void foo()
-{
-  /* Dummy loop.  */
-  int x = 0;
-  while (++x);
-}
-
-int main()
-{
-  foo();
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-2.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-2.c
deleted file mode 100644
index 78de867..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-2.c
+++ /dev/null
@@ -1,21 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
-
-/* Function is small to be instrumented with default values. Check there
-   aren't any nop-bytes at beginning or end of function.  */
-
-/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-__attribute__ ((noinline))
-void foo()
-{
-  int x = 0;
-}
-
-int main()
-{
-  foo();
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-3.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-3.c
deleted file mode 100644
index 9e8eb52..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-3.c
+++ /dev/null
@@ -1,21 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation --param function-patch-min-instructions=0" } */
-
-/* Function should have nop-bytes with -mpatch-function-min-instructions=0.
-   Check there are nop-bytes at beginning and end of function.  */
-
-/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-__attribute__ ((noinline))
-void foo()
-{
-  int x = 0;
-}
-
-int main()
-{
-  foo();
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-4.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-4.c
deleted file mode 100644
index 7a031d7..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-4.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation -mpatch-functions-ignore-loops -mno-patch-functions-main-always" } */
-
-/* Function is too small to be patched when ignoring the loop.
-   Check there aren't any nop-bytes at beginning and end of function.  */
-
-/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-__attribute__ ((noinline))
-void foo()
-{
-  int x = 0;
-  while (++x);
-}
-
-int main()
-{
-  foo();
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-5.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-5.c
deleted file mode 100644
index cd6a014..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-5.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation -mpatch-functions-ignore-loops --param function-patch-min-instructions=0" } */
-
-/* Function should be patched with nop bytes with given options.
-   Check there are nop-bytes at beginning and end of function.  */
-
-/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-__attribute__ ((noinline))
-void foo()
-{
-  int x = 0;
-  while (++x);
-}
-
-int main()
-{
-  foo();
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-6.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-6.c
deleted file mode 100644
index c1d6446..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-6.c
+++ /dev/null
@@ -1,15 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation" } */
-
-/* 'main' function should always be patched, irrespective of how small it is.
-   Check there are nop-bytes at beginning and end of main.  */
-
-/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-int main()
-{
-  int x = 0;
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-7.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-7.c
deleted file mode 100644
index f625298..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-7.c
+++ /dev/null
@@ -1,15 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
-
-/* 'main' shouldn't be patched with the option -mno-patch-functions-main-always.
-   Check there aren't any nop-bytes at beginning and end of main.  */
-
-/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-int main()
-{
-  int x = 0;
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-8.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-8.c
deleted file mode 100644
index 436379c..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-8.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Verify -mpatch-functions-for-instrumentation works.  */
-/* { dg-do run } */
-/* { dg-require-effective-target lp64 } */
-
-/* -O2 forces a sibling call for foo from bar.  */
-/* { dg-options "-O2 -mpatch-functions-for-instrumentation --param function-patch-min-instructions=0" } */
-
-__attribute__ ((noinline))
-int foo()
-{
-  /* Dummy loop.  */
-  int x = 10;
-  int y = 100;
-  while (--x)
-    ++y;
-  return y;
-}
-
-__attribute__ ((noinline))
-int bar()
-{
-  return foo();
-}
-
-int main()
-{
-  bar();
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-force-no-patching.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-force-no-patching.c
deleted file mode 100644
index cad6f2d..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-force-no-patching.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
-
-/* Even complicated functions shouldn't get patched if they have the
-   never_patch_for_instrumentation attribute. */
-
-/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-__attribute__ ((never_patch_for_instrumentation))
-int foo () {
-  volatile unsigned x = 0;
-  volatile unsigned y = 1;
-  x += y;
-  x *= y;
-  while (++x)
-    foo ();
-  return y;
-}
-
-
-int main ()
-{
-  int x = 0;
-  return 0;
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-force-patching.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-force-patching.c
deleted file mode 100644
index 86ad159..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-force-patching.c
+++ /dev/null
@@ -1,20 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* { dg-options "-O3 -mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
-
-/* Functions which have the always_patch attribute should be patched no matter
-   what.  Check that there are nop-bytes at the beginning and end of the
-   function.  We add -O3 so that the compiler will try to inline foo (but it
-   will be blocked by the attribute).  */
-
-/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
-
-__attribute__ ((always_patch_for_instrumentation))
-static int foo () {
-  return 3;
-}
-
-int main () {
-  volatile int x = foo ();
-}
diff --git a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-sibling-call.c b/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-sibling-call.c
deleted file mode 100644
index 847a95c..0000000
--- a/gcc-4.9/gcc/testsuite/gcc.target/i386/patch-functions-sibling-call.c
+++ /dev/null
@@ -1,26 +0,0 @@
-/* { dg-do compile } */
-/* { dg-require-effective-target lp64 } */
-/* -O2 forces a sibling call.  */
-/* { dg-options "-O2 -mpatch-functions-for-instrumentation" } */
-
-/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
-
-/* Checks correct nop-bytes are generated just before a sibling call.  */
-/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90(.*)jmp" } } */
-
-/* Not instrumented as function has no loop and is small.  */
-__attribute__ ((noinline))
-int foo(int n)
-{
-  int x = 0;
-  return n + 10;
-}
-
-__attribute__ ((noinline))
-int bar(int n)
-{
-  /* Dummy loop.  */
-  while (--n)
-    n = n * 2;
-  return foo(n);
-}
