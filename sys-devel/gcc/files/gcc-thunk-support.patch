diff --git a/gcc-4.9/gcc/config/i386/i386-opts.h b/gcc-4.9/gcc/config/i386/i386-opts.h
index 47a34dbf7..e98cd8c1e 100644
--- a/gcc-4.9/gcc/config/i386/i386-opts.h
+++ b/gcc-4.9/gcc/config/i386/i386-opts.h
@@ -93,4 +93,18 @@ enum stack_protector_guard {
   SSP_GLOBAL    /* global canary */
 };
 
+enum indirect_branch {
+  indirect_branch_unset = 0,
+  indirect_branch_keep,
+  indirect_branch_thunk,
+  indirect_branch_thunk_inline,
+  indirect_branch_thunk_extern
+};
+
+enum indirect_branch_loop {
+  indirect_branch_loop_lfence,
+  indirect_branch_loop_pause,
+  indirect_branch_loop_nop
+};
+
 #endif
diff --git a/gcc-4.9/gcc/config/i386/i386-protos.h b/gcc-4.9/gcc/config/i386/i386-protos.h
index 3ae0d6db2..e2c462a71 100644
--- a/gcc-4.9/gcc/config/i386/i386-protos.h
+++ b/gcc-4.9/gcc/config/i386/i386-protos.h
@@ -312,6 +312,8 @@ extern enum attr_cpu ix86_schedule;
 #endif
 
 extern const char * ix86_output_call_insn (rtx insn, rtx call_op);
+extern const char * ix86_output_indirect_jmp (rtx call_op, bool ret_p);
+extern const char * ix86_output_function_return (bool long_p);
 extern bool adjacent_mem_locations (rtx mem1, rtx mem2);
 
 #ifdef RTX_CODE
diff --git a/gcc-4.9/gcc/config/i386/i386.c b/gcc-4.9/gcc/config/i386/i386.c
index e2fb1da00..afc8eea46 100644
--- a/gcc-4.9/gcc/config/i386/i386.c
+++ b/gcc-4.9/gcc/config/i386/i386.c
@@ -2267,53 +2267,6 @@ struct GTY(()) stack_local_entry {
   struct stack_local_entry *next;
 };
 
-/* Structure describing stack frame layout.
-   Stack grows downward:
-
-   [arguments]
-					<- ARG_POINTER
-   saved pc
-
-   saved static chain			if ix86_static_chain_on_stack
-
-   saved frame pointer			if frame_pointer_needed
-					<- HARD_FRAME_POINTER
-   [saved regs]
-					<- regs_save_offset
-   [padding0]
-
-   [saved SSE regs]
-					<- sse_regs_save_offset
-   [padding1]          |
-		       |		<- FRAME_POINTER
-   [va_arg registers]  |
-		       |
-   [frame]	       |
-		       |
-   [padding2]	       | = to_allocate
-					<- STACK_POINTER
-  */
-struct ix86_frame
-{
-  int nsseregs;
-  int nregs;
-  int va_arg_size;
-  int red_zone_size;
-  int outgoing_arguments_size;
-
-  /* The offsets relative to ARG_POINTER.  */
-  HOST_WIDE_INT frame_pointer_offset;
-  HOST_WIDE_INT hard_frame_pointer_offset;
-  HOST_WIDE_INT stack_pointer_offset;
-  HOST_WIDE_INT hfp_save_offset;
-  HOST_WIDE_INT reg_save_offset;
-  HOST_WIDE_INT sse_reg_save_offset;
-
-  /* When save_regs_using_mov is set, emit prologue using
-     move instead of push instructions.  */
-  bool save_regs_using_mov;
-};
-
 /* Which cpu are we scheduling for.  */
 enum attr_cpu ix86_schedule;
 
@@ -2403,7 +2356,7 @@ static unsigned int ix86_function_arg_boundary (enum machine_mode,
 						const_tree);
 static rtx ix86_static_chain (const_tree, bool);
 static int ix86_function_regparm (const_tree, const_tree);
-static void ix86_compute_frame_layout (struct ix86_frame *);
+static void ix86_compute_frame_layout (void);
 static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,
 						 rtx, rtx, int);
 static void ix86_add_new_builtins (HOST_WIDE_INT);
@@ -2558,12 +2511,19 @@ make_pass_insert_vzeroupper (gcc::context *ctxt)
   return new pass_insert_vzeroupper (ctxt);
 }
 
-/* Return true if a red-zone is in use.  */
+/* Return true if a red-zone is in use.  We can't use red-zone when
+   there are local indirect jumps, like "indirect_jump" or "tablejump",
+   which jumps to another place in the function, since "call" in the
+   indirect thunk pushes the return address onto stack, destroying
+   red-zone.  */
 
 static inline bool
 ix86_using_red_zone (void)
 {
-  return TARGET_RED_ZONE && !TARGET_64BIT_MS_ABI;
+  return (TARGET_RED_ZONE
+          && !TARGET_64BIT_MS_ABI
+          && (!cfun->machine->has_local_indirect_jump
+              || cfun->machine->indirect_branch_type == indirect_branch_keep));
 }
 
 /* Return a string that documents the current -m options.  The caller is
@@ -4963,6 +4923,65 @@ ix86_reset_previous_fndecl (void)
   ix86_previous_fndecl = NULL_TREE;
 }
 
+/* Set the indirect_branch_type field from the function FNDECL.  */
+
+static void
+ix86_set_indirect_branch_type (tree fndecl)
+{
+  if (cfun->machine == NULL)
+    return;
+
+  if (cfun->machine->indirect_branch_type == indirect_branch_unset)
+    {
+      tree attr = lookup_attribute ("indirect_branch",
+                                    DECL_ATTRIBUTES (fndecl));
+      if (attr != NULL)
+        {
+          tree args = TREE_VALUE (attr);
+          if (args == NULL)
+            gcc_unreachable ();
+          tree cst = TREE_VALUE (args);
+          if (strcmp (TREE_STRING_POINTER (cst), "keep") == 0)
+            cfun->machine->indirect_branch_type = indirect_branch_keep;
+          else if (strcmp (TREE_STRING_POINTER (cst), "thunk") == 0)
+            cfun->machine->indirect_branch_type = indirect_branch_thunk;
+          else if (strcmp (TREE_STRING_POINTER (cst), "thunk-inline") == 0)
+            cfun->machine->indirect_branch_type = indirect_branch_thunk_inline;
+          else if (strcmp (TREE_STRING_POINTER (cst), "thunk-extern") == 0)
+            cfun->machine->indirect_branch_type = indirect_branch_thunk_extern;
+          else
+            gcc_unreachable ();
+        }
+      else
+        cfun->machine->indirect_branch_type = ix86_indirect_branch;
+    }
+
+  if (cfun->machine->function_return_type == indirect_branch_unset)
+    {
+      tree attr = lookup_attribute ("function_return",
+                                    DECL_ATTRIBUTES (fndecl));
+      if (attr != NULL)
+        {
+          tree args = TREE_VALUE (attr);
+          if (args == NULL)
+            gcc_unreachable ();
+          tree cst = TREE_VALUE (args);
+          if (strcmp (TREE_STRING_POINTER (cst), "keep") == 0)
+            cfun->machine->function_return_type = indirect_branch_keep;
+          else if (strcmp (TREE_STRING_POINTER (cst), "thunk") == 0)
+            cfun->machine->function_return_type = indirect_branch_thunk;
+          else if (strcmp (TREE_STRING_POINTER (cst), "thunk-inline") == 0)
+            cfun->machine->function_return_type = indirect_branch_thunk_inline;
+          else if (strcmp (TREE_STRING_POINTER (cst), "thunk-extern") == 0)
+            cfun->machine->function_return_type = indirect_branch_thunk_extern;
+          else
+            gcc_unreachable ();
+        }
+      else
+        cfun->machine->function_return_type = ix86_function_return;
+    }
+}
+
 /* Establish appropriate back-end context for processing the function
    FNDECL.  The argument might be NULL to indicate processing at top
    level, outside of any function scope.  */
@@ -4982,6 +5001,8 @@ ix86_set_current_function (tree fndecl)
 		       ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)
 		       : NULL_TREE);
 
+      ix86_set_indirect_branch_type (fndecl);
+
       ix86_previous_fndecl = fndecl;
       if (old_tree == new_tree)
 	;
@@ -9074,7 +9095,6 @@ symbolic_reference_mentioned_p (rtx op)
 bool
 ix86_can_use_return_insn_p (void)
 {
-  struct ix86_frame frame;
 
   if (! reload_completed || frame_pointer_needed)
     return 0;
@@ -9084,7 +9104,8 @@ ix86_can_use_return_insn_p (void)
   if (crtl->args.pops_args && crtl->args.size >= 32768)
     return 0;
 
-  ix86_compute_frame_layout (&frame);
+  ix86_compute_frame_layout ();
+  struct ix86_frame &frame = cfun->machine->frame;
   return (frame.stack_pointer_offset == UNITS_PER_WORD
 	  && (frame.nregs + frame.nsseregs) == 0);
 }
@@ -9147,6 +9168,217 @@ ix86_setup_frame_addresses (void)
 # endif
 #endif
 
+static int indirectlabelno;
+static bool indirect_thunk_needed = false;
+
+static int indirect_thunks_used;
+
+#ifndef INDIRECT_LABEL
+# define INDIRECT_LABEL "LIND"
+#endif
+
+/* Fills in the label name that should be used for the indirect thunk.  */
+
+static void
+indirect_thunk_name (char name[32], int regno, bool ret_p)
+{
+  if (regno >= 0 && ret_p)
+    gcc_unreachable ();
+
+  if (USE_HIDDEN_LINKONCE)
+    {
+      if (regno >= 0)
+        {
+          const char *reg_prefix;
+          if (!REX_INT_REGNO_P (regno))
+            reg_prefix = TARGET_64BIT ? "r" : "e";
+          else
+            reg_prefix = "";
+          sprintf (name, "__x86.indirect_thunk.%s%s",
+                   reg_prefix, reg_names[regno]);
+        }
+      else
+        {
+          const char *ret = ret_p ? "return" : "indirect";
+          sprintf (name, "__x86.%s_thunk", ret);
+        }
+    }
+  else
+    {
+      if (regno >= 0)
+        ASM_GENERATE_INTERNAL_LABEL (name, "LITR", regno);
+      else
+        {
+          if (ret_p)
+            ASM_GENERATE_INTERNAL_LABEL (name, "LRT", 0);
+          else
+            ASM_GENERATE_INTERNAL_LABEL (name, "LIT", 0);
+        }
+    }
+}
+
+static void
+output_indirect_thunk (int regno)
+{
+  char indirectlabel1[32];
+  char indirectlabel2[32];
+
+  ASM_GENERATE_INTERNAL_LABEL (indirectlabel1, INDIRECT_LABEL,
+                              indirectlabelno++);
+  ASM_GENERATE_INTERNAL_LABEL (indirectlabel2, INDIRECT_LABEL,
+                              indirectlabelno++);
+
+  /* Call */
+  fputs ("\tcall\t", asm_out_file);
+  assemble_name_raw (asm_out_file, indirectlabel2);
+  fputc ('\n', asm_out_file);
+
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel1);
+
+  switch (ix86_indirect_branch_loop)
+    {
+    case indirect_branch_loop_lfence:
+      /* lfence.  */
+      fprintf (asm_out_file, "\tlfence\n");
+      break;
+    case indirect_branch_loop_pause:
+      /* pause.  */
+      fprintf (asm_out_file, "\tpause\n");
+      break;
+    case indirect_branch_loop_nop:
+      /* nop.  */
+      fprintf (asm_out_file, "\tnop\n");
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  /* Jump.  */
+  fputs ("\tjmp\t", asm_out_file);
+  assemble_name_raw (asm_out_file, indirectlabel1);
+  fputc ('\n', asm_out_file);
+
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
+
+  if (regno >= 0)
+    {
+      /* MOV.  */
+      rtx xops[2];
+      xops[0] = gen_rtx_MEM (word_mode, stack_pointer_rtx);
+      xops[1] = gen_rtx_REG (word_mode, regno);
+      output_asm_insn ("mov\t{%1, %0|%0, %1}", xops);
+    }
+  else
+    {
+      /* LEA.  */
+      rtx xops[2];
+      xops[0] = stack_pointer_rtx;
+      xops[1] = plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD);
+      output_asm_insn ("lea\t{%E1, %0|%0, %E1}", xops);
+    }
+
+  fputs ("\tret\n", asm_out_file);
+}
+
+static void
+output_indirect_thunk_function (int regno)
+{
+  char name[32];
+  tree decl;
+
+  /* Create __x86.indirect_thunk.  */
+  indirect_thunk_name (name, regno, false);
+  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
+                    get_identifier (name),
+                    build_function_type_list (void_type_node, NULL_TREE));
+  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
+                                  NULL_TREE, void_type_node);
+  TREE_PUBLIC (decl) = 1;
+  TREE_STATIC (decl) = 1;
+  DECL_IGNORED_P (decl) = 1;
+
+#if TARGET_MACHO
+  if (TARGET_MACHO)
+    {
+      switch_to_section (darwin_sections[text_coal_section]);
+      fputs ("\t.weak_definition\t", asm_out_file);
+      assemble_name (asm_out_file, name);
+      fputs ("\n\t.private_extern\t", asm_out_file);
+      assemble_name (asm_out_file, name);
+      putc ('\n', asm_out_file);
+      ASM_OUTPUT_LABEL (asm_out_file, name);
+      DECL_WEAK (decl) = 1;
+    }
+  else
+#endif
+    if (USE_HIDDEN_LINKONCE)
+      {
+       DECL_COMDAT_GROUP (decl) = DECL_ASSEMBLER_NAME (decl);
+
+       targetm.asm_out.unique_section (decl, 0);
+       switch_to_section (get_named_section (decl, NULL, 0));
+
+       targetm.asm_out.globalize_label (asm_out_file, name);
+       fputs ("\t.hidden\t", asm_out_file);
+       assemble_name (asm_out_file, name);
+       putc ('\n', asm_out_file);
+       ASM_DECLARE_FUNCTION_NAME (asm_out_file, name, decl);
+      }
+    else
+      {
+       switch_to_section (text_section);
+       ASM_OUTPUT_LABEL (asm_out_file, name);
+      }
+
+  if (regno < 0)
+    {
+      /* Create alias for __x86.return_thunk.  */
+      char alias[32];
+
+      indirect_thunk_name (alias, regno, true);
+      ASM_OUTPUT_DEF (asm_out_file, alias, name);
+#if TARGET_MACHO
+      if (TARGET_MACHO)
+        {
+          fputs ("\t.weak_definition\t", asm_out_file);
+          assemble_name (asm_out_file, alias);
+          fputs ("\n\t.private_extern\t", asm_out_file);
+          assemble_name (asm_out_file, alias);
+          putc ('\n', asm_out_file);
+        }
+#else
+      if (USE_HIDDEN_LINKONCE)
+        {
+          fputs ("\t.globl\t", asm_out_file);
+          assemble_name (asm_out_file, alias);
+          putc ('\n', asm_out_file);
+          fputs ("\t.hidden\t", asm_out_file);
+          assemble_name (asm_out_file, alias);
+          putc ('\n', asm_out_file);
+        }
+#endif
+    }
+
+  DECL_INITIAL (decl) = make_node (BLOCK);
+  current_function_decl = decl;
+  allocate_struct_function (decl, false);
+  init_function_start (decl);
+  /* We're about to hide the function body from callees of final_* by
+     emitting it directly; tell them we're a thunk, if they care.  */
+  cfun->is_thunk = true;
+  first_function_block_is_cold = false;
+  /* Make sure unwind info is emitted for the thunk if needed.  */
+  final_start_function (emit_barrier (), asm_out_file, 1);
+
+  output_indirect_thunk (regno);
+
+  final_end_function ();
+  init_insn_lengths ();
+  free_after_compilation (cfun);
+  set_cfun (NULL);
+  current_function_decl = NULL;
+}
+
 static int pic_labels_used;
 
 /* Fills in the label name that should be used for a pc thunk for
@@ -9173,11 +9405,24 @@ ix86_code_end (void)
   rtx xops[2];
   int regno;
 
+  if (indirect_thunk_needed)
+    output_indirect_thunk_function (-1);
+
+  for (regno = FIRST_REX_INT_REG; regno <= LAST_REX_INT_REG; regno++)
+    {
+      int i = regno - FIRST_REX_INT_REG + SP_REG + 1;
+      if ((indirect_thunks_used & (1 << i)))
+        output_indirect_thunk_function (regno);
+    }
+
   for (regno = AX_REG; regno <= SP_REG; regno++)
     {
       char name[32];
       tree decl;
 
+      if ((indirect_thunks_used & (1 << regno)))
+        output_indirect_thunk_function (regno);
+
       if (!(pic_labels_used & (1 << regno)))
 	continue;
 
@@ -9479,8 +9724,8 @@ ix86_can_eliminate (const int from, const int to)
 HOST_WIDE_INT
 ix86_initial_elimination_offset (int from, int to)
 {
-  struct ix86_frame frame;
-  ix86_compute_frame_layout (&frame);
+  ix86_compute_frame_layout ();
+  struct ix86_frame &frame = cfun->machine->frame;
 
   if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)
     return frame.hard_frame_pointer_offset;
@@ -9519,8 +9764,9 @@ ix86_builtin_setjmp_frame_value (void)
 /* Fill structure ix86_frame about frame of currently computed function.  */
 
 static void
-ix86_compute_frame_layout (struct ix86_frame *frame)
+ix86_compute_frame_layout (void)
 {
+  struct ix86_frame *frame = &cfun->machine->frame;
   unsigned HOST_WIDE_INT stack_alignment_needed;
   HOST_WIDE_INT offset;
   unsigned HOST_WIDE_INT preferred_alignment;
@@ -10736,7 +10982,6 @@ ix86_expand_prologue (void)
   struct machine_function *m = cfun->machine;
   rtx insn, t;
   bool pic_reg_used;
-  struct ix86_frame frame;
   HOST_WIDE_INT allocate;
   bool int_registers_saved;
   bool sse_registers_saved;
@@ -10758,7 +11003,8 @@ ix86_expand_prologue (void)
   m->fs.sp_offset = INCOMING_FRAME_SP_OFFSET;
   m->fs.sp_valid = true;
 
-  ix86_compute_frame_layout (&frame);
+  ix86_compute_frame_layout ();
+  struct ix86_frame &frame = m->frame;
 
   if (!TARGET_64BIT && ix86_function_ms_hook_prologue (current_function_decl))
     {
@@ -11298,10 +11544,10 @@ static rtx
 ix86_set_fp_insn ()
 {
   rtx r, seq;
-  struct ix86_frame frame;
   HOST_WIDE_INT offset;
 
-  ix86_compute_frame_layout (&frame);
+  ix86_compute_frame_layout ();
+  struct ix86_frame &frame = cfun->machine->frame;
   gcc_assert (frame_pointer_partially_needed);
   offset = frame.stack_pointer_offset - frame.hard_frame_pointer_offset;
 
@@ -11491,12 +11737,12 @@ ix86_expand_epilogue (int style)
 {
   struct machine_function *m = cfun->machine;
   struct machine_frame_state frame_state_save = m->fs;
-  struct ix86_frame frame;
   bool restore_regs_via_mov;
   bool using_drap;
 
   ix86_finalize_stack_realign_flags ();
-  ix86_compute_frame_layout (&frame);
+  ix86_compute_frame_layout ();
+  struct ix86_frame &frame = m->frame;
 
   m->fs.sp_valid = (!frame_pointer_needed
 		    || (crtl->sp_is_unchanging
@@ -11963,7 +12209,6 @@ static GTY(()) rtx split_stack_fn_large;
 void
 ix86_expand_split_stack_prologue (void)
 {
-  struct ix86_frame frame;
   HOST_WIDE_INT allocate;
   unsigned HOST_WIDE_INT args_size;
   rtx label, limit, current, jump_insn, allocate_rtx, call_insn, call_fusage;
@@ -11974,7 +12219,8 @@ ix86_expand_split_stack_prologue (void)
   gcc_assert (flag_split_stack && reload_completed);
 
   ix86_finalize_stack_realign_flags ();
-  ix86_compute_frame_layout (&frame);
+  ix86_compute_frame_layout ();
+  struct ix86_frame &frame = cfun->machine->frame;
   allocate = frame.stack_pointer_offset - INCOMING_FRAME_SP_OFFSET;
 
   /* This is the label we will branch to if we have enough stack
@@ -25055,6 +25301,145 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,
   return call;
 }
 
+static void
+ix86_output_indirect_branch (rtx call_op, const char *xasm,
+                             bool sibcall_p)
+{
+  char thunk_name_buf[32];
+  char *thunk_name;
+  char push_buf[64];
+  int regno;
+
+  if (REG_P (call_op))
+    regno = REGNO (call_op);
+  else
+    regno = -1;
+
+  if (cfun->machine->indirect_branch_type
+      != indirect_branch_thunk_inline)
+    {
+      if (cfun->machine->indirect_branch_type == indirect_branch_thunk)
+        {
+          if (regno >= 0)
+            {
+              int i = regno;
+              if (i >= FIRST_REX_INT_REG)
+                i -= (FIRST_REX_INT_REG - SP_REG - 1);
+              indirect_thunks_used |= 1 << i;
+            }
+          else
+            indirect_thunk_needed = true;
+        }
+      indirect_thunk_name (thunk_name_buf, regno, false);
+      thunk_name = thunk_name_buf;
+    }
+  else
+    thunk_name = NULL;
+
+  snprintf (push_buf, sizeof (push_buf), "push{%c}\t%s",
+            TARGET_64BIT ? 'q' : 'l', xasm);
+
+  if (sibcall_p)
+    {
+      if (regno < 0)
+        output_asm_insn (push_buf, &call_op);
+      if (thunk_name != NULL)
+        fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+      else
+        output_indirect_thunk (regno);
+    }
+  else
+    {
+      if (regno >= 0 && thunk_name != NULL)
+        {
+          fprintf (asm_out_file, "\tcall\t%s\n", thunk_name);
+          return;
+        }
+
+      char indirectlabel1[32];
+      char indirectlabel2[32];
+
+      ASM_GENERATE_INTERNAL_LABEL (indirectlabel1,
+                                   INDIRECT_LABEL,
+                                   indirectlabelno++);
+      ASM_GENERATE_INTERNAL_LABEL (indirectlabel2,
+                                   INDIRECT_LABEL,
+                                   indirectlabelno++);
+
+      /* Jump.  */
+      fputs ("\tjmp\t", asm_out_file);
+      assemble_name_raw (asm_out_file, indirectlabel2);
+      fputc ('\n', asm_out_file);
+
+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel1);
+
+      if (MEM_P (call_op))
+        {
+          struct ix86_address parts;
+          rtx addr = XEXP (call_op, 0);
+          if (ix86_decompose_address (addr, &parts)
+              && parts.base == stack_pointer_rtx)
+            {
+              /* Since call will adjust stack by -UNITS_PER_WORD,
+                 we must convert "disp(stack, index, scale)" to
+                 "disp+UNITS_PER_WORD(stack, index, scale)".  */
+              if (parts.index)
+                {
+                  addr = gen_rtx_MULT (Pmode, parts.index,
+                                       GEN_INT (parts.scale));
+                  addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,
+                                       addr);
+                }
+              else
+                addr = stack_pointer_rtx;
+
+              rtx disp;
+              if (parts.disp != NULL_RTX)
+                disp = plus_constant (Pmode, parts.disp,
+                                      UNITS_PER_WORD);
+              else
+                disp = GEN_INT (UNITS_PER_WORD);
+
+              addr = gen_rtx_PLUS (Pmode, addr, disp);
+              call_op = gen_rtx_MEM (GET_MODE (call_op), addr);
+            }
+        }
+
+      if (regno < 0)
+        output_asm_insn (push_buf, &call_op);
+
+      if (thunk_name != NULL)
+        fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+      else
+        output_indirect_thunk (regno);
+
+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
+
+      /* Call.  */
+      fputs ("\tcall\t", asm_out_file);
+      assemble_name_raw (asm_out_file, indirectlabel1);
+      fputc ('\n', asm_out_file);
+    }
+}
+
+const char *
+ix86_output_indirect_jmp (rtx call_op, bool ret_p)
+{
+  if (cfun->machine->indirect_branch_type != indirect_branch_keep)
+    {
+      /* We can't have red-zone if this isn't a function return since
+        "call" in the indirect thunk pushes the return address onto
+        stack, destroying red-zone.  */
+      if (!ret_p && ix86_red_zone_size != 0)
+        gcc_unreachable ();
+
+      ix86_output_indirect_branch (call_op, "%0", true);
+      return "";
+    }
+  else
+    return "jmp\t%A0";
+}
+
 /* Return true if the function being called was marked with attribute "noplt"
    or using -fno-plt and we are compiling for non-PIC and x86_64.  We need to
    handle the non-PIC case in the backend because there is no easy interface
@@ -25080,12 +25465,43 @@ ix86_nopic_noplt_attribute_p (rtx call_op)
   return false;
 }
 
+const char *
+ix86_output_function_return (bool long_p)
+{
+  if (cfun->machine->function_return_type != indirect_branch_keep)
+    {
+      char thunk_name[32];
+
+      if (cfun->machine->function_return_type
+          != indirect_branch_thunk_inline)
+        {
+          bool need_thunk = (cfun->machine->function_return_type
+                             == indirect_branch_thunk);
+          indirect_thunk_name (thunk_name, -1, true);
+          indirect_thunk_needed |= need_thunk;
+          fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+        }
+      else
+        output_indirect_thunk (-1);
+
+      return "";
+    }
+
+  if (!long_p)
+    return "ret";
+
+  return "rep%; ret";
+}
+
 /* Output the assembly for a call instruction.  */
 
 const char *
 ix86_output_call_insn (rtx insn, rtx call_op)
 {
   bool direct_p = constant_call_address_operand (call_op, VOIDmode);
+  bool output_indirect_p
+      = (!TARGET_SEH
+         && cfun->machine->indirect_branch_type != indirect_branch_keep);
   bool seh_nop_p = false;
   const char *xasm;
 
@@ -25100,9 +25516,17 @@ ix86_output_call_insn (rtx insn, rtx call_op)
       else if (TARGET_SEH)
 	xasm = "rex.W jmp %A0";
       else
-	xasm = "jmp\t%A0";
+        {
+          if (output_indirect_p)
+            xasm = "%0";
+          else
+            xasm = "jmp\t%A0";
+        }
 
-      output_asm_insn (xasm, &call_op);
+      if (output_indirect_p && !direct_p)
+        ix86_output_indirect_branch (call_op, xasm, true);
+      else
+        output_asm_insn (xasm, &call_op);
       return "";
     }
 
@@ -25141,9 +25565,17 @@ ix86_output_call_insn (rtx insn, rtx call_op)
   else if (direct_p)
     xasm = "call\t%P0";
   else
-    xasm = "call\t%A0";
+    {
+      if (output_indirect_p)
+        xasm = "%0";
+      else
+        xasm = "call\t%A0";
+    }
 
-  output_asm_insn (xasm, &call_op);
+  if (output_indirect_p && !direct_p)
+    ix86_output_indirect_branch (call_op, xasm, false);
+  else
+    output_asm_insn (xasm, &call_op);
 
   if (seh_nop_p)
     return "nop";
@@ -38714,7 +39146,7 @@ ix86_handle_struct_attribute (tree *node, tree name,
 
 static tree
 ix86_handle_fndecl_attribute (tree *node, tree name,
-                              tree args ATTRIBUTE_UNUSED,
+                              tree args,
                               int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
 {
   if (TREE_CODE (*node) != FUNCTION_DECL)
@@ -38723,6 +39155,51 @@ ix86_handle_fndecl_attribute (tree *node, tree name,
                name);
       *no_add_attrs = true;
     }
+
+  if (is_attribute_p ("indirect_branch", name))
+    {
+      tree cst = TREE_VALUE (args);
+      if (TREE_CODE (cst) != STRING_CST)
+        {
+          warning (OPT_Wattributes,
+                   "%qE attribute requires a string constant argument",
+                   name);
+          *no_add_attrs = true;
+        }
+      else if (strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+               && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+               && strcmp (TREE_STRING_POINTER (cst), "thunk-inline") != 0
+               && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+        {
+          warning (OPT_Wattributes,
+                   "argument to %qE attribute is not "
+                   "(keep|thunk|thunk-inline|thunk-extern)", name);
+          *no_add_attrs = true;
+        }
+    }
+
+  if (is_attribute_p ("function_return", name))
+    {
+      tree cst = TREE_VALUE (args);
+      if (TREE_CODE (cst) != STRING_CST)
+        {
+          warning (OPT_Wattributes,
+                   "%qE attribute requires a string constant argument",
+                   name);
+          *no_add_attrs = true;
+        }
+      else if (strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+               && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+               && strcmp (TREE_STRING_POINTER (cst), "thunk-inline") != 0
+               && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+        {
+          warning (OPT_Wattributes,
+                   "argument to %qE attribute is not "
+                   "(keep|thunk|thunk-inline|thunk-extern)", name);
+          *no_add_attrs = true;
+        }
+    }
+
   return NULL_TREE;
 }
 
@@ -42418,6 +42895,10 @@ static const struct attribute_spec ix86_attribute_table[] =
     false },
   { "callee_pop_aggregate_return", 1, 1, false, true, true,
     ix86_handle_callee_pop_aggregate_return, true },
+  { "indirect_branch", 1, 1, true, false, false,
+    ix86_handle_fndecl_attribute, false },
+  { "function_return", 1, 1, true, false, false,
+    ix86_handle_fndecl_attribute, false },
   /* End element.  */
   { NULL,        0, 0, false, false, false, NULL, false }
 };
diff --git a/gcc-4.9/gcc/config/i386/i386.h b/gcc-4.9/gcc/config/i386/i386.h
index f6b169c24..7e439a1e1 100644
--- a/gcc-4.9/gcc/config/i386/i386.h
+++ b/gcc-4.9/gcc/config/i386/i386.h
@@ -536,7 +536,7 @@ extern tree x86_mfence;
 #define TARGET_SUBTARGET64_DEFAULT 0
 #define TARGET_SUBTARGET64_ISA_DEFAULT 0
 
-/* Replace MACH-O, ifdefs by in-line tests, where possible. 
+/* Replace MACH-O, ifdefs by in-line tests, where possible.
    (a) Macros defined in config/i386/darwin.h  */
 #define TARGET_MACHO 0
 #define TARGET_MACHO_BRANCH_ISLANDS 0
@@ -1541,11 +1541,11 @@ enum reg_class
 /* If defined, the maximum amount of space required for outgoing arguments
    will be computed and placed into the variable `crtl->outgoing_args_size'.
    No space will be pushed onto the stack for each call; instead, the
-   function prologue should increase the stack frame size by this amount.  
+   function prologue should increase the stack frame size by this amount.
 
    In 32bit mode enabling argument accumulation results in about 5% code size
    growth becuase move instructions are less compact than push.  In 64bit
-   mode the difference is less drastic but visible.  
+   mode the difference is less drastic but visible.
 
    FIXME: Unlike earlier implementations, the size of unwind info seems to
    actually grow with accumulation.  Is that because accumulated args
@@ -2204,7 +2204,7 @@ do {									\
 #define DEFAULT_LARGE_SECTION_THRESHOLD 65536
 
 /* Which processor to tune code generation for.  These must be in sync
-   with processor_target_table in i386.c.  */ 
+   with processor_target_table in i386.c.  */
 
 enum processor_type
 {
@@ -2369,9 +2369,56 @@ enum avx_u128_state
 
 #define FASTCALL_PREFIX '@'
 
+#ifndef USED_FOR_TARGET
+/* Structure describing stack frame layout.
+   Stack grows downward:
+
+   [arguments]
+                                       <- ARG_POINTER
+   saved pc
+
+   saved static chain                  if ix86_static_chain_on_stack
+
+   saved frame pointer                 if frame_pointer_needed
+                                       <- HARD_FRAME_POINTER
+   [saved regs]
+                                       <- regs_save_offset
+   [padding0]
+
+   [saved SSE regs]
+                                       <- sse_regs_save_offset
+   [padding1]          |
+                      |                <- FRAME_POINTER
+   [va_arg registers]  |
+                      |
+   [frame]            |
+                      |
+   [padding2]         | = to_allocate
+                                       <- STACK_POINTER
+  */
+struct GTY(()) ix86_frame
+{
+  int nsseregs;
+  int nregs;
+  int va_arg_size;
+  int red_zone_size;
+  int outgoing_arguments_size;
+
+  /* The offsets relative to ARG_POINTER.  */
+  HOST_WIDE_INT frame_pointer_offset;
+  HOST_WIDE_INT hard_frame_pointer_offset;
+  HOST_WIDE_INT stack_pointer_offset;
+  HOST_WIDE_INT hfp_save_offset;
+  HOST_WIDE_INT reg_save_offset;
+  HOST_WIDE_INT sse_reg_save_offset;
+
+  /* When save_regs_using_mov is set, emit prologue using
+     move instead of push instructions.  */
+  bool save_regs_using_mov;
+};
+
 /* Machine specific frame tracking during prologue/epilogue generation.  */
 
-#ifndef USED_FOR_TARGET
 struct GTY(()) machine_frame_state
 {
   /* This pair tracks the currently active CFA as reg+offset.  When reg
@@ -2417,6 +2464,9 @@ struct GTY(()) machine_function {
   int varargs_fpr_size;
   int optimize_mode_switching[MAX_386_ENTITIES];
 
+  /* Cached initial frame layout for the current function.  */
+  struct ix86_frame frame;
+
   /* Number of saved registers USE_FAST_PROLOGUE_EPILOGUE
      has been computed for.  */
   int use_fast_prologue_epilogue_nregs;
@@ -2460,6 +2510,16 @@ struct GTY(()) machine_function {
   /* If true, it is safe to not save/restore DRAP register.  */
   BOOL_BITFIELD no_drap_save_restore : 1;
 
+  /* How to generate indirec branch.  */
+  ENUM_BITFIELD(indirect_branch) indirect_branch_type : 3;
+
+  /* If true, the current function has local indirect jumps, like
+     "indirect_jump" or "tablejump".  */
+  BOOL_BITFIELD has_local_indirect_jump : 1;
+
+  /* How to generate function return.  */
+  ENUM_BITFIELD(indirect_branch) function_return_type : 3;
+
   /* During prologue/epilogue generation, the current frame state.
      Otherwise, the frame state at the end of the prologue.  */
   struct machine_frame_state fs;
@@ -2484,6 +2544,7 @@ struct GTY(()) machine_function {
 #define ix86_current_function_calls_tls_descriptor \
   (ix86_tls_descriptor_calls_expanded_in_cfun && df_regs_ever_live_p (SP_REG))
 #define ix86_static_chain_on_stack (cfun->machine->static_chain_on_stack)
+#define ix86_red_zone_size (cfun->machine->frame.red_zone_size)
 
 /* Control behavior of x86_file_start.  */
 #define X86_FILE_START_VERSION_DIRECTIVE false
diff --git a/gcc-4.9/gcc/config/i386/i386.md b/gcc-4.9/gcc/config/i386/i386.md
index d3caabfd0..e32ba52a6 100644
--- a/gcc-4.9/gcc/config/i386/i386.md
+++ b/gcc-4.9/gcc/config/i386/i386.md
@@ -11142,12 +11142,13 @@
 {
   if (TARGET_X32)
     operands[0] = convert_memory_address (word_mode, operands[0]);
+  cfun->machine->has_local_indirect_jump = true;
 })
 
 (define_insn "*indirect_jump"
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rw"))]
   ""
-  "jmp\t%A0"
+  "* return ix86_output_indirect_jmp (operands[0], false);"
   [(set_attr "type" "ibr")
    (set_attr "length_immediate" "0")])
 
@@ -11190,13 +11191,14 @@
 
   if (TARGET_X32)
     operands[0] = convert_memory_address (word_mode, operands[0]);
+  cfun->machine->has_local_indirect_jump = true;
 })
 
 (define_insn "*tablejump_1"
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rw"))
    (use (label_ref (match_operand 1)))]
   ""
-  "jmp\t%A0"
+  "* return ix86_output_indirect_jmp (operands[0], false);"
   [(set_attr "type" "ibr")
    (set_attr "length_immediate" "0")])
 
@@ -11583,7 +11585,7 @@
 (define_insn "simple_return_internal"
   [(simple_return)]
   "reload_completed"
-  "ret"
+  "* return ix86_output_function_return (false);" 
   [(set_attr "length" "1")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
@@ -11596,7 +11598,7 @@
   [(simple_return)
    (unspec [(const_int 0)] UNSPEC_REP)]
   "reload_completed"
-  "rep\;ret"
+  "* return ix86_output_function_return (true);"
   [(set_attr "length" "2")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
@@ -11617,7 +11619,7 @@
   [(simple_return)
    (use (match_operand:SI 0 "register_operand" "r"))]
   "reload_completed"
-  "jmp\t%A0"
+  "* return ix86_output_indirect_jmp (operands[0], true);"
   [(set_attr "type" "ibr")
    (set_attr "length_immediate" "0")])
 
diff --git a/gcc-4.9/gcc/config/i386/i386.opt b/gcc-4.9/gcc/config/i386/i386.opt
index 0f463a238..3b4a86066 100644
--- a/gcc-4.9/gcc/config/i386/i386.opt
+++ b/gcc-4.9/gcc/config/i386/i386.opt
@@ -794,3 +794,43 @@ Enum(stack_protector_guard) String(tls) Value(SSP_TLS)
 
 EnumValue
 Enum(stack_protector_guard) String(global) Value(SSP_GLOBAL)
+
+mindirect-branch=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(ix86_indirect_branch) Init(indirect_branch_keep)
+Update indirect call and jump.
+
+mfunction-return=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(ix86_function_return) Init(indirect_branch_keep)
+Update function return.
+
+Enum
+Name(indirect_branch) Type(enum indirect_branch)
+Known indirect branch choices (for use with the -mindirect-branch=/-mfunction-return= options):
+
+EnumValue
+Enum(indirect_branch) String(keep) Value(indirect_branch_keep)
+
+EnumValue
+Enum(indirect_branch) String(thunk) Value(indirect_branch_thunk)
+
+EnumValue
+Enum(indirect_branch) String(thunk-inline) Value(indirect_branch_thunk_inline)
+
+EnumValue
+Enum(indirect_branch) String(thunk-extern) Value(indirect_branch_thunk_extern)
+
+mindirect-branch-loop=
+Target Report RejectNegative Joined Enum(indirect_branch_loop) Var(ix86_indirect_branch_loop) Undocumented Init(indirect_branch_loop_lfence)
+
+Enum
+Name(indirect_branch_loop) Type(enum indirect_branch_loop)
+Known loop choices (for use with the -mindirect-branch-loop= option):
+
+EnumValue
+Enum(indirect_branch_loop) String(lfence) Value(indirect_branch_loop_lfence)
+
+EnumValue
+Enum(indirect_branch_loop) String(pause) Value(indirect_branch_loop_pause)
+
+EnumValue
+Enum(indirect_branch_loop) String(nop) Value(indirect_branch_loop_nop)
