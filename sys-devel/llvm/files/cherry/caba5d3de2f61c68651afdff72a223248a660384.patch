commit caba5d3de2f61c68651afdff72a223248a660384
Author: Robert Lougher <rob.lougher@gmail.com>
Date:   Wed Dec 14 20:07:49 2016 +0000

    [InstCombine] Folding of a binop with RHS const should merge the debug locations
    
    If all the operands to a phi node are a binop with a RHS constant, instcombine
    will try to pull them through the phi node, combining them into a single
    operation. When it does this, the debug location of the new op should be the
    merged debug locations of the phi node arguments.
    
    Patch 7 of 8 for D26256.  Folding of a binop with RHS constant.
    
    Differential Revision: https://reviews.llvm.org/D26256
    
    
    git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@289699 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Transforms/InstCombine/InstCombinePHI.cpp b/lib/Transforms/InstCombine/InstCombinePHI.cpp
index 2c5b5f9d08f..5ef509cd9aa 100644
--- a/lib/Transforms/InstCombine/InstCombinePHI.cpp
+++ b/lib/Transforms/InstCombine/InstCombinePHI.cpp
@@ -576,7 +576,7 @@ Instruction *InstCombiner::FoldPHIArgOpIntoPHI(PHINode &PN) {
     for (unsigned i = 1, e = PN.getNumIncomingValues(); i != e; ++i)
       BinOp->andIRFlags(PN.getIncomingValue(i));
 
-    BinOp->setDebugLoc(FirstInst->getDebugLoc());
+    BinOp->setDebugLoc(PHIArgMergedDebugLoc(PN));
     return BinOp;
   }
 
diff --git a/test/DebugInfo/Generic/instcombine-phi.ll b/test/DebugInfo/Generic/instcombine-phi.ll
index c7ccc95f058..29a921184f6 100644
--- a/test/DebugInfo/Generic/instcombine-phi.ll
+++ b/test/DebugInfo/Generic/instcombine-phi.ll
@@ -214,6 +214,47 @@ if.end:                                           ; preds = %if.else, %if.then
   ret i64 %r.0, !dbg !44
 }
 
+; Test folding of a binary op with a RHS constant.  Generated from source:
+
+; extern int foo(void);
+; extern int bar(void);
+; 
+; int binop_const(int a) {
+;   int r;
+;   if(a)
+;     r = foo() - 5;
+;   else
+;     r = bar() - 5;
+;   return r;
+; }
+
+; CHECK: define i32 @binop_const
+; CHECK-LABEL: if.end:
+; CHECK: %[[PHI:.*]] = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
+; CHECK: add nsw i32 %[[PHI]], -5
+; CHECK-NOT: !dbg
+; CHECK: ret i32
+
+define i32 @binop_const(i32 %a) !dbg !45 {
+entry:
+  %tobool = icmp ne i32 %a, 0, !dbg !46
+  br i1 %tobool, label %if.then, label %if.else, !dbg !46
+
+if.then:                                          ; preds = %entry
+  %call = call i32 @foo(), !dbg !47
+  %sub = sub nsw i32 %call, 5, !dbg !48
+  br label %if.end, !dbg !49
+
+if.else:                                          ; preds = %entry
+  %call1 = call i32 @bar(), !dbg !50
+  %sub2 = sub nsw i32 %call1, 5, !dbg !51
+  br label %if.end
+
+if.end:                                           ; preds = %if.else, %if.then
+  %r.0 = phi i32 [ %sub, %if.then ], [ %sub2, %if.else ]
+  ret i32 %r.0, !dbg !52
+}
+
 declare i32 @foo()
 declare i32 @bar()
 declare i64 @foo2()
@@ -268,3 +309,11 @@ declare i32* @bar3()
 !42 = !DILocation(line: 46, column: 5, scope: !39)
 !43 = !DILocation(line: 48, column: 9, scope: !39)
 !44 = !DILocation(line: 49, column: 3, scope: !39)
+!45 = distinct !DISubprogram(name: "binop_const", scope: !1, file: !1, line: 52, type: !7, isLocal: false, isDefinition: true, scopeLine: 52, flags: DIFlagPrototyped, isOptimized: false, unit: !0, variables: !2)
+!46 = !DILocation(line: 54, column: 6, scope: !45)
+!47 = !DILocation(line: 55, column: 9, scope: !45)
+!48 = !DILocation(line: 55, column: 15, scope: !45)
+!49 = !DILocation(line: 55, column: 5, scope: !45)
+!50 = !DILocation(line: 57, column: 9, scope: !45)
+!51 = !DILocation(line: 57, column: 15, scope: !45)
+!52 = !DILocation(line: 58, column: 3, scope: !45)
