commit 16748767563bb9bcb1e1c3e42c35d44924d464d0
Author: Sanjay Patel <spatel@rotateright.com>
Date:   Mon Feb 5 17:16:50 2018 +0000

    [InstCombine] only allow narrow/wide evaluation of values with >1 use if that user is a binop
    
    There was a logic hole in D42739 / rL324014 because we're not accounting for select and phi
    instructions that might have repeated operands. This is likely a source of an infinite loop.
    I haven't manufactured a test case to prove that, but it should be safe to speculatively limit
    this transform to binops while we try to create that test.
    
    
    git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@324252 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Transforms/InstCombine/InstCombineCasts.cpp b/lib/Transforms/InstCombine/InstCombineCasts.cpp
index 18cd0000f98..9046c36dee8 100644
--- a/lib/Transforms/InstCombine/InstCombineCasts.cpp
+++ b/lib/Transforms/InstCombine/InstCombineCasts.cpp
@@ -327,12 +327,14 @@ static bool canNotEvaluateInType(Value *V, Type *Ty) {
   if (!isa<Instruction>(V))
     return true;
   // We can't extend or shrink something that has multiple uses -- unless those
-  // multiple uses are all in the same instruction -- doing so would require
-  // duplicating the instruction which isn't profitable.
-  if (!V->hasOneUse())
+  // multiple uses are all in the same binop instruction -- doing so would
+  // require duplicating the instruction which isn't profitable.
+  if (!V->hasOneUse()) {
+    if (!match(V->user_back(), m_BinOp()))
+      return true;
     if (any_of(V->users(), [&](User *U) { return U != V->user_back(); }))
       return true;
-
+  }
   return false;
 }
 
