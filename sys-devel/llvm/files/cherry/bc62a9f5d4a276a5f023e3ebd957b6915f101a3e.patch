commit bc62a9f5d4a276a5f023e3ebd957b6915f101a3e
Author: Davide Italiano <davide@freebsd.org>
Date:   Fri Jul 28 03:10:43 2017 +0000

    [JumpThreading] Stop falsely preserving LazyValueInfo.
    
    JumpThreading claims to preserve LVI, but it doesn't preserve
    the analyses which LVI holds a reference to (e.g. the Dominator).
    In the current pass manager infrastructure, after JT runs, the
    PM frees these analyses (including DominatorTree) but preserves
    LVI.
    
    CorrelatedValuePropagation runs immediately after and queries
    a corrupted domtree, causing weird miscompiles.
    
    This commit disables the preservation of LVI for the time being.
    Eventually, we should either move LVI to a proper dependency
    tracking mechanism (i.e. an analyses shouldn't hold references
    to other analyses and compute them on demand if needed), or
    we should teach all the passes preserving LVI to preserve the
    analyses LVI depends on.
    
    The new pass manager has a mechanism to invalidate LVI in case
    one of the analyses it depends on becomes invalid, so this problem
    shouldn't exist (at least not in this immediate form), but handling
    of analyses holding references is still a very delicate subject.
    
    Fixes PR33917 (and rustc).
    
    git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@309355 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Transforms/Scalar/JumpThreading.cpp b/lib/Transforms/Scalar/JumpThreading.cpp
index 0da003b14ed..dc9143bebc4 100644
--- a/lib/Transforms/Scalar/JumpThreading.cpp
+++ b/lib/Transforms/Scalar/JumpThreading.cpp
@@ -102,7 +102,6 @@ namespace {
         AU.addRequired<DominatorTreeWrapperPass>();
       AU.addRequired<AAResultsWrapperPass>();
       AU.addRequired<LazyValueInfoWrapperPass>();
-      AU.addPreserved<LazyValueInfoWrapperPass>();
       AU.addPreserved<GlobalsAAWrapperPass>();
       AU.addRequired<TargetLibraryInfoWrapperPass>();
     }
diff --git a/test/Transforms/JumpThreading/pr33917.ll b/test/Transforms/JumpThreading/pr33917.ll
new file mode 100644
index 00000000000..30652279a0e
--- /dev/null
+++ b/test/Transforms/JumpThreading/pr33917.ll
@@ -0,0 +1,57 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt -jump-threading -correlated-propagation %s -S | FileCheck %s
+
+target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+declare i8* @foo()
+
+declare i32 @rust_eh_personality() unnamed_addr
+
+; Function Attrs: nounwind
+declare void @llvm.assume(i1) #0
+
+define void @patatino() personality i32 ()* @rust_eh_personality {
+; CHECK-LABEL: @patatino(
+; CHECK-NEXT:  bb9:
+; CHECK-NEXT:    [[T9:%.*]] = invoke i8* @foo()
+; CHECK-NEXT:    to label [[GOOD:%.*]] unwind label [[BAD:%.*]]
+; CHECK:       bad:
+; CHECK-NEXT:    [[T10:%.*]] = landingpad { i8*, i32 }
+; CHECK-NEXT:    cleanup
+; CHECK-NEXT:    resume { i8*, i32 } [[T10]]
+; CHECK:       good:
+; CHECK-NEXT:    [[T11:%.*]] = icmp ne i8* [[T9]], null
+; CHECK-NEXT:    [[T12:%.*]] = zext i1 [[T11]] to i64
+; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[T12]], 1
+; CHECK-NEXT:    br i1 [[COND]], label [[IF_TRUE:%.*]], label [[DONE:%.*]]
+; CHECK:       if_true:
+; CHECK-NEXT:    call void @llvm.assume(i1 [[T11]])
+; CHECK-NEXT:    br label [[DONE]]
+; CHECK:       done:
+; CHECK-NEXT:    ret void
+;
+bb9:
+  %t9 = invoke i8* @foo()
+  to label %good unwind label %bad
+
+bad:
+  %t10 = landingpad { i8*, i32 }
+  cleanup
+  resume { i8*, i32 } %t10
+
+good:
+  %t11 = icmp ne i8* %t9, null
+  %t12 = zext i1 %t11 to i64
+  %cond = icmp eq i64 %t12, 1
+  br i1 %cond, label %if_true, label %done
+
+if_true:
+  call void @llvm.assume(i1 %t11)
+  br label %done
+
+done:
+  ret void
+}
+
+attributes #0 = { nounwind }
