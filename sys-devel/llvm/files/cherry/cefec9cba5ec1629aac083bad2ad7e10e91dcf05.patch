commit cefec9cba5ec1629aac083bad2ad7e10e91dcf05
Author: George Burgess IV <george.burgess.iv@gmail.com>
Date:   Wed Feb 22 02:35:51 2017 +0000

    Call the correct @llvm.objectsize.
    
    The following code would crash clang:
    
    void foo(unsigned *const __attribute__((pass_object_size(0))));
    void bar(unsigned *i) { foo(i); }
    
    This is because we were always selecting the version of
    `@llvm.objectsize` that takes an i8* in CodeGen. Passing an i32* as an
    i8* makes LLVM very unhappy.
    
    (Yes, I'm surprised that this remained uncaught for so long, too. :) )
    
    As an added bonus, we'll now also use the appropriate address space when
    emitting @llvm.objectsize calls.
    
    
    git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@295805 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/CodeGen/CGBuiltin.cpp b/lib/CodeGen/CGBuiltin.cpp
index f8c6f2bc7d..9f0cfa7db3 100644
--- a/lib/CodeGen/CGBuiltin.cpp
+++ b/lib/CodeGen/CGBuiltin.cpp
@@ -460,13 +460,14 @@ CodeGenFunction::emitBuiltinObjectSize(const Expr *E, unsigned Type,
   if (Type == 3 || E->HasSideEffects(getContext()))
     return getDefaultBuiltinObjectSizeResult(Type, ResType);
 
-  // LLVM only supports 0 and 2, make sure that we pass along that
-  // as a boolean.
+  Value *Ptr = EmitScalarExpr(E);
+  assert(Ptr->getType()->isPointerTy() &&
+         "Non-pointer passed to __builtin_object_size?");
+
+  // LLVM only supports 0 and 2, make sure that we pass along that as a boolean.
   auto *CI = ConstantInt::get(Builder.getInt1Ty(), (Type & 2) >> 1);
-  // FIXME: Get right address space.
-  llvm::Type *Tys[] = {ResType, Builder.getInt8PtrTy(0)};
-  Value *F = CGM.getIntrinsic(Intrinsic::objectsize, Tys);
-  return Builder.CreateCall(F, {EmitScalarExpr(E), CI});
+  Value *F = CGM.getIntrinsic(Intrinsic::objectsize, {ResType, Ptr->getType()});
+  return Builder.CreateCall(F, {Ptr, CI});
 }
 
 // Many of MSVC builtins are on both x64 and ARM; to avoid repeating code, we
diff --git a/test/CodeGen/pass-object-size.c b/test/CodeGen/pass-object-size.c
index 6f5827befa..4842c09c3b 100644
--- a/test/CodeGen/pass-object-size.c
+++ b/test/CodeGen/pass-object-size.c
@@ -369,3 +369,29 @@ void test14(char *c) {
   // CHECK: call void (i8*, i64, ...) @my_sprintf
   my_sprintf(c, 1, 2, 3);
 }
+
+void pass_size_unsigned(unsigned *const PS(0));
+
+// Bug: we weren't lowering to the proper @llvm.objectsize for pointers that
+// don't turn into i8*s, which caused crashes.
+// CHECK-LABEL: define void @test15
+void test15(unsigned *I) {
+  // CHECK: @llvm.objectsize.i64.p0i32
+  // CHECK: call void @pass_size_unsigned
+  pass_size_unsigned(I);
+}
+
+void pass_size_as1(__attribute__((address_space(1))) void *const PS(0));
+
+void pass_size_unsigned_as1(
+    __attribute__((address_space(1))) unsigned *const PS(0));
+
+// CHECK-LABEL: define void @test16
+void test16(__attribute__((address_space(1))) unsigned *I) {
+  // CHECK: call i64 @llvm.objectsize.i64.p1i8
+  // CHECK: call void @pass_size_as1
+  pass_size_as1(I);
+  // CHECK: call i64 @llvm.objectsize.i64.p1i32
+  // CHECK: call void @pass_size_unsigned_as1
+  pass_size_unsigned_as1(I);
+}
