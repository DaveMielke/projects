commit ffaaef68dbab0e872c0e6013836170bb78705a81
Author: Reid Kleckner <rnk@google.com>
Date:   Tue Feb 6 00:47:14 2018 +0000

    Revert "Don't assume a null GV is local for ELF and MachO."
    
    This reverts r323297.
    
    It breaks building grub.
    
    git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@324301 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Target/TargetMachine.cpp b/lib/Target/TargetMachine.cpp
index 76ec541f8b6..ee5b010ecf2 100644
--- a/lib/Target/TargetMachine.cpp
+++ b/lib/Target/TargetMachine.cpp
@@ -137,27 +137,20 @@ bool TargetMachine::shouldAssumeDSOLocal(const Module &M,
   if (TT.isOSBinFormatCOFF() || (TT.isOSWindows() && TT.isOSBinFormatMachO()))
     return true;
 
-  // If GV is null we know that this is a call to an intrinsic. For ELF and
-  // MachO we don't need to assume those are local since the liker can trivially
-  // convert a call to a PLT to a direct call if the target (in the runtime
-  // library) turns out to be local.
-  if (!GV)
-    return false;
-
   // Most PIC code sequences that assume that a symbol is local cannot
   // produce a 0 if it turns out the symbol is undefined. While this
   // is ABI and relocation depended, it seems worth it to handle it
   // here.
-  if (isPositionIndependent() && GV->hasExternalWeakLinkage())
+  if (GV && isPositionIndependent() && GV->hasExternalWeakLinkage())
     return false;
 
-  if (!GV->hasDefaultVisibility())
+  if (GV && !GV->hasDefaultVisibility())
     return true;
 
   if (TT.isOSBinFormatMachO()) {
     if (RM == Reloc::Static)
       return true;
-    return GV->isStrongDefinitionForLinker();
+    return GV && GV->isStrongDefinitionForLinker();
   }
 
   assert(TT.isOSBinFormatELF());
@@ -167,19 +160,19 @@ bool TargetMachine::shouldAssumeDSOLocal(const Module &M,
       RM == Reloc::Static || M.getPIELevel() != PIELevel::Default;
   if (IsExecutable) {
     // If the symbol is defined, it cannot be preempted.
-    if (!GV->isDeclarationForLinker())
+    if (GV && !GV->isDeclarationForLinker())
       return true;
 
     // A symbol marked nonlazybind should not be accessed with a plt. If the
     // symbol turns out to be external, the linker will convert a direct
     // access to an access via the plt, so don't assume it is local.
-    const Function *F = dyn_cast<Function>(GV);
+    const Function *F = dyn_cast_or_null<Function>(GV);
     if (F && F->hasFnAttribute(Attribute::NonLazyBind))
       return false;
 
-    bool IsTLS = GV->isThreadLocal();
+    bool IsTLS = GV && GV->isThreadLocal();
     bool IsAccessViaCopyRelocs =
-        Options.MCOptions.MCPIECopyRelocations && isa<GlobalVariable>(GV);
+        Options.MCOptions.MCPIECopyRelocations && GV && isa<GlobalVariable>(GV);
     Triple::ArchType Arch = TT.getArch();
     bool IsPPC =
         Arch == Triple::ppc || Arch == Triple::ppc64 || Arch == Triple::ppc64le;
diff --git a/test/CodeGen/X86/finite-libcalls.ll b/test/CodeGen/X86/finite-libcalls.ll
index f3d336083b2..d4b79acbd7e 100644
--- a/test/CodeGen/X86/finite-libcalls.ll
+++ b/test/CodeGen/X86/finite-libcalls.ll
@@ -9,7 +9,7 @@
 define float @exp_f32(float %x) #0 {
 ; GNU-LABEL: exp_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __expf_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __expf_finite # TAILCALL
 ;
 ; WIN-LABEL: exp_f32:
 ; WIN:       # %bb.0:
@@ -25,7 +25,7 @@ define float @exp_f32(float %x) #0 {
 define double @exp_f64(double %x) #0 {
 ; GNU-LABEL: exp_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __exp_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __exp_finite # TAILCALL
 ;
 ; WIN-LABEL: exp_f64:
 ; WIN:       # %bb.0:
@@ -72,7 +72,7 @@ define x86_fp80 @exp_f80(x86_fp80 %x) #0 {
 define float @exp2_f32(float %x) #0 {
 ; GNU-LABEL: exp2_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __exp2f_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __exp2f_finite # TAILCALL
 ;
 ; WIN-LABEL: exp2_f32:
 ; WIN:       # %bb.0:
@@ -88,7 +88,7 @@ define float @exp2_f32(float %x) #0 {
 define double @exp2_f64(double %x) #0 {
 ; GNU-LABEL: exp2_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __exp2_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __exp2_finite # TAILCALL
 ;
 ; WIN-LABEL: exp2_f64:
 ; WIN:       # %bb.0:
@@ -135,7 +135,7 @@ define x86_fp80 @exp2_f80(x86_fp80 %x) #0 {
 define float @log_f32(float %x) #0 {
 ; GNU-LABEL: log_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __logf_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __logf_finite # TAILCALL
 ;
 ; WIN-LABEL: log_f32:
 ; WIN:       # %bb.0:
@@ -151,7 +151,7 @@ define float @log_f32(float %x) #0 {
 define double @log_f64(double %x) #0 {
 ; GNU-LABEL: log_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __log_finite # TAILCALL
 ;
 ; WIN-LABEL: log_f64:
 ; WIN:       # %bb.0:
@@ -198,7 +198,7 @@ define x86_fp80 @log_f80(x86_fp80 %x) #0 {
 define float @log2_f32(float %x) #0 {
 ; GNU-LABEL: log2_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log2f_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __log2f_finite # TAILCALL
 ;
 ; WIN-LABEL: log2_f32:
 ; WIN:       # %bb.0:
@@ -214,7 +214,7 @@ define float @log2_f32(float %x) #0 {
 define double @log2_f64(double %x) #0 {
 ; GNU-LABEL: log2_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log2_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __log2_finite # TAILCALL
 ;
 ; WIN-LABEL: log2_f64:
 ; WIN:       # %bb.0:
@@ -261,7 +261,7 @@ define x86_fp80 @log2_f80(x86_fp80 %x) #0 {
 define float @log10_f32(float %x) #0 {
 ; GNU-LABEL: log10_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log10f_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __log10f_finite # TAILCALL
 ;
 ; WIN-LABEL: log10_f32:
 ; WIN:       # %bb.0:
@@ -277,7 +277,7 @@ define float @log10_f32(float %x) #0 {
 define double @log10_f64(double %x) #0 {
 ; GNU-LABEL: log10_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log10_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __log10_finite # TAILCALL
 ;
 ; WIN-LABEL: log10_f64:
 ; WIN:       # %bb.0:
@@ -325,7 +325,7 @@ define float @pow_f32(float %x) #0 {
 ; GNU-LABEL: pow_f32:
 ; GNU:       # %bb.0:
 ; GNU-NEXT:    movaps %xmm0, %xmm1
-; GNU-NEXT:    jmp __powf_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __powf_finite # TAILCALL
 ;
 ; WIN-LABEL: pow_f32:
 ; WIN:       # %bb.0:
@@ -344,7 +344,7 @@ define double @pow_f64(double %x) #0 {
 ; GNU-LABEL: pow_f64:
 ; GNU:       # %bb.0:
 ; GNU-NEXT:    movaps %xmm0, %xmm1
-; GNU-NEXT:    jmp __pow_finite@PLT # TAILCALL
+; GNU-NEXT:    jmp __pow_finite # TAILCALL
 ;
 ; WIN-LABEL: pow_f64:
 ; WIN:       # %bb.0:
diff --git a/test/CodeGen/X86/fp-intrinsics.ll b/test/CodeGen/X86/fp-intrinsics.ll
index 9816875ebad..eae3955adc3 100644
--- a/test/CodeGen/X86/fp-intrinsics.ll
+++ b/test/CodeGen/X86/fp-intrinsics.ll
@@ -245,7 +245,7 @@ entry:
 ; Verify that fma(3.5) isn't simplified when the rounding mode is
 ; unknown.
 ; CHECK-LABEL: f17
-; FMACALL32: jmp fmaf@PLT  # TAILCALL
+; FMACALL32: jmp fmaf  # TAILCALL
 ; FMA32: vfmadd213ss
 define float @f17() {
 entry:
@@ -261,7 +261,7 @@ entry:
 ; Verify that fma(42.1) isn't simplified when the rounding mode is
 ; unknown.
 ; CHECK-LABEL: f18
-; FMACALL64: jmp fma@PLT  # TAILCALL
+; FMACALL64: jmp fma  # TAILCALL
 ; FMA64: vfmadd213sd
 define double @f18() {
 entry:
diff --git a/test/CodeGen/X86/half.ll b/test/CodeGen/X86/half.ll
index e0270173aaf..7770b9936ea 100644
--- a/test/CodeGen/X86/half.ll
+++ b/test/CodeGen/X86/half.ll
@@ -75,7 +75,7 @@ define float @test_extend32(half* %addr) #0 {
 ; CHECK-LIBCALL-LABEL: test_extend32:
 ; CHECK-LIBCALL:       # %bb.0:
 ; CHECK-LIBCALL-NEXT:    movzwl (%rdi), %edi
-; CHECK-LIBCALL-NEXT:    jmp __gnu_h2f_ieee@PLT # TAILCALL
+; CHECK-LIBCALL-NEXT:    jmp __gnu_h2f_ieee # TAILCALL
 ;
 ; BWON-F16C-LABEL: test_extend32:
 ; BWON-F16C:       # %bb.0:
diff --git a/test/CodeGen/X86/memset-nonzero.ll b/test/CodeGen/X86/memset-nonzero.ll
index e7192b0e136..37b98b40192 100644
--- a/test/CodeGen/X86/memset-nonzero.ll
+++ b/test/CodeGen/X86/memset-nonzero.ll
@@ -394,7 +394,7 @@ define void @memset_256_nonconst_bytes(i8* %x, i8 %c) {
 ; SSE-LABEL: memset_256_nonconst_bytes:
 ; SSE:       # %bb.0:
 ; SSE-NEXT:    movl $256, %edx # imm = 0x100
-; SSE-NEXT:    jmp memset@PLT # TAILCALL
+; SSE-NEXT:    jmp memset # TAILCALL
 ;
 ; SSE2FAST-LABEL: memset_256_nonconst_bytes:
 ; SSE2FAST:       # %bb.0:
diff --git a/test/CodeGen/X86/negative-sin.ll b/test/CodeGen/X86/negative-sin.ll
index 9f00dbb01ff..c30cd2741e6 100644
--- a/test/CodeGen/X86/negative-sin.ll
+++ b/test/CodeGen/X86/negative-sin.ll
@@ -28,7 +28,7 @@ define double @strict(double %e) nounwind {
 define double @fast(double %e) nounwind {
 ; CHECK-LABEL: fast:
 ; CHECK:       # %bb.0:
-; CHECK-NEXT:    jmp sin@PLT # TAILCALL
+; CHECK-NEXT:    jmp sin # TAILCALL
   %f = fsub fast double 0.0, %e
   %g = call double @sin(double %f) readonly
   %h = fsub fast double 0.0, %g
@@ -40,7 +40,7 @@ define double @fast(double %e) nounwind {
 define double @nsz(double %e) nounwind {
 ; CHECK-LABEL: nsz:
 ; CHECK:       # %bb.0:
-; CHECK-NEXT:    jmp sin@PLT # TAILCALL
+; CHECK-NEXT:    jmp sin # TAILCALL
   %f = fsub nsz double 0.0, %e
   %g = call double @sin(double %f) readonly
   %h = fsub nsz double 0.0, %g
@@ -88,7 +88,7 @@ define double @semi_strict2(double %e) nounwind {
 define double @fn_attr(double %e) nounwind #0 {
 ; CHECK-LABEL: fn_attr:
 ; CHECK:       # %bb.0:
-; CHECK-NEXT:    jmp sin@PLT # TAILCALL
+; CHECK-NEXT:    jmp sin # TAILCALL
   %f = fsub double 0.0, %e
   %g = call double @sin(double %f) readonly
   %h = fsub double 0.0, %g
diff --git a/test/CodeGen/X86/vector-half-conversions.ll b/test/CodeGen/X86/vector-half-conversions.ll
index 51a4dae355e..94dc5b9e001 100644
--- a/test/CodeGen/X86/vector-half-conversions.ll
+++ b/test/CodeGen/X86/vector-half-conversions.ll
@@ -2953,7 +2953,7 @@ define void @store_cvt_16f32_to_16i16(<16 x float> %a0, <16 x i16>* %a1) nounwin
 define i16 @cvt_f64_to_i16(double %a0) nounwind {
 ; ALL-LABEL: cvt_f64_to_i16:
 ; ALL:       # %bb.0:
-; ALL-NEXT:    jmp __truncdfhf2@PLT # TAILCALL
+; ALL-NEXT:    jmp __truncdfhf2 # TAILCALL
   %1 = fptrunc double %a0 to half
   %2 = bitcast half %1 to i16
   ret i16 %2
