commit 87b8537d3eb21a2afa0ef8673de958ed46ca4af0
Author: Peter Collingbourne <peter@pcc.me.uk>
Date:   Fri Nov 16 20:08:54 2018 +0000

    AArch64: Emit a call frame instruction for the shadow call stack register.
    
    When unwinding past a function that uses shadow call stack, we must
    subtract 8 from the value of the x18 register. This patch causes us
    to emit a call frame instruction that causes that to happen.
    
    Differential Revision: https://reviews.llvm.org/D54609
    
    git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@347089 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Target/AArch64/AArch64FrameLowering.cpp b/lib/Target/AArch64/AArch64FrameLowering.cpp
index 7df25bb424a..d32ff827f3d 100644
--- a/lib/Target/AArch64/AArch64FrameLowering.cpp
+++ b/lib/Target/AArch64/AArch64FrameLowering.cpp
@@ -590,10 +590,12 @@ static MachineBasicBlock::iterator convertCalleeSaveRestoreToSPPrePostIncDec(
     const DebugLoc &DL, const TargetInstrInfo *TII, int CSStackSizeInc,
     bool NeedsWinCFI, bool InProlog = true) {
   // Ignore instructions that do not operate on SP, i.e. shadow call stack
-  // instructions.
+  // instructions and associated CFI instruction.
   while (MBBI->getOpcode() == AArch64::STRXpost ||
-         MBBI->getOpcode() == AArch64::LDRXpre) {
-    assert(MBBI->getOperand(0).getReg() != AArch64::SP);
+         MBBI->getOpcode() == AArch64::LDRXpre ||
+         MBBI->getOpcode() == AArch64::CFI_INSTRUCTION) {
+    if (MBBI->getOpcode() != AArch64::CFI_INSTRUCTION)
+      assert(MBBI->getOperand(0).getReg() != AArch64::SP);
     ++MBBI;
   }
   unsigned NewOpc;
@@ -690,9 +692,11 @@ static void fixupCalleeSaveRestoreStackOffset(MachineInstr &MI,
   unsigned Opc = MI.getOpcode();
 
   // Ignore instructions that do not operate on SP, i.e. shadow call stack
-  // instructions.
-  if (Opc == AArch64::STRXpost || Opc == AArch64::LDRXpre) {
-    assert(MI.getOperand(0).getReg() != AArch64::SP);
+  // instructions and associated CFI instruction.
+  if (Opc == AArch64::STRXpost || Opc == AArch64::LDRXpre ||
+      Opc == AArch64::CFI_INSTRUCTION) {
+    if (Opc != AArch64::CFI_INSTRUCTION)
+      assert(MI.getOperand(0).getReg() != AArch64::SP);
     return;
   }
 
@@ -1729,6 +1733,21 @@ bool AArch64FrameLowering::spillCalleeSavedRegisters(
       BuildMI(MBB, MI, DL, TII.get(AArch64::SEH_Nop))
           .setMIFlag(MachineInstr::FrameSetup);
 
+    // Emit a CFI instruction that causes 8 to be subtracted from the value of
+    // x18 when unwinding past this frame.
+    static const char CFIInst[] = {
+        dwarf::DW_CFA_val_expression,
+        18, // register
+        2,  // length
+        static_cast<char>(dwarf::DW_OP_breg18),
+        static_cast<char>(-8) & 0x7f, // addend (sleb128)
+    };
+    unsigned CFIIndex =
+        MF.addFrameInst(MCCFIInstruction::createEscape(nullptr, CFIInst));
+    BuildMI(MBB, MI, DL, TII.get(AArch64::CFI_INSTRUCTION))
+        .addCFIIndex(CFIIndex)
+        .setMIFlag(MachineInstr::FrameSetup);
+
     // This instruction also makes x18 live-in to the entry block.
     MBB.addLiveIn(AArch64::X18);
   }
diff --git a/test/CodeGen/AArch64/shadow-call-stack.ll b/test/CodeGen/AArch64/shadow-call-stack.ll
index dbd44fd3cd1..7ec1d639614 100644
--- a/test/CodeGen/AArch64/shadow-call-stack.ll
+++ b/test/CodeGen/AArch64/shadow-call-stack.ll
@@ -22,6 +22,7 @@ declare i32 @bar()
 define i32 @f3() shadowcallstack {
   ; CHECK: f3:
   ; CHECK: str x30, [x18], #8
+  ; CHECK: .cfi_escape 0x16, 0x12, 0x02, 0x82, 0x78
   ; CHECK: str x30, [sp, #-16]!
   %res = call i32 @bar()
   %res1 = add i32 %res, 1
