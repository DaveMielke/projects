From fe59b7ae6947575cfcd0374a7e74fb6e4013a8f4 Mon Sep 17 00:00:00 2001
From: Jorge Lucangeli Obes <jorgelo@google.com>
Date: Tue, 28 Aug 2018 11:23:29 -0400
Subject: [PATCH] libchrome: Add base::Optional.

base::Optional (which works like std::optional from C++17) is pretty
useful to wrap syscall return values where the syscall might return
a valid positive integer (like a PID) on success, but -1 on error
(like fork(2)).

BUG=chromium:188605
TEST=Builds
TEST=Works with new code that uses base::Optional.

Change-Id: Idfb645b648de05c144160c5ec7e6b3c14d3129a4
---
 base/optional.h           |  922 ++++++++++++++++
 base/optional_unittest.cc | 2185 +++++++++++++++++++++++++++++++++++++
 2 files changed, 3107 insertions(+)
 create mode 100644 base/optional.h
 create mode 100644 base/optional_unittest.cc

diff --git base/optional.h base/optional.h
new file mode 100644
index 0000000..4ae901b
--- /dev/null
+++ base/optional.h
@@ -0,0 +1,922 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_OPTIONAL_H_
+#define BASE_OPTIONAL_H_
+
+#include <type_traits>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/template_util.h"
+
+namespace base {
+
+// Specification:
+// http://en.cppreference.com/w/cpp/utility/optional/in_place_t
+struct in_place_t {};
+
+// Specification:
+// http://en.cppreference.com/w/cpp/utility/optional/nullopt_t
+struct nullopt_t {
+  constexpr explicit nullopt_t(int) {}
+};
+
+// Specification:
+// http://en.cppreference.com/w/cpp/utility/optional/in_place
+constexpr in_place_t in_place = {};
+
+// Specification:
+// http://en.cppreference.com/w/cpp/utility/optional/nullopt
+constexpr nullopt_t nullopt(0);
+
+// Forward declaration, which is refered by following helpers.
+template <typename T>
+class Optional;
+
+namespace internal {
+
+template <typename T, bool = std::is_trivially_destructible<T>::value>
+struct OptionalStorageBase {
+  // Initializing |empty_| here instead of using default member initializing
+  // to avoid errors in g++ 4.8.
+  constexpr OptionalStorageBase() : empty_('\0') {}
+
+  template <class... Args>
+  constexpr explicit OptionalStorageBase(in_place_t, Args&&... args)
+      : is_populated_(true), value_(std::forward<Args>(args)...) {}
+
+  // When T is not trivially destructible we must call its
+  // destructor before deallocating its memory.
+  // Note that this hides the (implicitly declared) move constructor, which
+  // would be used for constexpr move constructor in OptionalStorage<T>.
+  // It is needed iff T is trivially move constructible. However, the current
+  // is_trivially_{copy,move}_constructible implementation requires
+  // is_trivially_destructible (which looks a bug, cf:
+  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452 and
+  // http://cplusplus.github.io/LWG/lwg-active.html#2116), so it is not
+  // necessary for this case at the moment. Please see also the destructor
+  // comment in "is_trivially_destructible = true" specialization below.
+  ~OptionalStorageBase() {
+    if (is_populated_)
+      value_.~T();
+  }
+
+  template <class... Args>
+  void Init(Args&&... args) {
+    DCHECK(!is_populated_);
+    ::new (&value_) T(std::forward<Args>(args)...);
+    is_populated_ = true;
+  }
+
+  bool is_populated_ = false;
+  union {
+    // |empty_| exists so that the union will always be initialized, even when
+    // it doesn't contain a value. Union members must be initialized for the
+    // constructor to be 'constexpr'.
+    char empty_;
+    T value_;
+  };
+};
+
+template <typename T>
+struct OptionalStorageBase<T, true /* trivially destructible */> {
+  // Initializing |empty_| here instead of using default member initializing
+  // to avoid errors in g++ 4.8.
+  constexpr OptionalStorageBase() : empty_('\0') {}
+
+  template <class... Args>
+  constexpr explicit OptionalStorageBase(in_place_t, Args&&... args)
+      : is_populated_(true), value_(std::forward<Args>(args)...) {}
+
+  // When T is trivially destructible (i.e. its destructor does nothing) there
+  // is no need to call it. Implicitly defined destructor is trivial, because
+  // both members (bool and union containing only variants which are trivially
+  // destructible) are trivially destructible.
+  // Explicitly-defaulted destructor is also trivial, but do not use it here,
+  // because it hides the implicit move constructor. It is needed to implement
+  // constexpr move constructor in OptionalStorage iff T is trivially move
+  // constructible. Note that, if T is trivially move constructible, the move
+  // constructor of OptionalStorageBase<T> is also implicitly defined and it is
+  // trivially move constructor. If T is not trivially move constructible,
+  // "not declaring move constructor without destructor declaration" here means
+  // "delete move constructor", which works because any move constructor of
+  // OptionalStorage will not refer to it in that case.
+
+  template <class... Args>
+  void Init(Args&&... args) {
+    DCHECK(!is_populated_);
+    ::new (&value_) T(std::forward<Args>(args)...);
+    is_populated_ = true;
+  }
+
+  bool is_populated_ = false;
+  union {
+    // |empty_| exists so that the union will always be initialized, even when
+    // it doesn't contain a value. Union members must be initialized for the
+    // constructor to be 'constexpr'.
+    char empty_;
+    T value_;
+  };
+};
+
+// Implement conditional constexpr copy and move constructors. These are
+// constexpr if is_trivially_{copy,move}_constructible<T>::value is true
+// respectively. If each is true, the corresponding constructor is defined as
+// "= default;", which generates a constexpr constructor (In this case,
+// the condition of constexpr-ness is satisfied because the base class also has
+// compiler generated constexpr {copy,move} constructors). Note that
+// placement-new is prohibited in constexpr.
+template <typename T,
+          bool = std::is_trivially_copy_constructible<T>::value,
+          bool = std::is_trivially_move_constructible<T>::value>
+struct OptionalStorage : OptionalStorageBase<T> {
+  // This is no trivially {copy,move} constructible case. Other cases are
+  // defined below as specializations.
+
+  // Accessing the members of template base class requires explicit
+  // declaration.
+  using OptionalStorageBase<T>::is_populated_;
+  using OptionalStorageBase<T>::value_;
+  using OptionalStorageBase<T>::Init;
+
+  // Inherit constructors (specifically, the in_place constructor).
+  using OptionalStorageBase<T>::OptionalStorageBase;
+
+  // User defined constructor deletes the default constructor.
+  // Define it explicitly.
+  OptionalStorage() = default;
+
+  OptionalStorage(const OptionalStorage& other) {
+    if (other.is_populated_)
+      Init(other.value_);
+  }
+
+  OptionalStorage(OptionalStorage&& other) noexcept(
+      std::is_nothrow_move_constructible<T>::value) {
+    if (other.is_populated_)
+      Init(std::move(other.value_));
+  }
+};
+
+template <typename T>
+struct OptionalStorage<T,
+                       true /* trivially copy constructible */,
+                       false /* trivially move constructible */>
+    : OptionalStorageBase<T> {
+  using OptionalStorageBase<T>::is_populated_;
+  using OptionalStorageBase<T>::value_;
+  using OptionalStorageBase<T>::Init;
+  using OptionalStorageBase<T>::OptionalStorageBase;
+
+  OptionalStorage() = default;
+  OptionalStorage(const OptionalStorage& other) = default;
+
+  OptionalStorage(OptionalStorage&& other) noexcept(
+      std::is_nothrow_move_constructible<T>::value) {
+    if (other.is_populated_)
+      Init(std::move(other.value_));
+  }
+};
+
+template <typename T>
+struct OptionalStorage<T,
+                       false /* trivially copy constructible */,
+                       true /* trivially move constructible */>
+    : OptionalStorageBase<T> {
+  using OptionalStorageBase<T>::is_populated_;
+  using OptionalStorageBase<T>::value_;
+  using OptionalStorageBase<T>::Init;
+  using OptionalStorageBase<T>::OptionalStorageBase;
+
+  OptionalStorage() = default;
+  OptionalStorage(OptionalStorage&& other) = default;
+
+  OptionalStorage(const OptionalStorage& other) {
+    if (other.is_populated_)
+      Init(other.value_);
+  }
+};
+
+template <typename T>
+struct OptionalStorage<T,
+                       true /* trivially copy constructible */,
+                       true /* trivially move constructible */>
+    : OptionalStorageBase<T> {
+  // If both trivially {copy,move} constructible are true, it is not necessary
+  // to use user-defined constructors. So, just inheriting constructors
+  // from the base class works.
+  using OptionalStorageBase<T>::OptionalStorageBase;
+};
+
+// Base class to support conditionally usable copy-/move- constructors
+// and assign operators.
+template <typename T>
+class OptionalBase {
+  // This class provides implementation rather than public API, so everything
+  // should be hidden. Often we use composition, but we cannot in this case
+  // because of C++ language restriction.
+ protected:
+  constexpr OptionalBase() = default;
+  constexpr OptionalBase(const OptionalBase& other) = default;
+  constexpr OptionalBase(OptionalBase&& other) = default;
+
+  template <class... Args>
+  constexpr explicit OptionalBase(in_place_t, Args&&... args)
+      : storage_(in_place, std::forward<Args>(args)...) {}
+
+  // Implementation of converting constructors.
+  template <typename U>
+  explicit OptionalBase(const OptionalBase<U>& other) {
+    if (other.storage_.is_populated_)
+      storage_.Init(other.storage_.value_);
+  }
+
+  template <typename U>
+  explicit OptionalBase(OptionalBase<U>&& other) {
+    if (other.storage_.is_populated_)
+      storage_.Init(std::move(other.storage_.value_));
+  }
+
+  ~OptionalBase() = default;
+
+  OptionalBase& operator=(const OptionalBase& other) {
+    CopyAssign(other);
+    return *this;
+  }
+
+  OptionalBase& operator=(OptionalBase&& other) noexcept(
+      std::is_nothrow_move_assignable<T>::value&&
+          std::is_nothrow_move_constructible<T>::value) {
+    MoveAssign(std::move(other));
+    return *this;
+  }
+
+  template <typename U>
+  void CopyAssign(const OptionalBase<U>& other) {
+    if (other.storage_.is_populated_)
+      InitOrAssign(other.storage_.value_);
+    else
+      FreeIfNeeded();
+  }
+
+  template <typename U>
+  void MoveAssign(OptionalBase<U>&& other) {
+    if (other.storage_.is_populated_)
+      InitOrAssign(std::move(other.storage_.value_));
+    else
+      FreeIfNeeded();
+  }
+
+  template <typename U>
+  void InitOrAssign(U&& value) {
+    if (storage_.is_populated_)
+      storage_.value_ = std::forward<U>(value);
+    else
+      storage_.Init(std::forward<U>(value));
+  }
+
+  void FreeIfNeeded() {
+    if (!storage_.is_populated_)
+      return;
+    storage_.value_.~T();
+    storage_.is_populated_ = false;
+  }
+
+  // For implementing conversion, allow access to other typed OptionalBase
+  // class.
+  template <typename U>
+  friend class OptionalBase;
+
+  OptionalStorage<T> storage_;
+};
+
+// The following {Copy,Move}{Constructible,Assignable} structs are helpers to
+// implement constructor/assign-operator overloading. Specifically, if T is
+// is not movable but copyable, Optional<T>'s move constructor should not
+// participate in overload resolution. This inheritance trick implements that.
+template <bool is_copy_constructible>
+struct CopyConstructible {};
+
+template <>
+struct CopyConstructible<false> {
+  constexpr CopyConstructible() = default;
+  constexpr CopyConstructible(const CopyConstructible&) = delete;
+  constexpr CopyConstructible(CopyConstructible&&) = default;
+  CopyConstructible& operator=(const CopyConstructible&) = default;
+  CopyConstructible& operator=(CopyConstructible&&) = default;
+};
+
+template <bool is_move_constructible>
+struct MoveConstructible {};
+
+template <>
+struct MoveConstructible<false> {
+  constexpr MoveConstructible() = default;
+  constexpr MoveConstructible(const MoveConstructible&) = default;
+  constexpr MoveConstructible(MoveConstructible&&) = delete;
+  MoveConstructible& operator=(const MoveConstructible&) = default;
+  MoveConstructible& operator=(MoveConstructible&&) = default;
+};
+
+template <bool is_copy_assignable>
+struct CopyAssignable {};
+
+template <>
+struct CopyAssignable<false> {
+  constexpr CopyAssignable() = default;
+  constexpr CopyAssignable(const CopyAssignable&) = default;
+  constexpr CopyAssignable(CopyAssignable&&) = default;
+  CopyAssignable& operator=(const CopyAssignable&) = delete;
+  CopyAssignable& operator=(CopyAssignable&&) = default;
+};
+
+template <bool is_move_assignable>
+struct MoveAssignable {};
+
+template <>
+struct MoveAssignable<false> {
+  constexpr MoveAssignable() = default;
+  constexpr MoveAssignable(const MoveAssignable&) = default;
+  constexpr MoveAssignable(MoveAssignable&&) = default;
+  MoveAssignable& operator=(const MoveAssignable&) = default;
+  MoveAssignable& operator=(MoveAssignable&&) = delete;
+};
+
+// Helper to conditionally enable converting constructors and assign operators.
+template <typename T, typename U>
+struct IsConvertibleFromOptional
+    : std::integral_constant<
+          bool,
+          std::is_constructible<T, Optional<U>&>::value ||
+              std::is_constructible<T, const Optional<U>&>::value ||
+              std::is_constructible<T, Optional<U>&&>::value ||
+              std::is_constructible<T, const Optional<U>&&>::value ||
+              std::is_convertible<Optional<U>&, T>::value ||
+              std::is_convertible<const Optional<U>&, T>::value ||
+              std::is_convertible<Optional<U>&&, T>::value ||
+              std::is_convertible<const Optional<U>&&, T>::value> {};
+
+template <typename T, typename U>
+struct IsAssignableFromOptional
+    : std::integral_constant<
+          bool,
+          IsConvertibleFromOptional<T, U>::value ||
+              std::is_assignable<T&, Optional<U>&>::value ||
+              std::is_assignable<T&, const Optional<U>&>::value ||
+              std::is_assignable<T&, Optional<U>&&>::value ||
+              std::is_assignable<T&, const Optional<U>&&>::value> {};
+
+// Forward compatibility for C++17.
+// Introduce one more deeper nested namespace to avoid leaking using std::swap.
+namespace swappable_impl {
+using std::swap;
+
+struct IsSwappableImpl {
+  // Tests if swap can be called. Check<T&>(0) returns true_type iff swap
+  // is available for T. Otherwise, Check's overload resolution falls back
+  // to Check(...) declared below thanks to SFINAE, so returns false_type.
+  template <typename T>
+  static auto Check(int)
+      -> decltype(swap(std::declval<T>(), std::declval<T>()), std::true_type());
+
+  template <typename T>
+  static std::false_type Check(...);
+};
+}  // namespace swappable_impl
+
+template <typename T>
+struct IsSwappable : decltype(swappable_impl::IsSwappableImpl::Check<T&>(0)) {};
+
+// Forward compatibility for C++20.
+template <typename T>
+using RemoveCvRefT = std::remove_cv_t<std::remove_reference_t<T>>;
+
+}  // namespace internal
+
+// On Windows, by default, empty-base class optimization does not work,
+// which means even if the base class is empty struct, it still consumes one
+// byte for its body. __declspec(empty_bases) enables the optimization.
+// cf)
+// https://blogs.msdn.microsoft.com/vcblog/2016/03/30/optimizing-the-layout-of-empty-base-classes-in-vs2015-update-2-3/
+#ifdef OS_WIN
+#define OPTIONAL_DECLSPEC_EMPTY_BASES __declspec(empty_bases)
+#else
+#define OPTIONAL_DECLSPEC_EMPTY_BASES
+#endif
+
+// base::Optional is a Chromium version of the C++17 optional class:
+// std::optional documentation:
+// http://en.cppreference.com/w/cpp/utility/optional
+// Chromium documentation:
+// https://chromium.googlesource.com/chromium/src/+/master/docs/optional.md
+//
+// These are the differences between the specification and the implementation:
+// - Constructors do not use 'constexpr' as it is a C++14 extension.
+// - 'constexpr' might be missing in some places for reasons specified locally.
+// - No exceptions are thrown, because they are banned from Chromium.
+//   Marked noexcept for only move constructor and move assign operators.
+// - All the non-members are in the 'base' namespace instead of 'std'.
+//
+// Note that T cannot have a constructor T(Optional<T>) etc. Optional<T> checks
+// T's constructor (specifically via IsConvertibleFromOptional), and in the
+// check whether T can be constructible from Optional<T>, which is recursive
+// so it does not work. As of Feb 2018, std::optional C++17 implementation in
+// both clang and gcc has same limitation. MSVC SFINAE looks to have different
+// behavior, but anyway it reports an error, too.
+template <typename T>
+class OPTIONAL_DECLSPEC_EMPTY_BASES Optional
+    : public internal::OptionalBase<T>,
+      public internal::CopyConstructible<std::is_copy_constructible<T>::value>,
+      public internal::MoveConstructible<std::is_move_constructible<T>::value>,
+      public internal::CopyAssignable<std::is_copy_constructible<T>::value &&
+                                      std::is_copy_assignable<T>::value>,
+      public internal::MoveAssignable<std::is_move_constructible<T>::value &&
+                                      std::is_move_assignable<T>::value> {
+ public:
+#undef OPTIONAL_DECLSPEC_EMPTY_BASES
+  using value_type = T;
+
+  // Defer default/copy/move constructor implementation to OptionalBase.
+  constexpr Optional() = default;
+  constexpr Optional(const Optional& other) = default;
+  constexpr Optional(Optional&& other) noexcept(
+      std::is_nothrow_move_constructible<T>::value) = default;
+
+  constexpr Optional(nullopt_t) {}  // NOLINT(runtime/explicit)
+
+  // Converting copy constructor. "explicit" only if
+  // std::is_convertible<const U&, T>::value is false. It is implemented by
+  // declaring two almost same constructors, but that condition in enable_if_t
+  // is different, so that either one is chosen, thanks to SFINAE.
+  template <
+      typename U,
+      std::enable_if_t<std::is_constructible<T, const U&>::value &&
+                           !internal::IsConvertibleFromOptional<T, U>::value &&
+                           std::is_convertible<const U&, T>::value,
+                       bool> = false>
+  Optional(const Optional<U>& other) : internal::OptionalBase<T>(other) {}
+
+  template <
+      typename U,
+      std::enable_if_t<std::is_constructible<T, const U&>::value &&
+                           !internal::IsConvertibleFromOptional<T, U>::value &&
+                           !std::is_convertible<const U&, T>::value,
+                       bool> = false>
+  explicit Optional(const Optional<U>& other)
+      : internal::OptionalBase<T>(other) {}
+
+  // Converting move constructor. Similar to converting copy constructor,
+  // declaring two (explicit and non-explicit) constructors.
+  template <
+      typename U,
+      std::enable_if_t<std::is_constructible<T, U&&>::value &&
+                           !internal::IsConvertibleFromOptional<T, U>::value &&
+                           std::is_convertible<U&&, T>::value,
+                       bool> = false>
+  Optional(Optional<U>&& other) : internal::OptionalBase<T>(std::move(other)) {}
+
+  template <
+      typename U,
+      std::enable_if_t<std::is_constructible<T, U&&>::value &&
+                           !internal::IsConvertibleFromOptional<T, U>::value &&
+                           !std::is_convertible<U&&, T>::value,
+                       bool> = false>
+  explicit Optional(Optional<U>&& other)
+      : internal::OptionalBase<T>(std::move(other)) {}
+
+  template <class... Args>
+  constexpr explicit Optional(in_place_t, Args&&... args)
+      : internal::OptionalBase<T>(in_place, std::forward<Args>(args)...) {}
+
+  template <
+      class U,
+      class... Args,
+      class = std::enable_if_t<std::is_constructible<value_type,
+                                                     std::initializer_list<U>&,
+                                                     Args...>::value>>
+  constexpr explicit Optional(in_place_t,
+                              std::initializer_list<U> il,
+                              Args&&... args)
+      : internal::OptionalBase<T>(in_place, il, std::forward<Args>(args)...) {}
+
+  // Forward value constructor. Similar to converting constructors,
+  // conditionally explicit.
+  template <
+      typename U = value_type,
+      std::enable_if_t<
+          std::is_constructible<T, U&&>::value &&
+              !std::is_same<internal::RemoveCvRefT<U>, in_place_t>::value &&
+              !std::is_same<internal::RemoveCvRefT<U>, Optional<T>>::value &&
+              std::is_convertible<U&&, T>::value,
+          bool> = false>
+  constexpr Optional(U&& value)
+      : internal::OptionalBase<T>(in_place, std::forward<U>(value)) {}
+
+  template <
+      typename U = value_type,
+      std::enable_if_t<
+          std::is_constructible<T, U&&>::value &&
+              !std::is_same<internal::RemoveCvRefT<U>, in_place_t>::value &&
+              !std::is_same<internal::RemoveCvRefT<U>, Optional<T>>::value &&
+              !std::is_convertible<U&&, T>::value,
+          bool> = false>
+  constexpr explicit Optional(U&& value)
+      : internal::OptionalBase<T>(in_place, std::forward<U>(value)) {}
+
+  ~Optional() = default;
+
+  // Defer copy-/move- assign operator implementation to OptionalBase.
+  Optional& operator=(const Optional& other) = default;
+  Optional& operator=(Optional&& other) noexcept(
+      std::is_nothrow_move_assignable<T>::value&&
+          std::is_nothrow_move_constructible<T>::value) = default;
+
+  Optional& operator=(nullopt_t) {
+    FreeIfNeeded();
+    return *this;
+  }
+
+  // Perfect-forwarded assignment.
+  template <typename U>
+  std::enable_if_t<
+      !std::is_same<internal::RemoveCvRefT<U>, Optional<T>>::value &&
+          std::is_constructible<T, U>::value &&
+          std::is_assignable<T&, U>::value &&
+          (!std::is_scalar<T>::value ||
+           !std::is_same<std::decay_t<U>, T>::value),
+      Optional&>
+  operator=(U&& value) {
+    InitOrAssign(std::forward<U>(value));
+    return *this;
+  }
+
+  // Copy assign the state of other.
+  template <typename U>
+  std::enable_if_t<!internal::IsAssignableFromOptional<T, U>::value &&
+                       std::is_constructible<T, const U&>::value &&
+                       std::is_assignable<T&, const U&>::value,
+                   Optional&>
+  operator=(const Optional<U>& other) {
+    CopyAssign(other);
+    return *this;
+  }
+
+  // Move assign the state of other.
+  template <typename U>
+  std::enable_if_t<!internal::IsAssignableFromOptional<T, U>::value &&
+                       std::is_constructible<T, U>::value &&
+                       std::is_assignable<T&, U>::value,
+                   Optional&>
+  operator=(Optional<U>&& other) {
+    MoveAssign(std::move(other));
+    return *this;
+  }
+
+  constexpr const T* operator->() const {
+    DCHECK(storage_.is_populated_);
+    return &storage_.value_;
+  }
+
+  constexpr T* operator->() {
+    DCHECK(storage_.is_populated_);
+    return &storage_.value_;
+  }
+
+  constexpr const T& operator*() const & {
+    DCHECK(storage_.is_populated_);
+    return storage_.value_;
+  }
+
+  constexpr T& operator*() & {
+    DCHECK(storage_.is_populated_);
+    return storage_.value_;
+  }
+
+  constexpr const T&& operator*() const && {
+    DCHECK(storage_.is_populated_);
+    return std::move(storage_.value_);
+  }
+
+  constexpr T&& operator*() && {
+    DCHECK(storage_.is_populated_);
+    return std::move(storage_.value_);
+  }
+
+  constexpr explicit operator bool() const { return storage_.is_populated_; }
+
+  constexpr bool has_value() const { return storage_.is_populated_; }
+
+  constexpr T& value() & {
+    CHECK(storage_.is_populated_);
+    return storage_.value_;
+  }
+
+  constexpr const T& value() const & {
+    CHECK(storage_.is_populated_);
+    return storage_.value_;
+  }
+
+  constexpr T&& value() && {
+    CHECK(storage_.is_populated_);
+    return std::move(storage_.value_);
+  }
+
+  constexpr const T&& value() const && {
+    CHECK(storage_.is_populated_);
+    return std::move(storage_.value_);
+  }
+
+  template <class U>
+  constexpr T value_or(U&& default_value) const& {
+    // TODO(mlamouri): add the following assert when possible:
+    // static_assert(std::is_copy_constructible<T>::value,
+    //               "T must be copy constructible");
+    static_assert(std::is_convertible<U, T>::value,
+                  "U must be convertible to T");
+    return storage_.is_populated_
+               ? storage_.value_
+               : static_cast<T>(std::forward<U>(default_value));
+  }
+
+  template <class U>
+  constexpr T value_or(U&& default_value) && {
+    // TODO(mlamouri): add the following assert when possible:
+    // static_assert(std::is_move_constructible<T>::value,
+    //               "T must be move constructible");
+    static_assert(std::is_convertible<U, T>::value,
+                  "U must be convertible to T");
+    return storage_.is_populated_
+               ? std::move(storage_.value_)
+               : static_cast<T>(std::forward<U>(default_value));
+  }
+
+  void swap(Optional& other) {
+    if (!storage_.is_populated_ && !other.storage_.is_populated_)
+      return;
+
+    if (storage_.is_populated_ != other.storage_.is_populated_) {
+      if (storage_.is_populated_) {
+        other.storage_.Init(std::move(storage_.value_));
+        FreeIfNeeded();
+      } else {
+        storage_.Init(std::move(other.storage_.value_));
+        other.FreeIfNeeded();
+      }
+      return;
+    }
+
+    DCHECK(storage_.is_populated_ && other.storage_.is_populated_);
+    using std::swap;
+    swap(**this, *other);
+  }
+
+  void reset() { FreeIfNeeded(); }
+
+  template <class... Args>
+  T& emplace(Args&&... args) {
+    FreeIfNeeded();
+    storage_.Init(std::forward<Args>(args)...);
+    return storage_.value_;
+  }
+
+  template <class U, class... Args>
+  std::enable_if_t<
+      std::is_constructible<T, std::initializer_list<U>&, Args&&...>::value,
+      T&>
+  emplace(std::initializer_list<U> il, Args&&... args) {
+    FreeIfNeeded();
+    storage_.Init(il, std::forward<Args>(args)...);
+    return storage_.value_;
+  }
+
+ private:
+  // Accessing template base class's protected member needs explicit
+  // declaration to do so.
+  using internal::OptionalBase<T>::CopyAssign;
+  using internal::OptionalBase<T>::FreeIfNeeded;
+  using internal::OptionalBase<T>::InitOrAssign;
+  using internal::OptionalBase<T>::MoveAssign;
+  using internal::OptionalBase<T>::storage_;
+};
+
+// Here after defines comparation operators. The definition follows
+// http://en.cppreference.com/w/cpp/utility/optional/operator_cmp
+// while bool() casting is replaced by has_value() to meet the chromium
+// style guide.
+template <class T, class U>
+constexpr bool operator==(const Optional<T>& lhs, const Optional<U>& rhs) {
+  if (lhs.has_value() != rhs.has_value())
+    return false;
+  if (!lhs.has_value())
+    return true;
+  return *lhs == *rhs;
+}
+
+template <class T, class U>
+constexpr bool operator!=(const Optional<T>& lhs, const Optional<U>& rhs) {
+  if (lhs.has_value() != rhs.has_value())
+    return true;
+  if (!lhs.has_value())
+    return false;
+  return *lhs != *rhs;
+}
+
+template <class T, class U>
+constexpr bool operator<(const Optional<T>& lhs, const Optional<U>& rhs) {
+  if (!rhs.has_value())
+    return false;
+  if (!lhs.has_value())
+    return true;
+  return *lhs < *rhs;
+}
+
+template <class T, class U>
+constexpr bool operator<=(const Optional<T>& lhs, const Optional<U>& rhs) {
+  if (!lhs.has_value())
+    return true;
+  if (!rhs.has_value())
+    return false;
+  return *lhs <= *rhs;
+}
+
+template <class T, class U>
+constexpr bool operator>(const Optional<T>& lhs, const Optional<U>& rhs) {
+  if (!lhs.has_value())
+    return false;
+  if (!rhs.has_value())
+    return true;
+  return *lhs > *rhs;
+}
+
+template <class T, class U>
+constexpr bool operator>=(const Optional<T>& lhs, const Optional<U>& rhs) {
+  if (!rhs.has_value())
+    return true;
+  if (!lhs.has_value())
+    return false;
+  return *lhs >= *rhs;
+}
+
+template <class T>
+constexpr bool operator==(const Optional<T>& opt, nullopt_t) {
+  return !opt;
+}
+
+template <class T>
+constexpr bool operator==(nullopt_t, const Optional<T>& opt) {
+  return !opt;
+}
+
+template <class T>
+constexpr bool operator!=(const Optional<T>& opt, nullopt_t) {
+  return opt.has_value();
+}
+
+template <class T>
+constexpr bool operator!=(nullopt_t, const Optional<T>& opt) {
+  return opt.has_value();
+}
+
+template <class T>
+constexpr bool operator<(const Optional<T>& opt, nullopt_t) {
+  return false;
+}
+
+template <class T>
+constexpr bool operator<(nullopt_t, const Optional<T>& opt) {
+  return opt.has_value();
+}
+
+template <class T>
+constexpr bool operator<=(const Optional<T>& opt, nullopt_t) {
+  return !opt;
+}
+
+template <class T>
+constexpr bool operator<=(nullopt_t, const Optional<T>& opt) {
+  return true;
+}
+
+template <class T>
+constexpr bool operator>(const Optional<T>& opt, nullopt_t) {
+  return opt.has_value();
+}
+
+template <class T>
+constexpr bool operator>(nullopt_t, const Optional<T>& opt) {
+  return false;
+}
+
+template <class T>
+constexpr bool operator>=(const Optional<T>& opt, nullopt_t) {
+  return true;
+}
+
+template <class T>
+constexpr bool operator>=(nullopt_t, const Optional<T>& opt) {
+  return !opt;
+}
+
+template <class T, class U>
+constexpr bool operator==(const Optional<T>& opt, const U& value) {
+  return opt.has_value() ? *opt == value : false;
+}
+
+template <class T, class U>
+constexpr bool operator==(const U& value, const Optional<T>& opt) {
+  return opt.has_value() ? value == *opt : false;
+}
+
+template <class T, class U>
+constexpr bool operator!=(const Optional<T>& opt, const U& value) {
+  return opt.has_value() ? *opt != value : true;
+}
+
+template <class T, class U>
+constexpr bool operator!=(const U& value, const Optional<T>& opt) {
+  return opt.has_value() ? value != *opt : true;
+}
+
+template <class T, class U>
+constexpr bool operator<(const Optional<T>& opt, const U& value) {
+  return opt.has_value() ? *opt < value : true;
+}
+
+template <class T, class U>
+constexpr bool operator<(const U& value, const Optional<T>& opt) {
+  return opt.has_value() ? value < *opt : false;
+}
+
+template <class T, class U>
+constexpr bool operator<=(const Optional<T>& opt, const U& value) {
+  return opt.has_value() ? *opt <= value : true;
+}
+
+template <class T, class U>
+constexpr bool operator<=(const U& value, const Optional<T>& opt) {
+  return opt.has_value() ? value <= *opt : false;
+}
+
+template <class T, class U>
+constexpr bool operator>(const Optional<T>& opt, const U& value) {
+  return opt.has_value() ? *opt > value : false;
+}
+
+template <class T, class U>
+constexpr bool operator>(const U& value, const Optional<T>& opt) {
+  return opt.has_value() ? value > *opt : true;
+}
+
+template <class T, class U>
+constexpr bool operator>=(const Optional<T>& opt, const U& value) {
+  return opt.has_value() ? *opt >= value : false;
+}
+
+template <class T, class U>
+constexpr bool operator>=(const U& value, const Optional<T>& opt) {
+  return opt.has_value() ? value >= *opt : true;
+}
+
+template <class T>
+constexpr Optional<std::decay_t<T>> make_optional(T&& value) {
+  return Optional<std::decay_t<T>>(std::forward<T>(value));
+}
+
+template <class T, class... Args>
+constexpr Optional<T> make_optional(Args&&... args) {
+  return Optional<T>(in_place, std::forward<Args>(args)...);
+}
+
+template <class T, class U, class... Args>
+constexpr Optional<T> make_optional(std::initializer_list<U> il,
+                                    Args&&... args) {
+  return Optional<T>(in_place, il, std::forward<Args>(args)...);
+}
+
+// Partial specialization for a function template is not allowed. Also, it is
+// not allowed to add overload function to std namespace, while it is allowed
+// to specialize the template in std. Thus, swap() (kind of) overloading is
+// defined in base namespace, instead.
+template <class T>
+std::enable_if_t<std::is_move_constructible<T>::value &&
+                 internal::IsSwappable<T>::value>
+swap(Optional<T>& lhs, Optional<T>& rhs) {
+  lhs.swap(rhs);
+}
+
+}  // namespace base
+
+namespace std {
+
+template <class T>
+struct hash<base::Optional<T>> {
+  size_t operator()(const base::Optional<T>& opt) const {
+    return opt == base::nullopt ? 0 : std::hash<T>()(*opt);
+  }
+};
+
+}  // namespace std
+
+#endif  // BASE_OPTIONAL_H_
diff --git base/optional_unittest.cc base/optional_unittest.cc
new file mode 100644
index 0000000..7bdb46b
--- /dev/null
+++ base/optional_unittest.cc
@@ -0,0 +1,2185 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/optional.h"
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using ::testing::ElementsAre;
+
+namespace base {
+
+namespace {
+
+// Object used to test complex object with Optional<T> in addition of the move
+// semantics.
+class TestObject {
+ public:
+  enum class State {
+    DEFAULT_CONSTRUCTED,
+    VALUE_CONSTRUCTED,
+    COPY_CONSTRUCTED,
+    MOVE_CONSTRUCTED,
+    MOVED_FROM,
+    COPY_ASSIGNED,
+    MOVE_ASSIGNED,
+    SWAPPED,
+  };
+
+  TestObject() : foo_(0), bar_(0.0), state_(State::DEFAULT_CONSTRUCTED) {}
+
+  TestObject(int foo, double bar)
+      : foo_(foo), bar_(bar), state_(State::VALUE_CONSTRUCTED) {}
+
+  TestObject(const TestObject& other)
+      : foo_(other.foo_),
+        bar_(other.bar_),
+        state_(State::COPY_CONSTRUCTED),
+        move_ctors_count_(other.move_ctors_count_) {}
+
+  TestObject(TestObject&& other)
+      : foo_(std::move(other.foo_)),
+        bar_(std::move(other.bar_)),
+        state_(State::MOVE_CONSTRUCTED),
+        move_ctors_count_(other.move_ctors_count_ + 1) {
+    other.state_ = State::MOVED_FROM;
+  }
+
+  TestObject& operator=(const TestObject& other) {
+    foo_ = other.foo_;
+    bar_ = other.bar_;
+    state_ = State::COPY_ASSIGNED;
+    move_ctors_count_ = other.move_ctors_count_;
+    return *this;
+  }
+
+  TestObject& operator=(TestObject&& other) {
+    foo_ = other.foo_;
+    bar_ = other.bar_;
+    state_ = State::MOVE_ASSIGNED;
+    move_ctors_count_ = other.move_ctors_count_;
+    other.state_ = State::MOVED_FROM;
+    return *this;
+  }
+
+  void Swap(TestObject* other) {
+    using std::swap;
+    swap(foo_, other->foo_);
+    swap(bar_, other->bar_);
+    swap(move_ctors_count_, other->move_ctors_count_);
+    state_ = State::SWAPPED;
+    other->state_ = State::SWAPPED;
+  }
+
+  bool operator==(const TestObject& other) const {
+    return std::tie(foo_, bar_) == std::tie(other.foo_, other.bar_);
+  }
+
+  bool operator!=(const TestObject& other) const { return !(*this == other); }
+
+  int foo() const { return foo_; }
+  State state() const { return state_; }
+  int move_ctors_count() const { return move_ctors_count_; }
+
+ private:
+  int foo_;
+  double bar_;
+  State state_;
+  int move_ctors_count_ = 0;
+};
+
+// Implementing Swappable concept.
+void swap(TestObject& lhs, TestObject& rhs) {
+  lhs.Swap(&rhs);
+}
+
+class NonTriviallyDestructible {
+  ~NonTriviallyDestructible() {}
+};
+
+class DeletedDefaultConstructor {
+ public:
+  DeletedDefaultConstructor() = delete;
+  DeletedDefaultConstructor(int foo) : foo_(foo) {}
+
+  int foo() const { return foo_; }
+
+ private:
+  int foo_;
+};
+
+class DeletedCopy {
+ public:
+  explicit DeletedCopy(int foo) : foo_(foo) {}
+  DeletedCopy(const DeletedCopy&) = delete;
+  DeletedCopy(DeletedCopy&&) = default;
+
+  DeletedCopy& operator=(const DeletedCopy&) = delete;
+  DeletedCopy& operator=(DeletedCopy&&) = default;
+
+  int foo() const { return foo_; }
+
+ private:
+  int foo_;
+};
+
+class DeletedMove {
+ public:
+  explicit DeletedMove(int foo) : foo_(foo) {}
+  DeletedMove(const DeletedMove&) = default;
+  DeletedMove(DeletedMove&&) = delete;
+
+  DeletedMove& operator=(const DeletedMove&) = default;
+  DeletedMove& operator=(DeletedMove&&) = delete;
+
+  int foo() const { return foo_; }
+
+ private:
+  int foo_;
+};
+
+class NonTriviallyDestructibleDeletedCopyConstructor {
+ public:
+  explicit NonTriviallyDestructibleDeletedCopyConstructor(int foo)
+      : foo_(foo) {}
+  NonTriviallyDestructibleDeletedCopyConstructor(
+      const NonTriviallyDestructibleDeletedCopyConstructor&) = delete;
+  NonTriviallyDestructibleDeletedCopyConstructor(
+      NonTriviallyDestructibleDeletedCopyConstructor&&) = default;
+
+  ~NonTriviallyDestructibleDeletedCopyConstructor() {}
+
+  int foo() const { return foo_; }
+
+ private:
+  int foo_;
+};
+
+class DeleteNewOperators {
+ public:
+  void* operator new(size_t) = delete;
+  void* operator new(size_t, void*) = delete;
+  void* operator new[](size_t) = delete;
+  void* operator new[](size_t, void*) = delete;
+};
+
+}  // anonymous namespace
+
+static_assert(std::is_trivially_destructible<Optional<int>>::value,
+              "OptionalIsTriviallyDestructible");
+
+static_assert(
+    !std::is_trivially_destructible<Optional<NonTriviallyDestructible>>::value,
+    "OptionalIsTriviallyDestructible");
+
+static_assert(sizeof(Optional<int>) == sizeof(internal::OptionalBase<int>),
+              "internal::{Copy,Move}{Constructible,Assignable} structs "
+              "should be 0-sized");
+
+TEST(OptionalTest, DefaultConstructor) {
+  {
+    constexpr Optional<float> o;
+    EXPECT_FALSE(o);
+  }
+
+  {
+    Optional<std::string> o;
+    EXPECT_FALSE(o);
+  }
+
+  {
+    Optional<TestObject> o;
+    EXPECT_FALSE(o);
+  }
+}
+
+TEST(OptionalTest, CopyConstructor) {
+  {
+    constexpr Optional<float> first(0.1f);
+    constexpr Optional<float> other(first);
+
+    EXPECT_TRUE(other);
+    EXPECT_EQ(other.value(), 0.1f);
+    EXPECT_EQ(first, other);
+  }
+
+  {
+    Optional<std::string> first("foo");
+    Optional<std::string> other(first);
+
+    EXPECT_TRUE(other);
+    EXPECT_EQ(other.value(), "foo");
+    EXPECT_EQ(first, other);
+  }
+
+  {
+    const Optional<std::string> first("foo");
+    Optional<std::string> other(first);
+
+    EXPECT_TRUE(other);
+    EXPECT_EQ(other.value(), "foo");
+    EXPECT_EQ(first, other);
+  }
+
+  {
+    Optional<TestObject> first(TestObject(3, 0.1));
+    Optional<TestObject> other(first);
+
+    EXPECT_TRUE(!!other);
+    EXPECT_TRUE(other.value() == TestObject(3, 0.1));
+    EXPECT_TRUE(first == other);
+  }
+}
+
+TEST(OptionalTest, ValueConstructor) {
+  {
+    constexpr float value = 0.1f;
+    constexpr Optional<float> o(value);
+
+    EXPECT_TRUE(o);
+    EXPECT_EQ(value, o.value());
+  }
+
+  {
+    std::string value("foo");
+    Optional<std::string> o(value);
+
+    EXPECT_TRUE(o);
+    EXPECT_EQ(value, o.value());
+  }
+
+  {
+    TestObject value(3, 0.1);
+    Optional<TestObject> o(value);
+
+    EXPECT_TRUE(o);
+    EXPECT_EQ(TestObject::State::COPY_CONSTRUCTED, o->state());
+    EXPECT_EQ(value, o.value());
+  }
+}
+
+TEST(OptionalTest, MoveConstructor) {
+  {
+    constexpr Optional<float> first(0.1f);
+    constexpr Optional<float> second(std::move(first));
+
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(second.value(), 0.1f);
+
+    EXPECT_TRUE(first.has_value());
+  }
+
+  {
+    Optional<std::string> first("foo");
+    Optional<std::string> second(std::move(first));
+
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ("foo", second.value());
+
+    EXPECT_TRUE(first.has_value());
+  }
+
+  {
+    Optional<TestObject> first(TestObject(3, 0.1));
+    Optional<TestObject> second(std::move(first));
+
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(TestObject::State::MOVE_CONSTRUCTED, second->state());
+    EXPECT_TRUE(TestObject(3, 0.1) == second.value());
+
+    EXPECT_TRUE(first.has_value());
+    EXPECT_EQ(TestObject::State::MOVED_FROM, first->state());
+  }
+
+  // Even if copy constructor is deleted, move constructor needs to work.
+  // Note that it couldn't be constexpr.
+  {
+    Optional<DeletedCopy> first(in_place, 42);
+    Optional<DeletedCopy> second(std::move(first));
+
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(42, second->foo());
+
+    EXPECT_TRUE(first.has_value());
+  }
+
+  {
+    Optional<DeletedMove> first(in_place, 42);
+    Optional<DeletedMove> second(std::move(first));
+
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(42, second->foo());
+
+    EXPECT_TRUE(first.has_value());
+  }
+
+  {
+    Optional<NonTriviallyDestructibleDeletedCopyConstructor> first(in_place,
+                                                                   42);
+    Optional<NonTriviallyDestructibleDeletedCopyConstructor> second(
+        std::move(first));
+
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(42, second->foo());
+
+    EXPECT_TRUE(first.has_value());
+  }
+}
+
+TEST(OptionalTest, MoveValueConstructor) {
+  {
+    constexpr float value = 0.1f;
+    constexpr Optional<float> o(std::move(value));
+
+    EXPECT_TRUE(o);
+    EXPECT_EQ(0.1f, o.value());
+  }
+
+  {
+    float value = 0.1f;
+    Optional<float> o(std::move(value));
+
+    EXPECT_TRUE(o);
+    EXPECT_EQ(0.1f, o.value());
+  }
+
+  {
+    std::string value("foo");
+    Optional<std::string> o(std::move(value));
+
+    EXPECT_TRUE(o);
+    EXPECT_EQ("foo", o.value());
+  }
+
+  {
+    TestObject value(3, 0.1);
+    Optional<TestObject> o(std::move(value));
+
+    EXPECT_TRUE(o);
+    EXPECT_EQ(TestObject::State::MOVE_CONSTRUCTED, o->state());
+    EXPECT_EQ(TestObject(3, 0.1), o.value());
+  }
+}
+
+TEST(OptionalTest, ConvertingCopyConstructor) {
+  {
+    Optional<int> first(1);
+    Optional<double> second(first);
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(1.0, second.value());
+  }
+
+  // Make sure explicit is not marked for convertible case.
+  {
+    Optional<int> o(1);
+    ignore_result<Optional<double>>(o);
+  }
+}
+
+TEST(OptionalTest, ConvertingMoveConstructor) {
+  {
+    Optional<int> first(1);
+    Optional<double> second(std::move(first));
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(1.0, second.value());
+  }
+
+  // Make sure explicit is not marked for convertible case.
+  {
+    Optional<int> o(1);
+    ignore_result<Optional<double>>(std::move(o));
+  }
+
+  {
+    class Test1 {
+     public:
+      explicit Test1(int foo) : foo_(foo) {}
+
+      int foo() const { return foo_; }
+
+     private:
+      int foo_;
+    };
+
+    // Not copyable but convertible from Test1.
+    class Test2 {
+     public:
+      Test2(const Test2&) = delete;
+      explicit Test2(Test1&& other) : bar_(other.foo()) {}
+
+      double bar() const { return bar_; }
+
+     private:
+      double bar_;
+    };
+
+    Optional<Test1> first(in_place, 42);
+    Optional<Test2> second(std::move(first));
+    EXPECT_TRUE(second.has_value());
+    EXPECT_EQ(42.0, second->bar());
+  }
+}
+
+TEST(OptionalTest, ConstructorForwardArguments) {
+  {
+    constexpr Optional<float> a(base::in_place, 0.1f);
+    EXPECT_TRUE(a);
+    EXPECT_EQ(0.1f, a.value());
+  }
+
+  {
+    Optional<float> a(base::in_place, 0.1f);
+    EXPECT_TRUE(a);
+    EXPECT_EQ(0.1f, a.value());
+  }
+
+  {
+    Optional<std::string> a(base::in_place, "foo");
+    EXPECT_TRUE(a);
+    EXPECT_EQ("foo", a.value());
+  }
+
+  {
+    Optional<TestObject> a(base::in_place, 0, 0.1);
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(TestObject(0, 0.1) == a.value());
+  }
+}
+
+TEST(OptionalTest, ConstructorForwardInitListAndArguments) {
+  {
+    Optional<std::vector<int>> opt(in_place, {3, 1});
+    EXPECT_TRUE(opt);
+    EXPECT_THAT(*opt, ElementsAre(3, 1));
+    EXPECT_EQ(2u, opt->size());
+  }
+
+  {
+    Optional<std::vector<int>> opt(in_place, {3, 1}, std::allocator<int>());
+    EXPECT_TRUE(opt);
+    EXPECT_THAT(*opt, ElementsAre(3, 1));
+    EXPECT_EQ(2u, opt->size());
+  }
+}
+
+TEST(OptionalTest, ForwardConstructor) {
+  {
+    Optional<double> a(1);
+    EXPECT_TRUE(a.has_value());
+    EXPECT_EQ(1.0, a.value());
+  }
+
+  // Test that default type of 'U' is value_type.
+  {
+    struct TestData {
+      int a;
+      double b;
+      bool c;
+    };
+
+    Optional<TestData> a({1, 2.0, true});
+    EXPECT_TRUE(a.has_value());
+    EXPECT_EQ(1, a->a);
+    EXPECT_EQ(2.0, a->b);
+    EXPECT_TRUE(a->c);
+  }
+
+  // If T has a constructor with a param Optional<U>, and another ctor with a
+  // param U, then T(Optional<U>) should be used for Optional<T>(Optional<U>)
+  // constructor.
+  {
+    enum class ParamType {
+      DEFAULT_CONSTRUCTED,
+      COPY_CONSTRUCTED,
+      MOVE_CONSTRUCTED,
+      INT,
+      IN_PLACE,
+      OPTIONAL_INT,
+    };
+    struct Test {
+      Test() : param_type(ParamType::DEFAULT_CONSTRUCTED) {}
+      Test(const Test& param) : param_type(ParamType::COPY_CONSTRUCTED) {}
+      Test(Test&& param) : param_type(ParamType::MOVE_CONSTRUCTED) {}
+      explicit Test(int param) : param_type(ParamType::INT) {}
+      explicit Test(in_place_t param) : param_type(ParamType::IN_PLACE) {}
+      explicit Test(Optional<int> param)
+          : param_type(ParamType::OPTIONAL_INT) {}
+
+      ParamType param_type;
+    };
+
+    // Overload resolution with copy-conversion constructor.
+    {
+      const Optional<int> arg(in_place, 1);
+      Optional<Test> testee(arg);
+      EXPECT_EQ(ParamType::OPTIONAL_INT, testee->param_type);
+    }
+
+    // Overload resolution with move conversion constructor.
+    {
+      Optional<Test> testee(Optional<int>(in_place, 1));
+      EXPECT_EQ(ParamType::OPTIONAL_INT, testee->param_type);
+    }
+
+    // Default constructor should be used.
+    {
+      Optional<Test> testee(in_place);
+      EXPECT_EQ(ParamType::DEFAULT_CONSTRUCTED, testee->param_type);
+    }
+  }
+
+  {
+    struct Test {
+      Test(int a) {}  // NOLINT(runtime/explicit)
+    };
+    // If T is convertible from U, it is not marked as explicit.
+    static_assert(std::is_convertible<int, Test>::value,
+                  "Int should be convertible to Test.");
+    ([](Optional<Test> param) {})(1);
+  }
+}
+
+TEST(OptionalTest, NulloptConstructor) {
+  constexpr Optional<int> a(base::nullopt);
+  EXPECT_FALSE(a);
+}
+
+TEST(OptionalTest, AssignValue) {
+  {
+    Optional<float> a;
+    EXPECT_FALSE(a);
+    a = 0.1f;
+    EXPECT_TRUE(a);
+
+    Optional<float> b(0.1f);
+    EXPECT_TRUE(a == b);
+  }
+
+  {
+    Optional<std::string> a;
+    EXPECT_FALSE(a);
+    a = std::string("foo");
+    EXPECT_TRUE(a);
+
+    Optional<std::string> b(std::string("foo"));
+    EXPECT_EQ(a, b);
+  }
+
+  {
+    Optional<TestObject> a;
+    EXPECT_FALSE(!!a);
+    a = TestObject(3, 0.1);
+    EXPECT_TRUE(!!a);
+
+    Optional<TestObject> b(TestObject(3, 0.1));
+    EXPECT_TRUE(a == b);
+  }
+
+  {
+    Optional<TestObject> a = TestObject(4, 1.0);
+    EXPECT_TRUE(!!a);
+    a = TestObject(3, 0.1);
+    EXPECT_TRUE(!!a);
+
+    Optional<TestObject> b(TestObject(3, 0.1));
+    EXPECT_TRUE(a == b);
+  }
+}
+
+TEST(OptionalTest, AssignObject) {
+  {
+    Optional<float> a;
+    Optional<float> b(0.1f);
+    a = b;
+
+    EXPECT_TRUE(a);
+    EXPECT_EQ(a.value(), 0.1f);
+    EXPECT_EQ(a, b);
+  }
+
+  {
+    Optional<std::string> a;
+    Optional<std::string> b("foo");
+    a = b;
+
+    EXPECT_TRUE(a);
+    EXPECT_EQ(a.value(), "foo");
+    EXPECT_EQ(a, b);
+  }
+
+  {
+    Optional<TestObject> a;
+    Optional<TestObject> b(TestObject(3, 0.1));
+    a = b;
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(a.value() == TestObject(3, 0.1));
+    EXPECT_TRUE(a == b);
+  }
+
+  {
+    Optional<TestObject> a(TestObject(4, 1.0));
+    Optional<TestObject> b(TestObject(3, 0.1));
+    a = b;
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(a.value() == TestObject(3, 0.1));
+    EXPECT_TRUE(a == b);
+  }
+
+  {
+    Optional<DeletedMove> a(in_place, 42);
+    Optional<DeletedMove> b;
+    b = a;
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(a->foo(), b->foo());
+  }
+
+  {
+    Optional<DeletedMove> a(in_place, 42);
+    Optional<DeletedMove> b(in_place, 1);
+    b = a;
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(a->foo(), b->foo());
+  }
+
+  // Converting assignment.
+  {
+    Optional<int> a(in_place, 1);
+    Optional<double> b;
+    b = a;
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(1, a.value());
+    EXPECT_EQ(1.0, b.value());
+  }
+
+  {
+    Optional<int> a(in_place, 42);
+    Optional<double> b(in_place, 1);
+    b = a;
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(42, a.value());
+    EXPECT_EQ(42.0, b.value());
+  }
+
+  {
+    Optional<int> a;
+    Optional<double> b(in_place, 1);
+    b = a;
+    EXPECT_FALSE(!!a);
+    EXPECT_FALSE(!!b);
+  }
+}
+
+TEST(OptionalTest, AssignObject_rvalue) {
+  {
+    Optional<float> a;
+    Optional<float> b(0.1f);
+    a = std::move(b);
+
+    EXPECT_TRUE(a);
+    EXPECT_TRUE(b);
+    EXPECT_EQ(0.1f, a.value());
+  }
+
+  {
+    Optional<std::string> a;
+    Optional<std::string> b("foo");
+    a = std::move(b);
+
+    EXPECT_TRUE(a);
+    EXPECT_TRUE(b);
+    EXPECT_EQ("foo", a.value());
+  }
+
+  {
+    Optional<TestObject> a;
+    Optional<TestObject> b(TestObject(3, 0.1));
+    a = std::move(b);
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_TRUE(TestObject(3, 0.1) == a.value());
+
+    EXPECT_EQ(TestObject::State::MOVE_CONSTRUCTED, a->state());
+    EXPECT_EQ(TestObject::State::MOVED_FROM, b->state());
+  }
+
+  {
+    Optional<TestObject> a(TestObject(4, 1.0));
+    Optional<TestObject> b(TestObject(3, 0.1));
+    a = std::move(b);
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_TRUE(TestObject(3, 0.1) == a.value());
+
+    EXPECT_EQ(TestObject::State::MOVE_ASSIGNED, a->state());
+    EXPECT_EQ(TestObject::State::MOVED_FROM, b->state());
+  }
+
+  {
+    Optional<DeletedMove> a(in_place, 42);
+    Optional<DeletedMove> b;
+    b = std::move(a);
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(42, b->foo());
+  }
+
+  {
+    Optional<DeletedMove> a(in_place, 42);
+    Optional<DeletedMove> b(in_place, 1);
+    b = std::move(a);
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(42, b->foo());
+  }
+
+  // Converting assignment.
+  {
+    Optional<int> a(in_place, 1);
+    Optional<double> b;
+    b = std::move(a);
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(1.0, b.value());
+  }
+
+  {
+    Optional<int> a(in_place, 42);
+    Optional<double> b(in_place, 1);
+    b = std::move(a);
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(42.0, b.value());
+  }
+
+  {
+    Optional<int> a;
+    Optional<double> b(in_place, 1);
+    b = std::move(a);
+
+    EXPECT_FALSE(!!a);
+    EXPECT_FALSE(!!b);
+  }
+}
+
+TEST(OptionalTest, AssignNull) {
+  {
+    Optional<float> a(0.1f);
+    Optional<float> b(0.2f);
+    a = base::nullopt;
+    b = base::nullopt;
+    EXPECT_EQ(a, b);
+  }
+
+  {
+    Optional<std::string> a("foo");
+    Optional<std::string> b("bar");
+    a = base::nullopt;
+    b = base::nullopt;
+    EXPECT_EQ(a, b);
+  }
+
+  {
+    Optional<TestObject> a(TestObject(3, 0.1));
+    Optional<TestObject> b(TestObject(4, 1.0));
+    a = base::nullopt;
+    b = base::nullopt;
+    EXPECT_TRUE(a == b);
+  }
+}
+
+TEST(OptionalTest, AssignOverload) {
+  struct Test1 {
+    enum class State {
+      CONSTRUCTED,
+      MOVED,
+    };
+    State state = State::CONSTRUCTED;
+  };
+
+  // Here, Optional<Test2> can be assigned from Optioanl<Test1>.
+  // In case of move, marks MOVED to Test1 instance.
+  struct Test2 {
+    enum class State {
+      DEFAULT_CONSTRUCTED,
+      COPY_CONSTRUCTED_FROM_TEST1,
+      MOVE_CONSTRUCTED_FROM_TEST1,
+      COPY_ASSIGNED_FROM_TEST1,
+      MOVE_ASSIGNED_FROM_TEST1,
+    };
+
+    Test2() = default;
+    explicit Test2(const Test1& test1)
+        : state(State::COPY_CONSTRUCTED_FROM_TEST1) {}
+    explicit Test2(Test1&& test1) : state(State::MOVE_CONSTRUCTED_FROM_TEST1) {
+      test1.state = Test1::State::MOVED;
+    }
+    Test2& operator=(const Test1& test1) {
+      state = State::COPY_ASSIGNED_FROM_TEST1;
+      return *this;
+    }
+    Test2& operator=(Test1&& test1) {
+      state = State::MOVE_ASSIGNED_FROM_TEST1;
+      test1.state = Test1::State::MOVED;
+      return *this;
+    }
+
+    State state = State::DEFAULT_CONSTRUCTED;
+  };
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test2> b;
+
+    b = a;
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::CONSTRUCTED, a->state);
+    EXPECT_EQ(Test2::State::COPY_CONSTRUCTED_FROM_TEST1, b->state);
+  }
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test2> b(in_place);
+
+    b = a;
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::CONSTRUCTED, a->state);
+    EXPECT_EQ(Test2::State::COPY_ASSIGNED_FROM_TEST1, b->state);
+  }
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test2> b;
+
+    b = std::move(a);
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::MOVED, a->state);
+    EXPECT_EQ(Test2::State::MOVE_CONSTRUCTED_FROM_TEST1, b->state);
+  }
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test2> b(in_place);
+
+    b = std::move(a);
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::MOVED, a->state);
+    EXPECT_EQ(Test2::State::MOVE_ASSIGNED_FROM_TEST1, b->state);
+  }
+
+  // Similar to Test2, but Test3 also has copy/move ctor and assign operators
+  // from Optional<Test1>, too. In this case, for a = b where a is
+  // Optional<Test3> and b is Optional<Test1>,
+  // Optional<T>::operator=(U&&) where U is Optional<Test1> should be used
+  // rather than Optional<T>::operator=(Optional<U>&&) where U is Test1.
+  struct Test3 {
+    enum class State {
+      DEFAULT_CONSTRUCTED,
+      COPY_CONSTRUCTED_FROM_TEST1,
+      MOVE_CONSTRUCTED_FROM_TEST1,
+      COPY_CONSTRUCTED_FROM_OPTIONAL_TEST1,
+      MOVE_CONSTRUCTED_FROM_OPTIONAL_TEST1,
+      COPY_ASSIGNED_FROM_TEST1,
+      MOVE_ASSIGNED_FROM_TEST1,
+      COPY_ASSIGNED_FROM_OPTIONAL_TEST1,
+      MOVE_ASSIGNED_FROM_OPTIONAL_TEST1,
+    };
+
+    Test3() = default;
+    explicit Test3(const Test1& test1)
+        : state(State::COPY_CONSTRUCTED_FROM_TEST1) {}
+    explicit Test3(Test1&& test1) : state(State::MOVE_CONSTRUCTED_FROM_TEST1) {
+      test1.state = Test1::State::MOVED;
+    }
+    explicit Test3(const Optional<Test1>& test1)
+        : state(State::COPY_CONSTRUCTED_FROM_OPTIONAL_TEST1) {}
+    explicit Test3(Optional<Test1>&& test1)
+        : state(State::MOVE_CONSTRUCTED_FROM_OPTIONAL_TEST1) {
+      // In the following senarios, given |test1| should always have value.
+      DCHECK(test1.has_value());
+      test1->state = Test1::State::MOVED;
+    }
+    Test3& operator=(const Test1& test1) {
+      state = State::COPY_ASSIGNED_FROM_TEST1;
+      return *this;
+    }
+    Test3& operator=(Test1&& test1) {
+      state = State::MOVE_ASSIGNED_FROM_TEST1;
+      test1.state = Test1::State::MOVED;
+      return *this;
+    }
+    Test3& operator=(const Optional<Test1>& test1) {
+      state = State::COPY_ASSIGNED_FROM_OPTIONAL_TEST1;
+      return *this;
+    }
+    Test3& operator=(Optional<Test1>&& test1) {
+      state = State::MOVE_ASSIGNED_FROM_OPTIONAL_TEST1;
+      // In the following senarios, given |test1| should always have value.
+      DCHECK(test1.has_value());
+      test1->state = Test1::State::MOVED;
+      return *this;
+    }
+
+    State state = State::DEFAULT_CONSTRUCTED;
+  };
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test3> b;
+
+    b = a;
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::CONSTRUCTED, a->state);
+    EXPECT_EQ(Test3::State::COPY_CONSTRUCTED_FROM_OPTIONAL_TEST1, b->state);
+  }
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test3> b(in_place);
+
+    b = a;
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::CONSTRUCTED, a->state);
+    EXPECT_EQ(Test3::State::COPY_ASSIGNED_FROM_OPTIONAL_TEST1, b->state);
+  }
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test3> b;
+
+    b = std::move(a);
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::MOVED, a->state);
+    EXPECT_EQ(Test3::State::MOVE_CONSTRUCTED_FROM_OPTIONAL_TEST1, b->state);
+  }
+
+  {
+    Optional<Test1> a(in_place);
+    Optional<Test3> b(in_place);
+
+    b = std::move(a);
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(!!b);
+    EXPECT_EQ(Test1::State::MOVED, a->state);
+    EXPECT_EQ(Test3::State::MOVE_ASSIGNED_FROM_OPTIONAL_TEST1, b->state);
+  }
+}
+
+TEST(OptionalTest, OperatorStar) {
+  {
+    Optional<float> a(0.1f);
+    EXPECT_EQ(a.value(), *a);
+  }
+
+  {
+    Optional<std::string> a("foo");
+    EXPECT_EQ(a.value(), *a);
+  }
+
+  {
+    Optional<TestObject> a(TestObject(3, 0.1));
+    EXPECT_EQ(a.value(), *a);
+  }
+}
+
+TEST(OptionalTest, OperatorStar_rvalue) {
+  EXPECT_EQ(0.1f, *Optional<float>(0.1f));
+  EXPECT_EQ(std::string("foo"), *Optional<std::string>("foo"));
+  EXPECT_TRUE(TestObject(3, 0.1) == *Optional<TestObject>(TestObject(3, 0.1)));
+}
+
+TEST(OptionalTest, OperatorArrow) {
+  Optional<TestObject> a(TestObject(3, 0.1));
+  EXPECT_EQ(a->foo(), 3);
+}
+
+TEST(OptionalTest, Value_rvalue) {
+  EXPECT_EQ(0.1f, Optional<float>(0.1f).value());
+  EXPECT_EQ(std::string("foo"), Optional<std::string>("foo").value());
+  EXPECT_TRUE(TestObject(3, 0.1) ==
+              Optional<TestObject>(TestObject(3, 0.1)).value());
+}
+
+TEST(OptionalTest, ValueOr) {
+  {
+    Optional<float> a;
+    EXPECT_EQ(0.0f, a.value_or(0.0f));
+
+    a = 0.1f;
+    EXPECT_EQ(0.1f, a.value_or(0.0f));
+
+    a = base::nullopt;
+    EXPECT_EQ(0.0f, a.value_or(0.0f));
+  }
+
+  // value_or() can be constexpr.
+  {
+    constexpr Optional<int> a(in_place, 1);
+    constexpr int value = a.value_or(10);
+    EXPECT_EQ(1, value);
+  }
+  {
+    constexpr Optional<int> a;
+    constexpr int value = a.value_or(10);
+    EXPECT_EQ(10, value);
+  }
+
+  {
+    Optional<std::string> a;
+    EXPECT_EQ("bar", a.value_or("bar"));
+
+    a = std::string("foo");
+    EXPECT_EQ(std::string("foo"), a.value_or("bar"));
+
+    a = base::nullopt;
+    EXPECT_EQ(std::string("bar"), a.value_or("bar"));
+  }
+
+  {
+    Optional<TestObject> a;
+    EXPECT_TRUE(a.value_or(TestObject(1, 0.3)) == TestObject(1, 0.3));
+
+    a = TestObject(3, 0.1);
+    EXPECT_TRUE(a.value_or(TestObject(1, 0.3)) == TestObject(3, 0.1));
+
+    a = base::nullopt;
+    EXPECT_TRUE(a.value_or(TestObject(1, 0.3)) == TestObject(1, 0.3));
+  }
+}
+
+TEST(OptionalTest, Swap_bothNoValue) {
+  Optional<TestObject> a, b;
+  a.swap(b);
+
+  EXPECT_FALSE(a);
+  EXPECT_FALSE(b);
+  EXPECT_TRUE(TestObject(42, 0.42) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(42, 0.42) == b.value_or(TestObject(42, 0.42)));
+}
+
+TEST(OptionalTest, Swap_inHasValue) {
+  Optional<TestObject> a(TestObject(1, 0.3));
+  Optional<TestObject> b;
+  a.swap(b);
+
+  EXPECT_FALSE(a);
+
+  EXPECT_TRUE(!!b);
+  EXPECT_TRUE(TestObject(42, 0.42) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(1, 0.3) == b.value_or(TestObject(42, 0.42)));
+}
+
+TEST(OptionalTest, Swap_outHasValue) {
+  Optional<TestObject> a;
+  Optional<TestObject> b(TestObject(1, 0.3));
+  a.swap(b);
+
+  EXPECT_TRUE(!!a);
+  EXPECT_FALSE(!!b);
+  EXPECT_TRUE(TestObject(1, 0.3) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(42, 0.42) == b.value_or(TestObject(42, 0.42)));
+}
+
+TEST(OptionalTest, Swap_bothValue) {
+  Optional<TestObject> a(TestObject(0, 0.1));
+  Optional<TestObject> b(TestObject(1, 0.3));
+  a.swap(b);
+
+  EXPECT_TRUE(!!a);
+  EXPECT_TRUE(!!b);
+  EXPECT_TRUE(TestObject(1, 0.3) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(0, 0.1) == b.value_or(TestObject(42, 0.42)));
+  EXPECT_EQ(TestObject::State::SWAPPED, a->state());
+  EXPECT_EQ(TestObject::State::SWAPPED, b->state());
+}
+
+TEST(OptionalTest, Emplace) {
+  {
+    Optional<float> a(0.1f);
+    EXPECT_EQ(0.3f, a.emplace(0.3f));
+
+    EXPECT_TRUE(a);
+    EXPECT_EQ(0.3f, a.value());
+  }
+
+  {
+    Optional<std::string> a("foo");
+    EXPECT_EQ("bar", a.emplace("bar"));
+
+    EXPECT_TRUE(a);
+    EXPECT_EQ("bar", a.value());
+  }
+
+  {
+    Optional<TestObject> a(TestObject(0, 0.1));
+    EXPECT_EQ(TestObject(1, 0.2), a.emplace(TestObject(1, 0.2)));
+
+    EXPECT_TRUE(!!a);
+    EXPECT_TRUE(TestObject(1, 0.2) == a.value());
+  }
+
+  {
+    Optional<std::vector<int>> a;
+    auto& ref = a.emplace({2, 3});
+    static_assert(std::is_same<std::vector<int>&, decltype(ref)>::value, "");
+    EXPECT_TRUE(a);
+    EXPECT_THAT(*a, ElementsAre(2, 3));
+    EXPECT_EQ(&ref, &*a);
+  }
+
+  {
+    Optional<std::vector<int>> a;
+    auto& ref = a.emplace({4, 5}, std::allocator<int>());
+    static_assert(std::is_same<std::vector<int>&, decltype(ref)>::value, "");
+    EXPECT_TRUE(a);
+    EXPECT_THAT(*a, ElementsAre(4, 5));
+    EXPECT_EQ(&ref, &*a);
+  }
+}
+
+TEST(OptionalTest, Equals_TwoEmpty) {
+  Optional<int> a;
+  Optional<int> b;
+
+  EXPECT_TRUE(a == b);
+}
+
+TEST(OptionalTest, Equals_TwoEquals) {
+  Optional<int> a(1);
+  Optional<int> b(1);
+
+  EXPECT_TRUE(a == b);
+}
+
+TEST(OptionalTest, Equals_OneEmpty) {
+  Optional<int> a;
+  Optional<int> b(1);
+
+  EXPECT_FALSE(a == b);
+}
+
+TEST(OptionalTest, Equals_TwoDifferent) {
+  Optional<int> a(0);
+  Optional<int> b(1);
+
+  EXPECT_FALSE(a == b);
+}
+
+TEST(OptionalTest, Equals_DifferentType) {
+  Optional<int> a(0);
+  Optional<double> b(0);
+
+  EXPECT_TRUE(a == b);
+}
+
+TEST(OptionalTest, NotEquals_TwoEmpty) {
+  Optional<int> a;
+  Optional<int> b;
+
+  EXPECT_FALSE(a != b);
+}
+
+TEST(OptionalTest, NotEquals_TwoEquals) {
+  Optional<int> a(1);
+  Optional<int> b(1);
+
+  EXPECT_FALSE(a != b);
+}
+
+TEST(OptionalTest, NotEquals_OneEmpty) {
+  Optional<int> a;
+  Optional<int> b(1);
+
+  EXPECT_TRUE(a != b);
+}
+
+TEST(OptionalTest, NotEquals_TwoDifferent) {
+  Optional<int> a(0);
+  Optional<int> b(1);
+
+  EXPECT_TRUE(a != b);
+}
+
+TEST(OptionalTest, NotEquals_DifferentType) {
+  Optional<int> a(0);
+  Optional<double> b(0.0);
+
+  EXPECT_FALSE(a != b);
+}
+
+TEST(OptionalTest, Less_LeftEmpty) {
+  Optional<int> l;
+  Optional<int> r(1);
+
+  EXPECT_TRUE(l < r);
+}
+
+TEST(OptionalTest, Less_RightEmpty) {
+  Optional<int> l(1);
+  Optional<int> r;
+
+  EXPECT_FALSE(l < r);
+}
+
+TEST(OptionalTest, Less_BothEmpty) {
+  Optional<int> l;
+  Optional<int> r;
+
+  EXPECT_FALSE(l < r);
+}
+
+TEST(OptionalTest, Less_BothValues) {
+  {
+    Optional<int> l(1);
+    Optional<int> r(2);
+
+    EXPECT_TRUE(l < r);
+  }
+  {
+    Optional<int> l(2);
+    Optional<int> r(1);
+
+    EXPECT_FALSE(l < r);
+  }
+  {
+    Optional<int> l(1);
+    Optional<int> r(1);
+
+    EXPECT_FALSE(l < r);
+  }
+}
+
+TEST(OptionalTest, Less_DifferentType) {
+  Optional<int> l(1);
+  Optional<double> r(2.0);
+
+  EXPECT_TRUE(l < r);
+}
+
+TEST(OptionalTest, LessEq_LeftEmpty) {
+  Optional<int> l;
+  Optional<int> r(1);
+
+  EXPECT_TRUE(l <= r);
+}
+
+TEST(OptionalTest, LessEq_RightEmpty) {
+  Optional<int> l(1);
+  Optional<int> r;
+
+  EXPECT_FALSE(l <= r);
+}
+
+TEST(OptionalTest, LessEq_BothEmpty) {
+  Optional<int> l;
+  Optional<int> r;
+
+  EXPECT_TRUE(l <= r);
+}
+
+TEST(OptionalTest, LessEq_BothValues) {
+  {
+    Optional<int> l(1);
+    Optional<int> r(2);
+
+    EXPECT_TRUE(l <= r);
+  }
+  {
+    Optional<int> l(2);
+    Optional<int> r(1);
+
+    EXPECT_FALSE(l <= r);
+  }
+  {
+    Optional<int> l(1);
+    Optional<int> r(1);
+
+    EXPECT_TRUE(l <= r);
+  }
+}
+
+TEST(OptionalTest, LessEq_DifferentType) {
+  Optional<int> l(1);
+  Optional<double> r(2.0);
+
+  EXPECT_TRUE(l <= r);
+}
+
+TEST(OptionalTest, Greater_BothEmpty) {
+  Optional<int> l;
+  Optional<int> r;
+
+  EXPECT_FALSE(l > r);
+}
+
+TEST(OptionalTest, Greater_LeftEmpty) {
+  Optional<int> l;
+  Optional<int> r(1);
+
+  EXPECT_FALSE(l > r);
+}
+
+TEST(OptionalTest, Greater_RightEmpty) {
+  Optional<int> l(1);
+  Optional<int> r;
+
+  EXPECT_TRUE(l > r);
+}
+
+TEST(OptionalTest, Greater_BothValue) {
+  {
+    Optional<int> l(1);
+    Optional<int> r(2);
+
+    EXPECT_FALSE(l > r);
+  }
+  {
+    Optional<int> l(2);
+    Optional<int> r(1);
+
+    EXPECT_TRUE(l > r);
+  }
+  {
+    Optional<int> l(1);
+    Optional<int> r(1);
+
+    EXPECT_FALSE(l > r);
+  }
+}
+
+TEST(OptionalTest, Greater_DifferentType) {
+  Optional<int> l(1);
+  Optional<double> r(2.0);
+
+  EXPECT_FALSE(l > r);
+}
+
+TEST(OptionalTest, GreaterEq_BothEmpty) {
+  Optional<int> l;
+  Optional<int> r;
+
+  EXPECT_TRUE(l >= r);
+}
+
+TEST(OptionalTest, GreaterEq_LeftEmpty) {
+  Optional<int> l;
+  Optional<int> r(1);
+
+  EXPECT_FALSE(l >= r);
+}
+
+TEST(OptionalTest, GreaterEq_RightEmpty) {
+  Optional<int> l(1);
+  Optional<int> r;
+
+  EXPECT_TRUE(l >= r);
+}
+
+TEST(OptionalTest, GreaterEq_BothValue) {
+  {
+    Optional<int> l(1);
+    Optional<int> r(2);
+
+    EXPECT_FALSE(l >= r);
+  }
+  {
+    Optional<int> l(2);
+    Optional<int> r(1);
+
+    EXPECT_TRUE(l >= r);
+  }
+  {
+    Optional<int> l(1);
+    Optional<int> r(1);
+
+    EXPECT_TRUE(l >= r);
+  }
+}
+
+TEST(OptionalTest, GreaterEq_DifferentType) {
+  Optional<int> l(1);
+  Optional<double> r(2.0);
+
+  EXPECT_FALSE(l >= r);
+}
+
+TEST(OptionalTest, OptNullEq) {
+  {
+    Optional<int> opt;
+    EXPECT_TRUE(opt == base::nullopt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(opt == base::nullopt);
+  }
+}
+
+TEST(OptionalTest, NullOptEq) {
+  {
+    Optional<int> opt;
+    EXPECT_TRUE(base::nullopt == opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(base::nullopt == opt);
+  }
+}
+
+TEST(OptionalTest, OptNullNotEq) {
+  {
+    Optional<int> opt;
+    EXPECT_FALSE(opt != base::nullopt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(opt != base::nullopt);
+  }
+}
+
+TEST(OptionalTest, NullOptNotEq) {
+  {
+    Optional<int> opt;
+    EXPECT_FALSE(base::nullopt != opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(base::nullopt != opt);
+  }
+}
+
+TEST(OptionalTest, OptNullLower) {
+  {
+    Optional<int> opt;
+    EXPECT_FALSE(opt < base::nullopt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(opt < base::nullopt);
+  }
+}
+
+TEST(OptionalTest, NullOptLower) {
+  {
+    Optional<int> opt;
+    EXPECT_FALSE(base::nullopt < opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(base::nullopt < opt);
+  }
+}
+
+TEST(OptionalTest, OptNullLowerEq) {
+  {
+    Optional<int> opt;
+    EXPECT_TRUE(opt <= base::nullopt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(opt <= base::nullopt);
+  }
+}
+
+TEST(OptionalTest, NullOptLowerEq) {
+  {
+    Optional<int> opt;
+    EXPECT_TRUE(base::nullopt <= opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(base::nullopt <= opt);
+  }
+}
+
+TEST(OptionalTest, OptNullGreater) {
+  {
+    Optional<int> opt;
+    EXPECT_FALSE(opt > base::nullopt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(opt > base::nullopt);
+  }
+}
+
+TEST(OptionalTest, NullOptGreater) {
+  {
+    Optional<int> opt;
+    EXPECT_FALSE(base::nullopt > opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(base::nullopt > opt);
+  }
+}
+
+TEST(OptionalTest, OptNullGreaterEq) {
+  {
+    Optional<int> opt;
+    EXPECT_TRUE(opt >= base::nullopt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(opt >= base::nullopt);
+  }
+}
+
+TEST(OptionalTest, NullOptGreaterEq) {
+  {
+    Optional<int> opt;
+    EXPECT_TRUE(base::nullopt >= opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(base::nullopt >= opt);
+  }
+}
+
+TEST(OptionalTest, ValueEq_Empty) {
+  Optional<int> opt;
+  EXPECT_FALSE(opt == 1);
+}
+
+TEST(OptionalTest, ValueEq_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_FALSE(opt == 1);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(opt == 1);
+  }
+}
+
+TEST(OptionalTest, ValueEq_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_TRUE(opt == 0.0);
+}
+
+TEST(OptionalTest, EqValue_Empty) {
+  Optional<int> opt;
+  EXPECT_FALSE(1 == opt);
+}
+
+TEST(OptionalTest, EqValue_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_FALSE(1 == opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(1 == opt);
+  }
+}
+
+TEST(OptionalTest, EqValue_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_TRUE(0.0 == opt);
+}
+
+TEST(OptionalTest, ValueNotEq_Empty) {
+  Optional<int> opt;
+  EXPECT_TRUE(opt != 1);
+}
+
+TEST(OptionalTest, ValueNotEq_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_TRUE(opt != 1);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(opt != 1);
+  }
+}
+
+TEST(OPtionalTest, ValueNotEq_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_FALSE(opt != 0.0);
+}
+
+TEST(OptionalTest, NotEqValue_Empty) {
+  Optional<int> opt;
+  EXPECT_TRUE(1 != opt);
+}
+
+TEST(OptionalTest, NotEqValue_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_TRUE(1 != opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(1 != opt);
+  }
+}
+
+TEST(OptionalTest, NotEqValue_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_FALSE(0.0 != opt);
+}
+
+TEST(OptionalTest, ValueLess_Empty) {
+  Optional<int> opt;
+  EXPECT_TRUE(opt < 1);
+}
+
+TEST(OptionalTest, ValueLess_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_TRUE(opt < 1);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(opt < 1);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_FALSE(opt < 1);
+  }
+}
+
+TEST(OPtionalTest, ValueLess_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_TRUE(opt < 1.0);
+}
+
+TEST(OptionalTest, LessValue_Empty) {
+  Optional<int> opt;
+  EXPECT_FALSE(1 < opt);
+}
+
+TEST(OptionalTest, LessValue_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_FALSE(1 < opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(1 < opt);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_TRUE(1 < opt);
+  }
+}
+
+TEST(OptionalTest, LessValue_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_FALSE(0.0 < opt);
+}
+
+TEST(OptionalTest, ValueLessEq_Empty) {
+  Optional<int> opt;
+  EXPECT_TRUE(opt <= 1);
+}
+
+TEST(OptionalTest, ValueLessEq_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_TRUE(opt <= 1);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(opt <= 1);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_FALSE(opt <= 1);
+  }
+}
+
+TEST(OptionalTest, ValueLessEq_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_TRUE(opt <= 0.0);
+}
+
+TEST(OptionalTest, LessEqValue_Empty) {
+  Optional<int> opt;
+  EXPECT_FALSE(1 <= opt);
+}
+
+TEST(OptionalTest, LessEqValue_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_FALSE(1 <= opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(1 <= opt);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_TRUE(1 <= opt);
+  }
+}
+
+TEST(OptionalTest, LessEqValue_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_TRUE(0.0 <= opt);
+}
+
+TEST(OptionalTest, ValueGreater_Empty) {
+  Optional<int> opt;
+  EXPECT_FALSE(opt > 1);
+}
+
+TEST(OptionalTest, ValueGreater_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_FALSE(opt > 1);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(opt > 1);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_TRUE(opt > 1);
+  }
+}
+
+TEST(OptionalTest, ValueGreater_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_FALSE(opt > 0.0);
+}
+
+TEST(OptionalTest, GreaterValue_Empty) {
+  Optional<int> opt;
+  EXPECT_TRUE(1 > opt);
+}
+
+TEST(OptionalTest, GreaterValue_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_TRUE(1 > opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_FALSE(1 > opt);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_FALSE(1 > opt);
+  }
+}
+
+TEST(OptionalTest, GreaterValue_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_FALSE(0.0 > opt);
+}
+
+TEST(OptionalTest, ValueGreaterEq_Empty) {
+  Optional<int> opt;
+  EXPECT_FALSE(opt >= 1);
+}
+
+TEST(OptionalTest, ValueGreaterEq_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_FALSE(opt >= 1);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(opt >= 1);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_TRUE(opt >= 1);
+  }
+}
+
+TEST(OptionalTest, ValueGreaterEq_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_TRUE(opt <= 0.0);
+}
+
+TEST(OptionalTest, GreaterEqValue_Empty) {
+  Optional<int> opt;
+  EXPECT_TRUE(1 >= opt);
+}
+
+TEST(OptionalTest, GreaterEqValue_NotEmpty) {
+  {
+    Optional<int> opt(0);
+    EXPECT_TRUE(1 >= opt);
+  }
+  {
+    Optional<int> opt(1);
+    EXPECT_TRUE(1 >= opt);
+  }
+  {
+    Optional<int> opt(2);
+    EXPECT_FALSE(1 >= opt);
+  }
+}
+
+TEST(OptionalTest, GreaterEqValue_DifferentType) {
+  Optional<int> opt(0);
+  EXPECT_TRUE(0.0 >= opt);
+}
+
+TEST(OptionalTest, NotEquals) {
+  {
+    Optional<float> a(0.1f);
+    Optional<float> b(0.2f);
+    EXPECT_NE(a, b);
+  }
+
+  {
+    Optional<std::string> a("foo");
+    Optional<std::string> b("bar");
+    EXPECT_NE(a, b);
+  }
+
+  {
+    Optional<int> a(1);
+    Optional<double> b(2);
+    EXPECT_NE(a, b);
+  }
+
+  {
+    Optional<TestObject> a(TestObject(3, 0.1));
+    Optional<TestObject> b(TestObject(4, 1.0));
+    EXPECT_TRUE(a != b);
+  }
+}
+
+TEST(OptionalTest, NotEqualsNull) {
+  {
+    Optional<float> a(0.1f);
+    Optional<float> b(0.1f);
+    b = base::nullopt;
+    EXPECT_NE(a, b);
+  }
+
+  {
+    Optional<std::string> a("foo");
+    Optional<std::string> b("foo");
+    b = base::nullopt;
+    EXPECT_NE(a, b);
+  }
+
+  {
+    Optional<TestObject> a(TestObject(3, 0.1));
+    Optional<TestObject> b(TestObject(3, 0.1));
+    b = base::nullopt;
+    EXPECT_TRUE(a != b);
+  }
+}
+
+TEST(OptionalTest, MakeOptional) {
+  {
+    Optional<float> o = make_optional(32.f);
+    EXPECT_TRUE(o);
+    EXPECT_EQ(32.f, *o);
+
+    float value = 3.f;
+    o = make_optional(std::move(value));
+    EXPECT_TRUE(o);
+    EXPECT_EQ(3.f, *o);
+  }
+
+  {
+    Optional<std::string> o = make_optional(std::string("foo"));
+    EXPECT_TRUE(o);
+    EXPECT_EQ("foo", *o);
+
+    std::string value = "bar";
+    o = make_optional(std::move(value));
+    EXPECT_TRUE(o);
+    EXPECT_EQ(std::string("bar"), *o);
+  }
+
+  {
+    Optional<TestObject> o = make_optional(TestObject(3, 0.1));
+    EXPECT_TRUE(!!o);
+    EXPECT_TRUE(TestObject(3, 0.1) == *o);
+
+    TestObject value = TestObject(0, 0.42);
+    o = make_optional(std::move(value));
+    EXPECT_TRUE(!!o);
+    EXPECT_TRUE(TestObject(0, 0.42) == *o);
+    EXPECT_EQ(TestObject::State::MOVED_FROM, value.state());
+    EXPECT_EQ(TestObject::State::MOVE_ASSIGNED, o->state());
+
+    EXPECT_EQ(TestObject::State::MOVE_CONSTRUCTED,
+              base::make_optional(std::move(value))->state());
+  }
+
+  {
+    struct Test {
+      Test(int a, double b, bool c) : a(a), b(b), c(c) {}
+
+      int a;
+      double b;
+      bool c;
+    };
+
+    Optional<Test> o = make_optional<Test>(1, 2.0, true);
+    EXPECT_TRUE(!!o);
+    EXPECT_EQ(1, o->a);
+    EXPECT_EQ(2.0, o->b);
+    EXPECT_TRUE(o->c);
+  }
+
+  {
+    auto str1 = make_optional<std::string>({'1', '2', '3'});
+    EXPECT_EQ("123", *str1);
+
+    auto str2 =
+        make_optional<std::string>({'a', 'b', 'c'}, std::allocator<char>());
+    EXPECT_EQ("abc", *str2);
+  }
+}
+
+TEST(OptionalTest, NonMemberSwap_bothNoValue) {
+  Optional<TestObject> a, b;
+  base::swap(a, b);
+
+  EXPECT_FALSE(!!a);
+  EXPECT_FALSE(!!b);
+  EXPECT_TRUE(TestObject(42, 0.42) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(42, 0.42) == b.value_or(TestObject(42, 0.42)));
+}
+
+TEST(OptionalTest, NonMemberSwap_inHasValue) {
+  Optional<TestObject> a(TestObject(1, 0.3));
+  Optional<TestObject> b;
+  base::swap(a, b);
+
+  EXPECT_FALSE(!!a);
+  EXPECT_TRUE(!!b);
+  EXPECT_TRUE(TestObject(42, 0.42) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(1, 0.3) == b.value_or(TestObject(42, 0.42)));
+}
+
+TEST(OptionalTest, NonMemberSwap_outHasValue) {
+  Optional<TestObject> a;
+  Optional<TestObject> b(TestObject(1, 0.3));
+  base::swap(a, b);
+
+  EXPECT_TRUE(!!a);
+  EXPECT_FALSE(!!b);
+  EXPECT_TRUE(TestObject(1, 0.3) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(42, 0.42) == b.value_or(TestObject(42, 0.42)));
+}
+
+TEST(OptionalTest, NonMemberSwap_bothValue) {
+  Optional<TestObject> a(TestObject(0, 0.1));
+  Optional<TestObject> b(TestObject(1, 0.3));
+  base::swap(a, b);
+
+  EXPECT_TRUE(!!a);
+  EXPECT_TRUE(!!b);
+  EXPECT_TRUE(TestObject(1, 0.3) == a.value_or(TestObject(42, 0.42)));
+  EXPECT_TRUE(TestObject(0, 0.1) == b.value_or(TestObject(42, 0.42)));
+  EXPECT_EQ(TestObject::State::SWAPPED, a->state());
+  EXPECT_EQ(TestObject::State::SWAPPED, b->state());
+}
+
+TEST(OptionalTest, Hash_OptionalReflectsInternal) {
+  {
+    std::hash<int> int_hash;
+    std::hash<Optional<int>> opt_int_hash;
+
+    EXPECT_EQ(int_hash(1), opt_int_hash(Optional<int>(1)));
+  }
+
+  {
+    std::hash<std::string> str_hash;
+    std::hash<Optional<std::string>> opt_str_hash;
+
+    EXPECT_EQ(str_hash(std::string("foobar")),
+              opt_str_hash(Optional<std::string>(std::string("foobar"))));
+  }
+}
+
+TEST(OptionalTest, Hash_NullOptEqualsNullOpt) {
+  std::hash<Optional<int>> opt_int_hash;
+  std::hash<Optional<std::string>> opt_str_hash;
+
+  EXPECT_EQ(opt_str_hash(Optional<std::string>()),
+            opt_int_hash(Optional<int>()));
+}
+
+TEST(OptionalTest, Hash_UseInSet) {
+  std::set<Optional<int>> setOptInt;
+
+  EXPECT_EQ(setOptInt.end(), setOptInt.find(42));
+
+  setOptInt.insert(Optional<int>(3));
+  EXPECT_EQ(setOptInt.end(), setOptInt.find(42));
+  EXPECT_NE(setOptInt.end(), setOptInt.find(3));
+}
+
+TEST(OptionalTest, HasValue) {
+  Optional<int> a;
+  EXPECT_FALSE(a.has_value());
+
+  a = 42;
+  EXPECT_TRUE(a.has_value());
+
+  a = nullopt;
+  EXPECT_FALSE(a.has_value());
+
+  a = 0;
+  EXPECT_TRUE(a.has_value());
+
+  a = Optional<int>();
+  EXPECT_FALSE(a.has_value());
+}
+
+TEST(OptionalTest, Reset_int) {
+  Optional<int> a(0);
+  EXPECT_TRUE(a.has_value());
+  EXPECT_EQ(0, a.value());
+
+  a.reset();
+  EXPECT_FALSE(a.has_value());
+  EXPECT_EQ(-1, a.value_or(-1));
+}
+
+TEST(OptionalTest, Reset_Object) {
+  Optional<TestObject> a(TestObject(0, 0.1));
+  EXPECT_TRUE(a.has_value());
+  EXPECT_EQ(TestObject(0, 0.1), a.value());
+
+  a.reset();
+  EXPECT_FALSE(a.has_value());
+  EXPECT_EQ(TestObject(42, 0.0), a.value_or(TestObject(42, 0.0)));
+}
+
+TEST(OptionalTest, Reset_NoOp) {
+  Optional<int> a;
+  EXPECT_FALSE(a.has_value());
+
+  a.reset();
+  EXPECT_FALSE(a.has_value());
+}
+
+TEST(OptionalTest, AssignFromRValue) {
+  Optional<TestObject> a;
+  EXPECT_FALSE(a.has_value());
+
+  TestObject obj;
+  a = std::move(obj);
+  EXPECT_TRUE(a.has_value());
+  EXPECT_EQ(1, a->move_ctors_count());
+}
+
+TEST(OptionalTest, DontCallDefaultCtor) {
+  Optional<DeletedDefaultConstructor> a;
+  EXPECT_FALSE(a.has_value());
+
+  a = base::make_optional<DeletedDefaultConstructor>(42);
+  EXPECT_TRUE(a.has_value());
+  EXPECT_EQ(42, a->foo());
+}
+
+TEST(OptionalTest, DontCallNewMemberFunction) {
+  Optional<DeleteNewOperators> a;
+  EXPECT_FALSE(a.has_value());
+
+  a = DeleteNewOperators();
+  EXPECT_TRUE(a.has_value());
+}
+
+TEST(OptionalTest, Noexcept) {
+  // Trivial copy ctor, non-trivial move ctor, nothrow move assign.
+  struct Test1 {
+    Test1(const Test1&) = default;
+    Test1(Test1&&) {}
+    Test1& operator=(Test1&&) = default;
+  };
+  // Non-trivial copy ctor, trivial move ctor, throw move assign.
+  struct Test2 {
+    Test2(const Test2&) {}
+    Test2(Test2&&) = default;
+    Test2& operator=(Test2&&) { return *this; }
+  };
+  // Trivial copy ctor, non-trivial nothrow move ctor.
+  struct Test3 {
+    Test3(const Test3&) = default;
+    Test3(Test3&&) noexcept {}
+  };
+  // Non-trivial copy ctor, non-trivial nothrow move ctor.
+  struct Test4 {
+    Test4(const Test4&) {}
+    Test4(Test4&&) noexcept {}
+  };
+  // Non-trivial copy ctor, non-trivial move ctor.
+  struct Test5 {
+    Test5(const Test5&) {}
+    Test5(Test5&&) {}
+  };
+
+  static_assert(
+      noexcept(Optional<int>(std::declval<Optional<int>>())),
+      "move constructor for noexcept move-constructible T must be noexcept "
+      "(trivial copy, trivial move)");
+  static_assert(
+      !noexcept(Optional<Test1>(std::declval<Optional<Test1>>())),
+      "move constructor for non-noexcept move-constructible T must not be "
+      "noexcept (trivial copy)");
+  static_assert(
+      noexcept(Optional<Test2>(std::declval<Optional<Test2>>())),
+      "move constructor for noexcept move-constructible T must be noexcept "
+      "(non-trivial copy, trivial move)");
+  static_assert(
+      noexcept(Optional<Test3>(std::declval<Optional<Test3>>())),
+      "move constructor for noexcept move-constructible T must be noexcept "
+      "(trivial copy, non-trivial move)");
+  static_assert(
+      noexcept(Optional<Test4>(std::declval<Optional<Test4>>())),
+      "move constructor for noexcept move-constructible T must be noexcept "
+      "(non-trivial copy, non-trivial move)");
+  static_assert(
+      !noexcept(Optional<Test5>(std::declval<Optional<Test5>>())),
+      "move constructor for non-noexcept move-constructible T must not be "
+      "noexcept (non-trivial copy)");
+
+  static_assert(
+      noexcept(std::declval<Optional<int>>() = std::declval<Optional<int>>()),
+      "move assign for noexcept move-constructible/move-assignable T "
+      "must be noexcept");
+  static_assert(
+      !noexcept(std::declval<Optional<Test1>>() =
+                    std::declval<Optional<Test1>>()),
+      "move assign for non-noexcept move-constructible T must not be noexcept");
+  static_assert(
+      !noexcept(std::declval<Optional<Test2>>() =
+                    std::declval<Optional<Test2>>()),
+      "move assign for non-noexcept move-assignable T must not be noexcept");
+}
+
+}  // namespace base
-- 
2.19.0.rc0.228.g281dcd1b4d0-goog

