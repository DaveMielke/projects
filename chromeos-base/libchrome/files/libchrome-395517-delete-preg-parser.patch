diff --git a/SConstruct b/SConstruct
index 99c00c9..704ebdb 100644
--- a/SConstruct
+++ b/SConstruct
@@ -242,7 +242,6 @@ base_libs = [
     'name' : 'policy',
     'sources' : """
                 core/common/policy_load_status.cc
-                core/common/preg_parser.cc
                 core/common/registry_dict.cc
                 """,
     'prefix' : 'components/policy',

diff --git a/components/policy/core/common/preg_parser.cc b/components/policy/core/common/preg_parser.cc
deleted file mode 100644
index a0bac73..0000000
--- a/components/policy/core/common/preg_parser.cc
+++ /dev/null
@@ -1,351 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "components/policy/core/common/preg_parser.h"
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include <algorithm>
-#include <functional>
-#include <iterator>
-#include <limits>
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/files/file_path.h"
-#include "base/files/memory_mapped_file.h"
-#include "base/logging.h"
-#include "base/macros.h"
-#include "base/memory/ptr_util.h"
-#include "base/strings/string16.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/sys_byteorder.h"
-#include "base/values.h"
-#include "components/policy/core/common/policy_load_status.h"
-#include "components/policy/core/common/registry_dict.h"
-
-#if defined(OS_WIN)
-#include "windows.h"
-#else
-// Registry data type constants.
-#define REG_NONE 0
-#define REG_SZ 1
-#define REG_EXPAND_SZ 2
-#define REG_BINARY 3
-#define REG_DWORD_LITTLE_ENDIAN 4
-#define REG_DWORD_BIG_ENDIAN 5
-#define REG_LINK 6
-#define REG_MULTI_SZ 7
-#define REG_RESOURCE_LIST 8
-#define REG_FULL_RESOURCE_DESCRIPTOR 9
-#define REG_RESOURCE_REQUIREMENTS_LIST 10
-#define REG_QWORD_LITTLE_ENDIAN 11
-#endif
-
-using RegistryDict = policy::RegistryDict;
-
-namespace {
-
-// Maximum PReg file size we're willing to accept.
-const int64_t kMaxPRegFileSize = 1024 * 1024 * 16;
-static_assert(kMaxPRegFileSize <= std::numeric_limits<ptrdiff_t>::max(),
-              "Max PReg file size too large.");
-
-// Constants for PReg file delimiters.
-const base::char16 kDelimBracketOpen = L'[';
-const base::char16 kDelimBracketClose = L']';
-const base::char16 kDelimSemicolon = L';';
-
-// Registry path separator.
-const base::string16 kRegistryPathSeparator = base::ASCIIToUTF16("\\");
-
-// Magic strings for the PReg value field to trigger special actions.
-const char kActionTriggerPrefix[] = "**";
-const char kActionTriggerDeleteValues[] = "deletevalues";
-const char kActionTriggerDel[] = "del.";
-const char kActionTriggerDelVals[] = "delvals";
-const char kActionTriggerDeleteKeys[] = "deletekeys";
-const char kActionTriggerSecureKey[] = "securekey";
-const char kActionTriggerSoft[] = "soft";
-
-// Returns the character at |cursor| and increments it, unless the end is here
-// in which case -1 is returned. The calling code must guarantee that
-// end - *cursor does not overflow ptrdiff_t.
-int NextChar(const uint8_t** cursor, const uint8_t* end) {
-  // Only read the character if a full base::char16 is available.
-  // This comparison makes sure no overflow can happen.
-  if (*cursor >= end ||
-      end - *cursor < static_cast<ptrdiff_t>(sizeof(base::char16)))
-    return -1;
-
-  int result = **cursor | (*(*cursor + 1) << 8);
-  *cursor += sizeof(base::char16);
-  return result;
-}
-
-// Reads a fixed-size field from a PReg file. The calling code must guarantee
-// that both end - *cursor and size do not overflow ptrdiff_t.
-bool ReadFieldBinary(const uint8_t** cursor,
-                     const uint8_t* end,
-                     uint32_t size,
-                     uint8_t* data) {
-  if (size == 0)
-    return true;
-
-  // Be careful to prevent possible overflows here (don't do *cursor + size).
-  if (*cursor >= end || end - *cursor < static_cast<ptrdiff_t>(size))
-    return false;
-  const uint8_t* field_end = *cursor + size;
-  std::copy(*cursor, field_end, data);
-  *cursor = field_end;
-  return true;
-}
-
-bool ReadField32(const uint8_t** cursor, const uint8_t* end, uint32_t* data) {
-  uint32_t value = 0;
-  if (!ReadFieldBinary(cursor, end, sizeof(uint32_t),
-                       reinterpret_cast<uint8_t*>(&value))) {
-    return false;
-  }
-  *data = base::ByteSwapToLE32(value);
-  return true;
-}
-
-// Reads a string field from a file.
-bool ReadFieldString(const uint8_t** cursor,
-                     const uint8_t* end,
-                     base::string16* str) {
-  int current = -1;
-  while ((current = NextChar(cursor, end)) > 0x0000)
-    *str += current;
-
-  return current == L'\0';
-}
-
-std::string DecodePRegStringValue(const std::vector<uint8_t>& data) {
-  size_t len = data.size() / sizeof(base::char16);
-  if (len <= 0)
-    return std::string();
-
-  const base::char16* chars =
-      reinterpret_cast<const base::char16*>(data.data());
-  base::string16 result;
-  std::transform(chars, chars + len - 1, std::back_inserter(result),
-                 std::ptr_fun(base::ByteSwapToLE16));
-  return base::UTF16ToUTF8(result);
-}
-
-// Decodes a value from a PReg file given as a uint8_t vector.
-bool DecodePRegValue(uint32_t type,
-                     const std::vector<uint8_t>& data,
-                     std::unique_ptr<base::Value>* value) {
-  switch (type) {
-    case REG_SZ:
-    case REG_EXPAND_SZ:
-      value->reset(new base::StringValue(DecodePRegStringValue(data)));
-      return true;
-    case REG_DWORD_LITTLE_ENDIAN:
-    case REG_DWORD_BIG_ENDIAN:
-      if (data.size() == sizeof(uint32_t)) {
-        uint32_t val = *reinterpret_cast<const uint32_t*>(data.data());
-        if (type == REG_DWORD_BIG_ENDIAN)
-          val = base::NetToHost32(val);
-        else
-          val = base::ByteSwapToLE32(val);
-        value->reset(new base::FundamentalValue(static_cast<int>(val)));
-        return true;
-      } else {
-        LOG(ERROR) << "Bad data size " << data.size();
-      }
-      break;
-    case REG_NONE:
-    case REG_LINK:
-    case REG_MULTI_SZ:
-    case REG_RESOURCE_LIST:
-    case REG_FULL_RESOURCE_DESCRIPTOR:
-    case REG_RESOURCE_REQUIREMENTS_LIST:
-    case REG_QWORD_LITTLE_ENDIAN:
-    default:
-      LOG(ERROR) << "Unsupported registry data type " << type;
-  }
-
-  return false;
-}
-
-// Adds |value| and |data| to |dict| or an appropriate sub-dictionary indicated
-// by |key_name|. Creates sub-dictionaries if necessary. Also handles special
-// action triggers, see |kActionTrigger*|, that can, for instance, remove an
-// existing value.
-void HandleRecord(const base::string16& key_name,
-                  const base::string16& value,
-                  uint32_t type,
-                  const std::vector<uint8_t>& data,
-                  RegistryDict* dict) {
-  // Locate/create the dictionary to place the value in.
-  std::vector<base::string16> path;
-
-  for (const base::string16& entry :
-       base::SplitString(key_name, kRegistryPathSeparator,
-                         base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY)) {
-    if (entry.empty())
-      continue;
-    const std::string name = base::UTF16ToUTF8(entry);
-    RegistryDict* subdict = dict->GetKey(name);
-    if (!subdict) {
-      subdict = new RegistryDict();
-      dict->SetKey(name, base::WrapUnique(subdict));
-    }
-    dict = subdict;
-  }
-
-  if (value.empty())
-    return;
-
-  std::string value_name(base::UTF16ToUTF8(value));
-  if (!base::StartsWith(value_name, kActionTriggerPrefix,
-                        base::CompareCase::SENSITIVE)) {
-    std::unique_ptr<base::Value> value;
-    if (DecodePRegValue(type, data, &value))
-      dict->SetValue(value_name, std::move(value));
-    return;
-  }
-
-  std::string action_trigger(base::ToLowerASCII(
-      value_name.substr(arraysize(kActionTriggerPrefix) - 1)));
-  if (action_trigger == kActionTriggerDeleteValues) {
-    for (const std::string& value :
-         base::SplitString(DecodePRegStringValue(data), ";",
-                           base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY))
-      dict->RemoveValue(value);
-  } else if (base::StartsWith(action_trigger, kActionTriggerDeleteKeys,
-                              base::CompareCase::SENSITIVE)) {
-    for (const std::string& key :
-         base::SplitString(DecodePRegStringValue(data), ";",
-                           base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY))
-      dict->RemoveKey(key);
-  } else if (base::StartsWith(action_trigger, kActionTriggerDel,
-                              base::CompareCase::SENSITIVE)) {
-    dict->RemoveValue(value_name.substr(arraysize(kActionTriggerPrefix) - 1 +
-                                        arraysize(kActionTriggerDel) - 1));
-  } else if (base::StartsWith(action_trigger, kActionTriggerDelVals,
-                              base::CompareCase::SENSITIVE)) {
-    // Delete all values.
-    dict->ClearValues();
-  } else if (base::StartsWith(action_trigger, kActionTriggerSecureKey,
-                              base::CompareCase::SENSITIVE) ||
-             base::StartsWith(action_trigger, kActionTriggerSoft,
-                              base::CompareCase::SENSITIVE)) {
-    // Doesn't affect values.
-  } else {
-    LOG(ERROR) << "Bad action trigger " << value_name;
-  }
-}
-
-}  // namespace
-
-namespace policy {
-namespace preg_parser {
-
-const char kPRegFileHeader[8] = {'P',    'R',    'e',    'g',
-                                 '\x01', '\x00', '\x00', '\x00'};
-
-bool ReadFile(const base::FilePath& file_path,
-              const base::string16& root,
-              RegistryDict* dict,
-              PolicyLoadStatusSampler* status) {
-  base::MemoryMappedFile mapped_file;
-  if (!mapped_file.Initialize(file_path) || !mapped_file.IsValid()) {
-    PLOG(ERROR) << "Failed to map " << file_path.value();
-    status->Add(POLICY_LOAD_STATUS_READ_ERROR);
-    return false;
-  }
-
-  if (mapped_file.length() > kMaxPRegFileSize) {
-    LOG(ERROR) << "PReg file " << file_path.value()
-               << " too large: " << mapped_file.length();
-    status->Add(POLICY_LOAD_STATUS_TOO_BIG);
-    return false;
-  }
-
-  // Check the header.
-  const int kHeaderSize = arraysize(kPRegFileHeader);
-  if (mapped_file.length() < kHeaderSize ||
-      memcmp(kPRegFileHeader, mapped_file.data(), kHeaderSize) != 0) {
-    LOG(ERROR) << "Bad policy file " << file_path.value();
-    status->Add(POLICY_LOAD_STATUS_PARSE_ERROR);
-    return false;
-  }
-
-  // Parse file contents, which is UCS-2 and little-endian. The latter I
-  // couldn't find documentation on, but the example I saw were all
-  // little-endian. It'd be interesting to check on big-endian hardware.
-  const uint8_t* cursor = mapped_file.data() + kHeaderSize;
-  const uint8_t* end = mapped_file.data() + mapped_file.length();
-  while (true) {
-    if (cursor == end)
-      return true;
-
-    if (NextChar(&cursor, end) != kDelimBracketOpen)
-      break;
-
-    // Read the record fields.
-    base::string16 key_name;
-    base::string16 value;
-    uint32_t type = 0;
-    uint32_t size = 0;
-    std::vector<uint8_t> data;
-
-    if (!ReadFieldString(&cursor, end, &key_name))
-      break;
-
-    int current = NextChar(&cursor, end);
-    if (current == kDelimSemicolon) {
-      if (!ReadFieldString(&cursor, end, &value))
-        break;
-      current = NextChar(&cursor, end);
-    }
-
-    if (current == kDelimSemicolon) {
-      if (!ReadField32(&cursor, end, &type))
-        break;
-      current = NextChar(&cursor, end);
-    }
-
-    if (current == kDelimSemicolon) {
-      if (!ReadField32(&cursor, end, &size))
-        break;
-      current = NextChar(&cursor, end);
-    }
-
-    if (current == kDelimSemicolon) {
-      if (size > kMaxPRegFileSize)
-        break;
-      data.resize(size);
-      if (!ReadFieldBinary(&cursor, end, size, data.data()))
-        break;
-      current = NextChar(&cursor, end);
-    }
-
-    if (current != kDelimBracketClose)
-      break;
-
-    // Process the record if it is within the |root| subtree.
-    if (base::StartsWith(key_name, root, base::CompareCase::INSENSITIVE_ASCII))
-      HandleRecord(key_name.substr(root.size()), value, type, data, dict);
-  }
-
-  LOG(ERROR) << "Error parsing " << file_path.value() << " at offset "
-             << reinterpret_cast<const uint8_t*>(cursor - 1) -
-                    mapped_file.data();
-  status->Add(POLICY_LOAD_STATUS_PARSE_ERROR);
-  return false;
-}
-
-}  // namespace preg_parser
-}  // namespace policy

diff --git a/components/policy/core/common/preg_parser.h b/components/policy/core/common/preg_parser.h
deleted file mode 100644
index 1aa1815..0000000
--- a/components/policy/core/common/preg_parser.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-// This file provides a parser for PReg files which are used for storing group
-// policy settings in the file system. The file format is documented here:
-//
-// http://msdn.microsoft.com/en-us/library/windows/desktop/aa374407(v=vs.85).aspx
-
-#ifndef COMPONENTS_POLICY_CORE_COMMON_PREG_PARSER_H_
-#define COMPONENTS_POLICY_CORE_COMMON_PREG_PARSER_H_
-
-#include <memory>
-#include <vector>
-
-#include "base/strings/string16.h"
-#include "components/policy/policy_export.h"
-
-namespace base {
-class FilePath;
-}
-
-namespace policy {
-
-class PolicyLoadStatusSampler;
-class RegistryDict;
-
-namespace preg_parser {
-
-// The magic header in PReg files: ASCII "PReg" + version (0x0001).
-POLICY_EXPORT extern const char kPRegFileHeader[8];
-
-// Reads the PReg file at |file_path| and writes the registry data to |dict|.
-// |root| specifies the registry subtree the caller is interested in,
-// everything else gets ignored.
-POLICY_EXPORT bool ReadFile(const base::FilePath& file_path,
-                            const base::string16& root,
-                            RegistryDict* dict,
-                            PolicyLoadStatusSampler* status);
-
-}  // namespace preg_parser
-}  // namespace policy
-
-#endif  // COMPONENTS_POLICY_CORE_COMMON_PREG_PARSER_H_

diff --git a/components/policy/core/common/preg_parser_unittest.cc b/components/policy/core/common/preg_parser_unittest.cc
deleted file mode 100644
index b8c93f3..0000000
--- a/components/policy/core/common/preg_parser_unittest.cc
+++ /dev/null
@@ -1,138 +0,0 @@
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "components/policy/core/common/preg_parser.h"
-
-#include <utility>
-
-#include "base/base_paths.h"
-#include "base/files/file_path.h"
-#include "base/json/json_writer.h"
-#include "base/logging.h"
-#include "base/memory/ptr_util.h"
-#include "base/path_service.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/values.h"
-#include "components/policy/core/common/policy_load_status.h"
-#include "components/policy/core/common/registry_dict.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace policy {
-namespace preg_parser {
-namespace {
-
-// Check whether two RegistryDicts equal each other.
-testing::AssertionResult RegistryDictEquals(const RegistryDict& a,
-                                            const RegistryDict& b) {
-  auto iter_key_a = a.keys().begin();
-  auto iter_key_b = b.keys().begin();
-  for (; iter_key_a != a.keys().end() && iter_key_b != b.keys().end();
-       ++iter_key_a, ++iter_key_b) {
-    if (iter_key_a->first != iter_key_b->first) {
-      return testing::AssertionFailure() << "Key mismatch " << iter_key_a->first
-                                         << " vs. " << iter_key_b->first;
-    }
-    testing::AssertionResult result =
-        RegistryDictEquals(*iter_key_a->second, *iter_key_b->second);
-    if (!result)
-      return result;
-  }
-
-  auto iter_value_a = a.values().begin();
-  auto iter_value_b = b.values().begin();
-  for (; iter_value_a != a.values().end() && iter_value_b != b.values().end();
-       ++iter_value_a, ++iter_value_b) {
-    if (iter_value_a->first != iter_value_b->first ||
-        !base::Value::Equals(iter_value_a->second.get(),
-                             iter_value_b->second.get())) {
-      return testing::AssertionFailure()
-             << "Value mismatch " << iter_value_a->first << "="
-             << *iter_value_a->second.get() << " vs. " << iter_value_b->first
-             << "=" << *iter_value_b->second.get();
-    }
-  }
-
-  return testing::AssertionSuccess();
-}
-
-void SetInteger(RegistryDict* dict, const std::string& name, int value) {
-  dict->SetValue(
-      name, base::WrapUnique<base::Value>(new base::FundamentalValue(value)));
-}
-
-void SetString(RegistryDict* dict,
-               const std::string& name,
-               const std::string& value) {
-  dict->SetValue(name,
-                 base::WrapUnique<base::Value>(new base::StringValue(value)));
-}
-
-TEST(PRegParserTest, TestParseFile) {
-  base::FilePath test_data_dir;
-  ASSERT_TRUE(PathService::Get(base::DIR_SOURCE_ROOT, &test_data_dir));
-
-  // Prepare the test dictionary with some data so the test can check that the
-  // PReg action triggers work, i.e. remove these items.
-  RegistryDict dict;
-  SetInteger(&dict, "DeleteValuesTest1", 1);
-  SetString(&dict, "DeleteValuesTest2", "2");
-  dict.SetKey("DeleteKeysTest1", base::MakeUnique<RegistryDict>());
-  std::unique_ptr<RegistryDict> delete_keys_test(new RegistryDict());
-  SetInteger(delete_keys_test.get(), "DeleteKeysTest2Entry", 1);
-  dict.SetKey("DeleteKeysTest2", std::move(delete_keys_test));
-  SetInteger(&dict, "DelTest", 1);
-  std::unique_ptr<RegistryDict> subdict(new RegistryDict());
-  SetInteger(subdict.get(), "DelValsTest1", 1);
-  SetString(subdict.get(), "DelValsTest2", "2");
-  subdict->SetKey("DelValsTest3", base::MakeUnique<RegistryDict>());
-  dict.SetKey("DelValsTest", std::move(subdict));
-
-  // Run the parser.
-  base::FilePath test_file(
-      test_data_dir.AppendASCII("chrome/test/data/policy/registry.pol"));
-  PolicyLoadStatusUmaReporter status;
-  ASSERT_TRUE(preg_parser::ReadFile(
-      test_file, base::ASCIIToUTF16("SOFTWARE\\Policies\\Chromium"), &dict,
-      &status));
-
-  // Build the expected output dictionary.
-  RegistryDict expected;
-  std::unique_ptr<RegistryDict> del_vals_dict(new RegistryDict());
-  del_vals_dict->SetKey("DelValsTest3", base::MakeUnique<RegistryDict>());
-  expected.SetKey("DelValsTest", std::move(del_vals_dict));
-  SetInteger(&expected, "HomepageIsNewTabPage", 1);
-  SetString(&expected, "HomepageLocation", "http://www.example.com");
-  SetInteger(&expected, "RestoreOnStartup", 4);
-  std::unique_ptr<RegistryDict> startup_urls(new RegistryDict());
-  SetString(startup_urls.get(), "1", "http://www.chromium.org");
-  SetString(startup_urls.get(), "2", "http://www.example.com");
-  expected.SetKey("RestoreOnStartupURLs", std::move(startup_urls));
-  SetInteger(&expected, "ShowHomeButton", 1);
-  SetString(&expected, "Snowman", "\xE2\x98\x83");
-  SetString(&expected, "Empty", "");
-
-  EXPECT_TRUE(RegistryDictEquals(dict, expected));
-}
-
-TEST_F(PRegParserTest, LoadStatusSampling) {
-  base::FilePath test_data_dir;
-  ASSERT_TRUE(PathService::Get(base::DIR_SOURCE_ROOT, &test_data_dir));
-
-  base::FilePath test_file(test_data_dir.AppendASCII("does_not_exist.pol"));
-  PolicyLoadStatusUmaReporter status;
-  RegistryDict dict;
-  ASSERT_FALSE(preg_parser::ReadFile(
-      test_file, base::ASCIIToUTF16("SOFTWARE\\Policies\\Chromium"), &dict,
-      &status));
-
-  // Tests load status sampling.
-  PolicyLoadStatusSampler::StatusSet expected_status_set;
-  expected_status_set[POLICY_LOAD_STATUS_STARTED] = true;
-  expected_status_set[POLICY_LOAD_STATUS_READ_ERROR] = true;
-  EXPECT_EQ(expected_status_set, status.GetStatusSet());
-}
-
-}  // namespace
-}  // namespace preg_parser
-}  // namespace policy
