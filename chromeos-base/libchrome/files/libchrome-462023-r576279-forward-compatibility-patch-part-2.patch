From 7961103872db4f879e3b7b196d3b565100a83ee4 Mon Sep 17 00:00:00 2001
From: Qijiang Fan <fqj@chromium.org>
Date: Tue, 29 Oct 2019 20:24:18 +0900
Subject: [PATCH 2/6] libchrome: r576279 forward compatibility patch part 2
 (mojo).

This CL includes;
- mojo/public/cpp/system/platform_handle.{h,cpp}:{W,Unw}rapPlatformHandle
- mojo/public/cpp/system/invitation.{h,cpp}:IncomingInvitation/OutgoingInvitation
- mojo/public/cpp/bindings/interface_request.h:InterfaceRequest
- mojo/public/cpp/platform/socket*:mojo::SocketRecvmsg/SendmsgWithHandles
- mojo/public/cpp/platform/platform_channel*:mojo::PlatformChannel{,Endpoint}
- mojo/core/embedder:Init/ScopedIPCSupport

BUG=chromium:909719
TEST=Build.

Change-Id: I7d987fea70704375a5a3296349749648a19ffa7c
---
 BUILD.gn                                      |  6 ++
 mojo/core/core.h                              | 12 ++++
 mojo/core/embedder/embedder.cc                | 16 +++++
 mojo/core/embedder/embedder.h                 | 16 +++++
 mojo/core/embedder/scoped_ipc_support.h       | 12 ++++
 .../embedder/pending_process_connection.cc    |  7 +++
 .../edk/embedder/pending_process_connection.h |  7 +++
 mojo/edk/system/core.cc                       |  5 ++
 mojo/edk/system/core.h                        |  3 +
 mojo/public/cpp/bindings/interface_request.h  |  3 +
 mojo/public/cpp/platform/platform_channel.cc  | 21 +++++++
 mojo/public/cpp/platform/platform_channel.h   | 24 +++++++
 .../cpp/platform/platform_channel_endpoint.cc | 13 ++++
 .../cpp/platform/platform_channel_endpoint.h  | 24 +++++++
 .../public/cpp/platform/socket_utils_posix.cc | 39 ++++++++++++
 mojo/public/cpp/platform/socket_utils_posix.h | 23 +++++++
 mojo/public/cpp/system/invitation.cc          | 51 +++++++++++++++
 mojo/public/cpp/system/invitation.h           | 56 +++++++++++++++++
 mojo/public/cpp/system/isolated_connection.cc | 22 +++++++
 mojo/public/cpp/system/isolated_connection.h  | 23 +++++++
 mojo/public/cpp/system/platform_handle.cc     | 57 +++++++++++++++++
 mojo/public/cpp/system/platform_handle.h      | 63 +++++++++++++++++++
 22 files changed, 503 insertions(+)
 create mode 100644 mojo/core/core.h
 create mode 100644 mojo/core/embedder/embedder.cc
 create mode 100644 mojo/core/embedder/embedder.h
 create mode 100644 mojo/core/embedder/scoped_ipc_support.h
 create mode 100644 mojo/public/cpp/platform/platform_channel.cc
 create mode 100644 mojo/public/cpp/platform/platform_channel.h
 create mode 100644 mojo/public/cpp/platform/platform_channel_endpoint.cc
 create mode 100644 mojo/public/cpp/platform/platform_channel_endpoint.h
 create mode 100644 mojo/public/cpp/platform/socket_utils_posix.cc
 create mode 100644 mojo/public/cpp/platform/socket_utils_posix.h
 create mode 100644 mojo/public/cpp/system/invitation.cc
 create mode 100644 mojo/public/cpp/system/invitation.h
 create mode 100644 mojo/public/cpp/system/isolated_connection.cc
 create mode 100644 mojo/public/cpp/system/isolated_connection.h

diff --git a/BUILD.gn b/BUILD.gn
index 4477a86..55cbf7f 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -607,6 +607,7 @@ if (use.mojo) {
       "mojo/common/data_pipe_drainer.cc",
       "mojo/common/data_pipe_utils.cc",
       "mojo/common/values_struct_traits.cc",
+      "mojo/core/embedder/embedder.cc",
       "mojo/edk/embedder/connection_params.cc",
       "mojo/edk/embedder/embedder.cc",
       "mojo/edk/embedder/entrypoints.cc",
@@ -685,11 +686,16 @@ if (use.mojo) {
       "mojo/public/cpp/bindings/lib/validation_errors.cc",
       "mojo/public/cpp/bindings/lib/validation_util.cc",
       "mojo/public/cpp/system/buffer.cc",
+      "mojo/public/cpp/system/invitation.cc",
+      "mojo/public/cpp/system/isolated_connection.cc",
       "mojo/public/cpp/system/platform_handle.cc",
       "mojo/public/cpp/system/simple_watcher.cc",
       "mojo/public/cpp/system/wait.cc",
       "mojo/public/cpp/system/wait_set.cc",
       "mojo/public/cpp/system/watcher.cc",
+      "mojo/public/cpp/platform/socket_utils_posix.cc",
+      "mojo/public/cpp/platform/platform_channel.cc",
+      "mojo/public/cpp/platform/platform_channel_endpoint.cc",
     ] + get_target_outputs(":mojom_bindings_gen")
   }
 
diff --git a/mojo/core/core.h b/mojo/core/core.h
new file mode 100644
index 0000000..dbdea04
--- /dev/null
+++ b/mojo/core/core.h
@@ -0,0 +1,12 @@
+#ifndef MOJO_CORE_CORE_H_
+#define MOJO_CORE_CORE_H_
+
+#include "mojo/edk/system/core.h"
+
+namespace mojo {
+namespace core {
+using Core = mojo::edk::Core;
+}
+}
+
+#endif // MOJO_CORE_CORE_H_
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
new file mode 100644
index 0000000..dcf1bba
--- /dev/null
+++ b/mojo/core/embedder/embedder.cc
@@ -0,0 +1,16 @@
+#include "mojo/core/embedder/embedder.h"
+#include "mojo/edk/embedder/embedder.h"
+
+namespace mojo {
+namespace core {
+
+void Init() {
+  mojo::edk::Init();
+}
+
+scoped_refptr<base::TaskRunner> GetIOTaskRunner() {
+  return mojo::edk::GetIOTaskRunner();
+}
+
+} // namespace core
+} // namespace mojo
diff --git a/mojo/core/embedder/embedder.h b/mojo/core/embedder/embedder.h
new file mode 100644
index 0000000..e8d6ed7
--- /dev/null
+++ b/mojo/core/embedder/embedder.h
@@ -0,0 +1,16 @@
+#ifndef MOJO_CORE_EMBEDDER_EMBEDDER_H_
+#define MOJO_CORE_EMBEDDER_EMBEDDER_H_
+
+#include "base/task_runner.h"
+
+namespace mojo {
+namespace core {
+
+void Init();
+
+scoped_refptr<base::TaskRunner> GetIOTaskRunner();
+
+} // namespace core
+} // namespace mojo
+
+#endif // MOJO_CORE_EMBEDDER_EMBEDDER_H_
diff --git a/mojo/core/embedder/scoped_ipc_support.h b/mojo/core/embedder/scoped_ipc_support.h
new file mode 100644
index 0000000..db4ab6a
--- /dev/null
+++ b/mojo/core/embedder/scoped_ipc_support.h
@@ -0,0 +1,12 @@
+#ifndef MOJO_CORE_EMBEDDER_SCOPED_IPC_SUPPORT_H_
+#define MOJO_CORE_EMBEDDER_SCOPED_IPC_SUPPORT_H_
+
+#include <mojo/edk/embedder/scoped_ipc_support.h>
+
+namespace mojo {
+namespace core {
+using ScopedIPCSupport = mojo::edk::ScopedIPCSupport;
+} // namespace core
+} // namespace mojo
+
+#endif // MOJO_CORE_EMBEDDER_SCOPED_IPC_SUPPORT_H_
diff --git a/mojo/edk/embedder/pending_process_connection.cc b/mojo/edk/embedder/pending_process_connection.cc
index d6be76e..13a9bba 100644
--- a/mojo/edk/embedder/pending_process_connection.cc
+++ b/mojo/edk/embedder/pending_process_connection.cc
@@ -31,6 +31,13 @@ ScopedMessagePipeHandle PendingProcessConnection::CreateMessagePipe(
   return internal::g_core->CreateParentMessagePipe(*token, process_token_);
 }
 
+ScopedMessagePipeHandle PendingProcessConnection::CreateMessagePipe(
+    std::string token) {
+  has_message_pipes_ = true;
+  DCHECK(internal::g_core);
+  return internal::g_core->CreateParentMessagePipe(token, process_token_);
+}
+
 void PendingProcessConnection::Connect(
     base::ProcessHandle process,
     ConnectionParams connection_params,
diff --git a/mojo/edk/embedder/pending_process_connection.h b/mojo/edk/embedder/pending_process_connection.h
index ca18227..1da3729 100644
--- a/mojo/edk/embedder/pending_process_connection.h
+++ b/mojo/edk/embedder/pending_process_connection.h
@@ -15,6 +15,10 @@
 #include "mojo/edk/system/system_impl_export.h"
 #include "mojo/public/cpp/system/message_pipe.h"
 
+namespace mojo {
+class OutgoingInvitation;
+}
+
 namespace mojo {
 namespace edk {
 
@@ -115,6 +119,9 @@ class MOJO_SYSTEM_IMPL_EXPORT PendingProcessConnection {
   // Indicates whether Connect() has been called yet.
   bool connected_ = false;
 
+  ScopedMessagePipeHandle CreateMessagePipe(std::string token);
+  friend class mojo::OutgoingInvitation;
+
   DISALLOW_COPY_AND_ASSIGN(PendingProcessConnection);
 };
 
diff --git a/mojo/edk/system/core.cc b/mojo/edk/system/core.cc
index 360e8c3..a5797ef 100644
--- a/mojo/edk/system/core.cc
+++ b/mojo/edk/system/core.cc
@@ -140,6 +140,11 @@ Core::~Core() {
   }
 }
 
+Core* Core::Get() {
+  DCHECK(internal::g_core);
+  return internal::g_core;
+}
+
 void Core::SetIOTaskRunner(scoped_refptr<base::TaskRunner> io_task_runner) {
   GetNodeController()->SetIOTaskRunner(io_task_runner);
 }
diff --git a/mojo/edk/system/core.h b/mojo/edk/system/core.h
index 1f6d865..4caa2d0 100644
--- a/mojo/edk/system/core.h
+++ b/mojo/edk/system/core.h
@@ -44,6 +44,9 @@ class MOJO_SYSTEM_IMPL_EXPORT Core {
   Core();
   virtual ~Core();
 
+  // Get. forward compatiblity
+  static Core* Get();
+
   // Called exactly once, shortly after construction, and before any other
   // methods are called on this object.
   void SetIOTaskRunner(scoped_refptr<base::TaskRunner> io_task_runner);
diff --git a/mojo/public/cpp/bindings/interface_request.h b/mojo/public/cpp/bindings/interface_request.h
index 29d8836..0221b65 100644
--- a/mojo/public/cpp/bindings/interface_request.h
+++ b/mojo/public/cpp/bindings/interface_request.h
@@ -33,6 +33,9 @@ class InterfaceRequest {
   InterfaceRequest() {}
   InterfaceRequest(decltype(nullptr)) {}
 
+  explicit InterfaceRequest(ScopedMessagePipeHandle&& handle)
+      : handle_(std::move(handle)) {}
+
   // Creates a new message pipe over which Interface is to be served, binding
   // the specified InterfacePtr to one end of the message pipe and this
   // InterfaceRequest to the other. For example usage, see comments on
diff --git a/mojo/public/cpp/platform/platform_channel.cc b/mojo/public/cpp/platform/platform_channel.cc
new file mode 100644
index 0000000..01dcc8f
--- /dev/null
+++ b/mojo/public/cpp/platform/platform_channel.cc
@@ -0,0 +1,21 @@
+#include "mojo/public/cpp/platform/platform_channel.h"
+
+namespace mojo {
+
+PlatformChannel::PlatformChannel() = default;
+
+PlatformChannelEndpoint PlatformChannel::TakeRemoteEndpoint() {
+  return mojo::PlatformChannelEndpoint(
+      mojo::PlatformHandle(
+          base::ScopedFD(
+              channel_.PassClientHandle().release().handle)));
+}
+
+PlatformChannelEndpoint PlatformChannel::TakeLocalEndpoint() {
+  return mojo::PlatformChannelEndpoint(
+      mojo::PlatformHandle(
+          base::ScopedFD(
+              channel_.PassServerHandle().release().handle)));
+}
+
+}
diff --git a/mojo/public/cpp/platform/platform_channel.h b/mojo/public/cpp/platform/platform_channel.h
new file mode 100644
index 0000000..3037d6a
--- /dev/null
+++ b/mojo/public/cpp/platform/platform_channel.h
@@ -0,0 +1,24 @@
+#ifndef MOJO_PUBLIC_CPP_PLATFORM_PLATFORM_CHANNEL_H_
+#define MOJO_PUBLIC_CPP_PLATFORM_PLATFORM_CHANNEL_H_
+
+#include "mojo/public/cpp/platform/platform_channel_endpoint.h"
+#include "mojo/edk/embedder/platform_channel_pair.h"
+
+namespace mojo {
+
+// All implementations are in mojo/public/cpp/system/invitation.cc to access
+// mapping in anonmymous namespace.
+class PlatformChannel {
+ public:
+  PlatformChannel();
+  PlatformChannelEndpoint TakeLocalEndpoint();
+  PlatformChannelEndpoint TakeRemoteEndpoint();
+
+ private:
+  mojo::edk::PlatformChannelPair channel_;
+};
+
+} // mojo
+
+#endif // MOJO_PUBLIC_CPP_PLATFORM_PLATFORM_CHANNEL_H_
+
diff --git a/mojo/public/cpp/platform/platform_channel_endpoint.cc b/mojo/public/cpp/platform/platform_channel_endpoint.cc
new file mode 100644
index 0000000..483d214
--- /dev/null
+++ b/mojo/public/cpp/platform/platform_channel_endpoint.cc
@@ -0,0 +1,13 @@
+#include "mojo/public/cpp/platform/platform_channel_endpoint.h"
+
+namespace mojo {
+
+PlatformChannelEndpoint::PlatformChannelEndpoint(PlatformHandle handle)
+    : handle_(std::move(handle)) {}
+
+PlatformChannelEndpoint::PlatformChannelEndpoint() = default;
+
+PlatformChannelEndpoint::PlatformChannelEndpoint(
+    PlatformChannelEndpoint&& other) = default;
+
+}
diff --git a/mojo/public/cpp/platform/platform_channel_endpoint.h b/mojo/public/cpp/platform/platform_channel_endpoint.h
new file mode 100644
index 0000000..bf8ba66
--- /dev/null
+++ b/mojo/public/cpp/platform/platform_channel_endpoint.h
@@ -0,0 +1,24 @@
+#ifndef MOJO_PUBLIC_CPP_PLATFORM_PLATFORM_CHANNEL_ENDPOINT_H_
+#define MOJO_PUBLIC_CPP_PLATFORM_PLATFORM_CHANNEL_ENDPOINT_H_
+
+#include "mojo/public/cpp/system/platform_handle.h"
+
+namespace mojo {
+
+class PlatformChannelEndpoint {
+ public:
+  PlatformChannelEndpoint();
+  explicit PlatformChannelEndpoint(PlatformHandle handle);
+  PlatformChannelEndpoint(PlatformChannelEndpoint&& other);
+  PlatformHandle TakePlatformHandle() WARN_UNUSED_RESULT {
+    return std::move(handle_);
+  }
+ private:
+  PlatformHandle handle_;
+
+  DISALLOW_COPY_AND_ASSIGN(PlatformChannelEndpoint);
+};
+
+}
+
+#endif // MOJO_PUBLIC_CPP_PLATFORM_PLATFORM_CHANNEL_ENDPOINT_H_
diff --git a/mojo/public/cpp/platform/socket_utils_posix.cc b/mojo/public/cpp/platform/socket_utils_posix.cc
new file mode 100644
index 0000000..e89b205
--- /dev/null
+++ b/mojo/public/cpp/platform/socket_utils_posix.cc
@@ -0,0 +1,39 @@
+#include "mojo/public/cpp/platform/socket_utils_posix.h"
+#include "mojo/edk/embedder/platform_channel_utils_posix.h"
+#include "mojo/edk/embedder/platform_handle_vector.h"
+
+ssize_t mojo::SendmsgWithHandles(base::PlatformFile socket,
+                                 struct iovec* iov,
+                                 size_t num_iov,
+                                 const std::vector<base::ScopedFD>& descriptors) {
+  mojo::edk::ScopedPlatformHandleVectorPtr handles(new mojo::edk::PlatformHandleVector());
+  for (const base::ScopedFD& fd: descriptors) {
+    handles->push_back(mojo::edk::PlatformHandle(fd.get()));
+  }
+  ssize_t ret = mojo::edk::PlatformChannelSendmsgWithHandles(
+      mojo::edk::PlatformHandle(socket),
+      iov, num_iov,
+      handles->data(), handles->size());
+  // We don't want to the fd being closed by mojo::edk::PlatformHandle.
+  // The conversion from base::ScopedFD to mojo::edk::PlatformHandle is only for
+  // forward-compatibility type conversion, not for transferring ownership.
+  // Clean up handles so fds not get closed here.
+  for (auto &handle: *handles) {
+    handle.handle = -1;
+  }
+  return ret;
+}
+
+ssize_t mojo::SocketRecvmsg(base::PlatformFile socket, void* buf,
+                            size_t num_bytes,
+                            std::vector<base::ScopedFD>* descriptors,
+                            bool block) {
+  std::deque<mojo::edk::PlatformHandle> platform_handles;
+  ssize_t retval =
+      mojo::edk::PlatformChannelRecvmsg(mojo::edk::PlatformHandle(socket), buf,
+                                        num_bytes, &platform_handles, block);
+  for (auto& handle : platform_handles) {
+    descriptors->push_back(std::move(base::ScopedFD(handle.handle)));
+  }
+  return retval;
+}
diff --git a/mojo/public/cpp/platform/socket_utils_posix.h b/mojo/public/cpp/platform/socket_utils_posix.h
new file mode 100644
index 0000000..2253c2a
--- /dev/null
+++ b/mojo/public/cpp/platform/socket_utils_posix.h
@@ -0,0 +1,23 @@
+#include <mojo/edk/embedder/platform_channel_utils_posix.h>
+
+#ifndef MOJO_PUBLIC_CPP_PLATFORM_SOCKET_UTILS_POSIX_H_
+#define MOJO_PUBLIC_CPP_PLATFORM_SOCKET_UTILS_POSIX_H_
+
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/files/scoped_file.h"
+
+namespace mojo {
+
+ssize_t SendmsgWithHandles(base::PlatformFile socket,
+                           struct iovec* iov,
+                           size_t num_iov,
+                           const std::vector<base::ScopedFD>& descriptors);
+
+ssize_t SocketRecvmsg(base::PlatformFile socket, void* buf, size_t num_bytes,
+                      std::vector<base::ScopedFD>* descriptors,
+                      bool block = false);
+}
+
+#endif
diff --git a/mojo/public/cpp/system/invitation.cc b/mojo/public/cpp/system/invitation.cc
new file mode 100644
index 0000000..1624524
--- /dev/null
+++ b/mojo/public/cpp/system/invitation.cc
@@ -0,0 +1,51 @@
+#include <map>
+#include <string>
+
+#include "mojo/public/cpp/system/invitation.h"
+#include "mojo/edk/embedder/pending_process_connection.h"
+#include "mojo/edk/embedder/platform_channel_pair.h"
+
+namespace mojo {
+
+IncomingInvitation::IncomingInvitation() = default;
+
+IncomingInvitation::IncomingInvitation(IncomingInvitation&& other) = default;
+
+IncomingInvitation& IncomingInvitation::operator=(IncomingInvitation&& other) = default;
+
+IncomingInvitation IncomingInvitation::Accept(
+    PlatformChannelEndpoint channel_endpoint) {
+  mojo::edk::SetParentPipeHandle(
+      mojo::edk::ScopedPlatformHandle(mojo::edk::PlatformHandle(
+          channel_endpoint.TakePlatformHandle().TakeFD().release())));
+  return IncomingInvitation();
+}
+
+ScopedMessagePipeHandle IncomingInvitation::ExtractMessagePipe(
+    base::StringPiece token) {
+  return mojo::edk::CreateChildMessagePipe(token.as_string());
+}
+
+OutgoingInvitation::OutgoingInvitation(): process_(std::make_unique<edk::PendingProcessConnection>()) {}
+
+OutgoingInvitation::OutgoingInvitation(OutgoingInvitation&& other) = default;
+
+OutgoingInvitation& OutgoingInvitation::operator=(OutgoingInvitation&& other) = default;
+
+ScopedMessagePipeHandle OutgoingInvitation::AttachMessagePipe(base::StringPiece name) {
+  return process_->CreateMessagePipe(name.as_string());
+}
+
+void OutgoingInvitation::Send(OutgoingInvitation invitation,
+                              base::ProcessHandle target_process,
+                              PlatformChannelEndpoint server_endpoint,
+                              const ProcessErrorCallback& error_callback) {
+  invitation.process_->Connect(target_process,
+                   mojo::edk::ConnectionParams(
+                       mojo::edk::ScopedPlatformHandle(
+                           mojo::edk::PlatformHandle(
+                               server_endpoint.TakePlatformHandle().TakeFD().release()))),
+                   error_callback);
+}
+
+}  // namespace mojo
diff --git a/mojo/public/cpp/system/invitation.h b/mojo/public/cpp/system/invitation.h
new file mode 100644
index 0000000..ac2b3f2
--- /dev/null
+++ b/mojo/public/cpp/system/invitation.h
@@ -0,0 +1,56 @@
+#ifndef MOJO_PUBLIC_CPP_SYSTEM_INVITATION_H_
+#define MOJO_PUBLIC_CPP_SYSTEM_INVITATION_H_
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/process/process_handle.h"
+#include "base/strings/string_piece.h"
+#include "mojo/edk/embedder/embedder.h"
+#include "mojo/edk/embedder/pending_process_connection.h"
+#include "mojo/public/cpp/platform/platform_channel.h"
+#include "mojo/public/cpp/platform/platform_channel_endpoint.h"
+#include "mojo/public/cpp/system/platform_handle.h"
+
+namespace mojo {
+
+using ProcessErrorCallback = base::RepeatingCallback<void(const std::string&)>;
+
+class IncomingInvitation {
+ public:
+  IncomingInvitation();
+  IncomingInvitation(IncomingInvitation&& other);
+
+  IncomingInvitation& operator=(IncomingInvitation&& other);
+
+  static IncomingInvitation Accept(
+      PlatformChannelEndpoint channel_endpoint);
+  ScopedMessagePipeHandle ExtractMessagePipe(base::StringPiece token);
+};
+
+class OutgoingInvitation {
+ public:
+  OutgoingInvitation();
+  OutgoingInvitation(OutgoingInvitation&& other);
+
+  OutgoingInvitation& operator=(OutgoingInvitation&& other);
+
+  ScopedMessagePipeHandle AttachMessagePipe(base::StringPiece name);
+
+  static void Send(OutgoingInvitation invitation,
+                   base::ProcessHandle target_process,
+                   // Intentially to be different from upstream to include the
+                   // pointer to PlatformChannel.
+                   PlatformChannelEndpoint server_endpoint,
+                   const ProcessErrorCallback& error_callback = {});
+
+ private:
+  std::unique_ptr<edk::PendingProcessConnection> process_;
+};
+
+} // mojo
+
+#endif // MOJO_PUBLIC_CPP_SYSTEM_INVITATION_H_
diff --git a/mojo/public/cpp/system/isolated_connection.cc b/mojo/public/cpp/system/isolated_connection.cc
new file mode 100644
index 0000000..05952eb
--- /dev/null
+++ b/mojo/public/cpp/system/isolated_connection.cc
@@ -0,0 +1,22 @@
+#include "mojo/public/cpp/system/isolated_connection.h"
+
+#include "mojo/edk/embedder/embedder.h"
+
+namespace mojo {
+
+IsolatedConnection::IsolatedConnection()
+    : token_(base::UnguessableToken::Create()) {}
+
+IsolatedConnection::~IsolatedConnection() {
+  mojo::edk::ClosePeerConnection(token_.ToString());
+}
+
+ScopedMessagePipeHandle IsolatedConnection::Connect(
+    PlatformChannelEndpoint endpoint) {
+  return mojo::edk::ConnectToPeerProcess(
+      mojo::edk::ScopedPlatformHandle(mojo::edk::PlatformHandle(
+          endpoint.TakePlatformHandle().TakeFD().release())),
+      token_.ToString());
+}
+
+}  // namespace mojo
diff --git a/mojo/public/cpp/system/isolated_connection.h b/mojo/public/cpp/system/isolated_connection.h
new file mode 100644
index 0000000..57c6e43
--- /dev/null
+++ b/mojo/public/cpp/system/isolated_connection.h
@@ -0,0 +1,23 @@
+#ifndef MOJO_PUBLIC_CPP_SYSTEM_ISOLATED_CONNECTION_H_
+#define MOJO_PUBLIC_CPP_SYSTEM_ISOLATED_CONNECTION_H_
+
+#include "base/unguessable_token.h"
+#include "mojo/public/cpp/platform/platform_channel_endpoint.h"
+#include "mojo/public/cpp/system/message_pipe.h"
+
+namespace mojo {
+
+class IsolatedConnection {
+ public:
+  IsolatedConnection();
+  ~IsolatedConnection();
+
+  ScopedMessagePipeHandle Connect(PlatformChannelEndpoint endpoint);
+
+ private:
+  const base::UnguessableToken token_;
+};
+
+}
+
+#endif // MOJO_PUBLIC_CPP_SYSTEM_ISOLATED_CONNECTION_H_
diff --git a/mojo/public/cpp/system/platform_handle.cc b/mojo/public/cpp/system/platform_handle.cc
index 42e4aba..6116860 100644
--- a/mojo/public/cpp/system/platform_handle.cc
+++ b/mojo/public/cpp/system/platform_handle.cc
@@ -31,6 +31,29 @@ base::PlatformFile PlatformFileFromPlatformHandleValue(uint64_t value) {
 
 }  // namespace
 
+
+ScopedHandle WrapPlatformHandle(PlatformHandle handle) {
+  MojoPlatformHandle platform_handle;
+  PlatformHandle::ToMojoPlatformHandle(std::move(handle), &platform_handle);
+
+  MojoHandle wrapped_handle;
+  MojoResult result =
+      MojoWrapPlatformHandle(&platform_handle, &wrapped_handle);
+  if (result != MOJO_RESULT_OK)
+    return ScopedHandle();
+  return ScopedHandle(Handle(wrapped_handle));
+}
+
+PlatformHandle UnwrapPlatformHandle(ScopedHandle handle) {
+  MojoPlatformHandle platform_handle;
+  platform_handle.struct_size = sizeof(platform_handle);
+  MojoResult result = MojoUnwrapPlatformHandle(handle.release().value(),
+                                               &platform_handle);
+  if (result != MOJO_RESULT_OK)
+    return PlatformHandle();
+  return PlatformHandle::FromMojoPlatformHandle(&platform_handle);
+}
+
 ScopedHandle WrapPlatformFile(base::PlatformFile platform_file) {
   MojoPlatformHandle platform_handle;
   platform_handle.struct_size = sizeof(MojoPlatformHandle);
@@ -175,4 +198,38 @@ MojoResult UnwrapMachPort(ScopedHandle handle, mach_port_t* port) {
 }
 #endif  // defined(OS_MACOSX) && !defined(OS_IOS)
 
+// static
+PlatformHandle PlatformHandle::FromMojoPlatformHandle(
+    const MojoPlatformHandle* handle) {
+  if (handle->struct_size < sizeof(*handle) ||
+      handle->type == MOJO_PLATFORM_HANDLE_TYPE_INVALID) {
+    return PlatformHandle();
+  }
+
+  if (handle->type != MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR)
+    return PlatformHandle();
+  return PlatformHandle(base::ScopedFD(static_cast<int>(handle->value)));
+}
+
+// static
+void PlatformHandle::ToMojoPlatformHandle(PlatformHandle handle,
+                                          MojoPlatformHandle* out_handle) {
+  DCHECK(out_handle);
+  out_handle->struct_size = sizeof(MojoPlatformHandle);
+  if (handle.type_ == Type::kNone) {
+    out_handle->type = MOJO_PLATFORM_HANDLE_TYPE_INVALID;
+    out_handle->value = 0;
+    return;
+  }
+
+  do {
+    DCHECK(handle.is_fd());
+    out_handle->type = MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR;
+    out_handle->value = static_cast<uint64_t>(handle.TakeFD().release());
+  } while (false);
+
+  // One of the above cases must take ownership of |handle|.
+  DCHECK(!handle.is_valid());
+}
+
 }  // namespace mojo
diff --git a/mojo/public/cpp/system/platform_handle.h b/mojo/public/cpp/system/platform_handle.h
index 801264e..e034ef8 100644
--- a/mojo/public/cpp/system/platform_handle.h
+++ b/mojo/public/cpp/system/platform_handle.h
@@ -30,6 +30,61 @@
 
 namespace mojo {
 
+class PlatformHandle {
+public:
+  enum class Type {
+    kNone,
+    kFd,
+  };
+
+  PlatformHandle() = default;
+  PlatformHandle(PlatformHandle&& other) {
+    *this = std::move(other);
+  }
+  explicit PlatformHandle(base::ScopedFD fd)
+    : type_(Type::kFd), fd_(std::move(fd)) {
+  }
+
+  ~PlatformHandle() = default;
+
+  PlatformHandle& operator=(PlatformHandle&& other) {
+    type_ = other.type_;
+    other.type_ = Type::kNone;
+
+    fd_ = std::move(other.fd_);
+
+    return *this;
+  }
+
+  // Takes ownership of |handle|'s underlying platform handle and fills in
+  // |mojo_handle| with a representation of it. The caller assumes ownership of
+  // the platform handle.
+  static void ToMojoPlatformHandle(PlatformHandle handle,
+                                   MojoPlatformHandle* mojo_handle);
+
+  // Closes the underlying platform handle.
+  // Assumes ownership of the platform handle described by |handle|, and returns
+  // it as a new PlatformHandle.
+  static PlatformHandle FromMojoPlatformHandle(
+      const MojoPlatformHandle* handle);
+
+  bool is_valid() const { return is_valid_fd(); }
+  bool is_valid_fd() const { return fd_.is_valid(); }
+  bool is_fd() const { return type_ == Type::kFd; }
+  const base::ScopedFD& GetFD() const { return fd_; }
+  base::ScopedFD TakeFD() {
+    return std::move(fd_);
+  }
+
+  int ReleaseFD() WARN_UNUSED_RESULT {
+    return fd_.release();
+  }
+
+private:
+  Type type_;
+  base::ScopedFD fd_;
+};
+
 #if defined(OS_POSIX)
 const MojoPlatformHandleType kPlatformFileHandleType =
     MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR;
@@ -58,6 +113,14 @@ ScopedHandle WrapPlatformFile(base::PlatformFile platform_file);
 MOJO_CPP_SYSTEM_EXPORT
 MojoResult UnwrapPlatformFile(ScopedHandle handle, base::PlatformFile* file);
 
+// Wraps a PlatformHandle from the C++ platform support library as a Mojo
+// handle.
+MOJO_CPP_SYSTEM_EXPORT ScopedHandle WrapPlatformHandle(PlatformHandle handle);
+
+// Unwraps a Mojo handle to a PlatformHandle object from the C++ platform
+// support library.
+MOJO_CPP_SYSTEM_EXPORT PlatformHandle UnwrapPlatformHandle(ScopedHandle handle);
+
 // Wraps a base::SharedMemoryHandle as a Mojo handle. Takes ownership of the
 // SharedMemoryHandle. Note that |read_only| is only an indicator of whether
 // |memory_handle| only supports read-only mapping. It does NOT have any
-- 
2.24.1.735.g03f4e72817-goog

