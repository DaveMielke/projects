From 193db4882304c2cd6105509d247856c66a8b371f Mon Sep 17 00:00:00 2001
From: Qijiang Fan <fqj@chromium.org>
Date: Tue, 29 Oct 2019 20:24:18 +0900
Subject: [PATCH 2/5] libchrome: r576279 forward compatibility patch part 2 (mojo).

This CL includes;
- mojo/public/cpp/system/platform_handle.{h,cpp}:{W,Unw}rapPlatformHandle
- mojo/public/cpp/system/invitation.{h,cpp}:IncomingInvitation
- mojo/public/cpp/bindings/interface_request.h:InterfaceRequest
- mojo/public/cpp/platform/socket*:mojo::SocketRecvmsg
- mojo/core/embedder:Init/ScopedIPCSupport

BUG=chromium:909719
TEST=Build.

Change-Id: I7d987fea70704375a5a3296349749648a19ffa7c
---
 BUILD.gn                                      |  3 +
 mojo/core/embedder/embedder.cc                | 12 ++++
 mojo/core/embedder/embedder.h                 | 12 ++++
 mojo/core/embedder/scoped_ipc_support.h       | 12 ++++
 mojo/public/cpp/bindings/interface_request.h  |  3 +
 .../public/cpp/platform/socket_utils_posix.cc | 16 +++++
 mojo/public/cpp/platform/socket_utils_posix.h | 17 +++++
 mojo/public/cpp/system/invitation.cc          | 30 +++++++++
 mojo/public/cpp/system/invitation.h           | 40 ++++++++++++
 mojo/public/cpp/system/platform_handle.cc     | 57 +++++++++++++++++
 mojo/public/cpp/system/platform_handle.h      | 63 +++++++++++++++++++
 11 files changed, 265 insertions(+)
 create mode 100644 mojo/core/embedder/embedder.cc
 create mode 100644 mojo/core/embedder/embedder.h
 create mode 100644 mojo/core/embedder/scoped_ipc_support.h
 create mode 100644 mojo/public/cpp/platform/socket_utils_posix.cc
 create mode 100644 mojo/public/cpp/platform/socket_utils_posix.h
 create mode 100644 mojo/public/cpp/system/invitation.cc
 create mode 100644 mojo/public/cpp/system/invitation.h

diff --git a/BUILD.gn b/BUILD.gn
index 4477a86..8124f0a 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -607,6 +607,7 @@ if (use.mojo) {
       "mojo/common/data_pipe_drainer.cc",
       "mojo/common/data_pipe_utils.cc",
       "mojo/common/values_struct_traits.cc",
+      "mojo/core/embedder/embedder.cc",
       "mojo/edk/embedder/connection_params.cc",
       "mojo/edk/embedder/embedder.cc",
       "mojo/edk/embedder/entrypoints.cc",
@@ -685,11 +686,13 @@ if (use.mojo) {
       "mojo/public/cpp/bindings/lib/validation_errors.cc",
       "mojo/public/cpp/bindings/lib/validation_util.cc",
       "mojo/public/cpp/system/buffer.cc",
+      "mojo/public/cpp/system/invitation.cc",
       "mojo/public/cpp/system/platform_handle.cc",
       "mojo/public/cpp/system/simple_watcher.cc",
       "mojo/public/cpp/system/wait.cc",
       "mojo/public/cpp/system/wait_set.cc",
       "mojo/public/cpp/system/watcher.cc",
+      "mojo/public/cpp/platform/socket_utils_posix.cc",
     ] + get_target_outputs(":mojom_bindings_gen")
   }
 
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
new file mode 100644
index 0000000..de6fc3c
--- /dev/null
+++ b/mojo/core/embedder/embedder.cc
@@ -0,0 +1,12 @@
+#include "mojo/core/embedder/embedder.h"
+#include "mojo/edk/embedder/embedder.h"
+
+namespace mojo {
+namespace core {
+
+void Init() {
+  mojo::edk::Init();
+}
+
+} // namespace core
+} // namespace mojo
diff --git a/mojo/core/embedder/embedder.h b/mojo/core/embedder/embedder.h
new file mode 100644
index 0000000..769a525
--- /dev/null
+++ b/mojo/core/embedder/embedder.h
@@ -0,0 +1,12 @@
+#ifndef MOJO_CORE_EMBEDDER_EMBEDDER_H_
+#define MOJO_CORE_EMBEDDER_EMBEDDER_H_
+
+namespace mojo {
+namespace core {
+
+void Init();
+
+} // namespace core
+} // namespace mojo
+
+#endif // MOJO_CORE_EMBEDDER_EMBEDDER_H_
diff --git a/mojo/core/embedder/scoped_ipc_support.h b/mojo/core/embedder/scoped_ipc_support.h
new file mode 100644
index 0000000..db4ab6a
--- /dev/null
+++ b/mojo/core/embedder/scoped_ipc_support.h
@@ -0,0 +1,12 @@
+#ifndef MOJO_CORE_EMBEDDER_SCOPED_IPC_SUPPORT_H_
+#define MOJO_CORE_EMBEDDER_SCOPED_IPC_SUPPORT_H_
+
+#include <mojo/edk/embedder/scoped_ipc_support.h>
+
+namespace mojo {
+namespace core {
+using ScopedIPCSupport = mojo::edk::ScopedIPCSupport;
+} // namespace core
+} // namespace mojo
+
+#endif // MOJO_CORE_EMBEDDER_SCOPED_IPC_SUPPORT_H_
diff --git a/mojo/public/cpp/bindings/interface_request.h b/mojo/public/cpp/bindings/interface_request.h
index 29d8836..0221b65 100644
--- a/mojo/public/cpp/bindings/interface_request.h
+++ b/mojo/public/cpp/bindings/interface_request.h
@@ -33,6 +33,9 @@ class InterfaceRequest {
   InterfaceRequest() {}
   InterfaceRequest(decltype(nullptr)) {}
 
+  explicit InterfaceRequest(ScopedMessagePipeHandle&& handle)
+      : handle_(std::move(handle)) {}
+
   // Creates a new message pipe over which Interface is to be served, binding
   // the specified InterfacePtr to one end of the message pipe and this
   // InterfaceRequest to the other. For example usage, see comments on
diff --git a/mojo/public/cpp/platform/socket_utils_posix.cc b/mojo/public/cpp/platform/socket_utils_posix.cc
new file mode 100644
index 0000000..f7704fd
--- /dev/null
+++ b/mojo/public/cpp/platform/socket_utils_posix.cc
@@ -0,0 +1,16 @@
+#include "mojo/public/cpp/platform/socket_utils_posix.h"
+#include "mojo/edk/embedder/platform_channel_utils_posix.h"
+
+ssize_t mojo::SocketRecvmsg(base::PlatformFile socket, void* buf,
+                            size_t num_bytes,
+                            std::vector<base::ScopedFD>* descriptors,
+                            bool block) {
+  std::deque<mojo::edk::PlatformHandle> platform_handles;
+  ssize_t retval =
+      mojo::edk::PlatformChannelRecvmsg(mojo::edk::PlatformHandle(socket), buf,
+                                        num_bytes, &platform_handles, block);
+  for (auto& handle : platform_handles) {
+    descriptors->push_back(std::move(base::ScopedFD(handle.handle)));
+  }
+  return retval;
+}
diff --git a/mojo/public/cpp/platform/socket_utils_posix.h b/mojo/public/cpp/platform/socket_utils_posix.h
new file mode 100644
index 0000000..307e661
--- /dev/null
+++ b/mojo/public/cpp/platform/socket_utils_posix.h
@@ -0,0 +1,17 @@
+#include <mojo/edk/embedder/platform_channel_utils_posix.h>
+
+#ifndef MOJO_PUBLIC_CPP_PLATFORM_SOCKET_UTILS_POSIX_H_
+#define MOJO_PUBLIC_CPP_PLATFORM_SOCKET_UTILS_POSIX_H_
+
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/files/scoped_file.h"
+
+namespace mojo {
+ssize_t SocketRecvmsg(base::PlatformFile socket, void* buf, size_t num_bytes,
+                      std::vector<base::ScopedFD>* descriptors,
+                      bool block = false);
+}
+
+#endif
diff --git a/mojo/public/cpp/system/invitation.cc b/mojo/public/cpp/system/invitation.cc
new file mode 100644
index 0000000..3cfddf4
--- /dev/null
+++ b/mojo/public/cpp/system/invitation.cc
@@ -0,0 +1,30 @@
+#include "mojo/public/cpp/system/invitation.h"
+
+namespace mojo {
+
+PlatformChannelEndpoint::PlatformChannelEndpoint(PlatformHandle handle)
+    : handle_(std::move(handle)) {}
+
+PlatformChannelEndpoint::PlatformChannelEndpoint(
+    PlatformChannelEndpoint&& other) = default;
+
+IncomingInvitation::IncomingInvitation() = default;
+
+IncomingInvitation::IncomingInvitation(IncomingInvitation&& other) = default;
+
+IncomingInvitation& IncomingInvitation::operator=(IncomingInvitation&& other) = default;
+
+IncomingInvitation IncomingInvitation::Accept(
+    PlatformChannelEndpoint channel_endpoint) {
+  mojo::edk::SetParentPipeHandle(
+      mojo::edk::ScopedPlatformHandle(mojo::edk::PlatformHandle(
+          channel_endpoint.TakePlatformHandle().TakeFD().release())));
+  return IncomingInvitation();
+}
+
+ScopedMessagePipeHandle IncomingInvitation::ExtractMessagePipe(
+    base::StringPiece token) {
+  return mojo::edk::CreateChildMessagePipe(token.as_string());
+}
+
+}  // namespace mojo
diff --git a/mojo/public/cpp/system/invitation.h b/mojo/public/cpp/system/invitation.h
new file mode 100644
index 0000000..3c58968
--- /dev/null
+++ b/mojo/public/cpp/system/invitation.h
@@ -0,0 +1,40 @@
+#ifndef MOJO_PUBLIC_CPP_SYSTEM_INVITATION_H_
+#define MOJO_PUBLIC_CPP_SYSTEM_INVITATION_H_
+
+#include <utility>
+
+#include "base/macros.h"
+#include "base/strings/string_piece.h"
+#include "mojo/edk/embedder/embedder.h"
+#include "mojo/public/cpp/system/platform_handle.h"
+
+namespace mojo {
+
+class PlatformChannelEndpoint {
+ public:
+  explicit PlatformChannelEndpoint(PlatformHandle handle);
+  PlatformChannelEndpoint(PlatformChannelEndpoint&& other);
+  PlatformHandle TakePlatformHandle() WARN_UNUSED_RESULT {
+    return std::move(handle_);
+  }
+ private:
+  PlatformHandle handle_;
+
+  DISALLOW_COPY_AND_ASSIGN(PlatformChannelEndpoint);
+};
+
+class IncomingInvitation {
+ public:
+  IncomingInvitation();
+  IncomingInvitation(IncomingInvitation&& other);
+
+  IncomingInvitation& operator=(IncomingInvitation&& other);
+
+  static IncomingInvitation Accept(
+      PlatformChannelEndpoint channel_endpoint);
+  ScopedMessagePipeHandle ExtractMessagePipe(base::StringPiece token);
+};
+
+} // mojo
+
+#endif // MOJO_PUBLIC_CPP_SYSTEM_INVITATION_H_
diff --git a/mojo/public/cpp/system/platform_handle.cc b/mojo/public/cpp/system/platform_handle.cc
index 42e4aba..6116860 100644
--- a/mojo/public/cpp/system/platform_handle.cc
+++ b/mojo/public/cpp/system/platform_handle.cc
@@ -31,6 +31,29 @@ base::PlatformFile PlatformFileFromPlatformHandleValue(uint64_t value) {
 
 }  // namespace
 
+
+ScopedHandle WrapPlatformHandle(PlatformHandle handle) {
+  MojoPlatformHandle platform_handle;
+  PlatformHandle::ToMojoPlatformHandle(std::move(handle), &platform_handle);
+
+  MojoHandle wrapped_handle;
+  MojoResult result =
+      MojoWrapPlatformHandle(&platform_handle, &wrapped_handle);
+  if (result != MOJO_RESULT_OK)
+    return ScopedHandle();
+  return ScopedHandle(Handle(wrapped_handle));
+}
+
+PlatformHandle UnwrapPlatformHandle(ScopedHandle handle) {
+  MojoPlatformHandle platform_handle;
+  platform_handle.struct_size = sizeof(platform_handle);
+  MojoResult result = MojoUnwrapPlatformHandle(handle.release().value(),
+                                               &platform_handle);
+  if (result != MOJO_RESULT_OK)
+    return PlatformHandle();
+  return PlatformHandle::FromMojoPlatformHandle(&platform_handle);
+}
+
 ScopedHandle WrapPlatformFile(base::PlatformFile platform_file) {
   MojoPlatformHandle platform_handle;
   platform_handle.struct_size = sizeof(MojoPlatformHandle);
@@ -175,4 +198,38 @@ MojoResult UnwrapMachPort(ScopedHandle handle, mach_port_t* port) {
 }
 #endif  // defined(OS_MACOSX) && !defined(OS_IOS)
 
+// static
+PlatformHandle PlatformHandle::FromMojoPlatformHandle(
+    const MojoPlatformHandle* handle) {
+  if (handle->struct_size < sizeof(*handle) ||
+      handle->type == MOJO_PLATFORM_HANDLE_TYPE_INVALID) {
+    return PlatformHandle();
+  }
+
+  if (handle->type != MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR)
+    return PlatformHandle();
+  return PlatformHandle(base::ScopedFD(static_cast<int>(handle->value)));
+}
+
+// static
+void PlatformHandle::ToMojoPlatformHandle(PlatformHandle handle,
+                                          MojoPlatformHandle* out_handle) {
+  DCHECK(out_handle);
+  out_handle->struct_size = sizeof(MojoPlatformHandle);
+  if (handle.type_ == Type::kNone) {
+    out_handle->type = MOJO_PLATFORM_HANDLE_TYPE_INVALID;
+    out_handle->value = 0;
+    return;
+  }
+
+  do {
+    DCHECK(handle.is_fd());
+    out_handle->type = MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR;
+    out_handle->value = static_cast<uint64_t>(handle.TakeFD().release());
+  } while (false);
+
+  // One of the above cases must take ownership of |handle|.
+  DCHECK(!handle.is_valid());
+}
+
 }  // namespace mojo
diff --git a/mojo/public/cpp/system/platform_handle.h b/mojo/public/cpp/system/platform_handle.h
index 801264e..e034ef8 100644
--- a/mojo/public/cpp/system/platform_handle.h
+++ b/mojo/public/cpp/system/platform_handle.h
@@ -30,6 +30,61 @@
 
 namespace mojo {
 
+class PlatformHandle {
+public:
+  enum class Type {
+    kNone,
+    kFd,
+  };
+
+  PlatformHandle() = default;
+  PlatformHandle(PlatformHandle&& other) {
+    *this = std::move(other);
+  }
+  explicit PlatformHandle(base::ScopedFD fd)
+    : type_(Type::kFd), fd_(std::move(fd)) {
+  }
+
+  ~PlatformHandle() = default;
+
+  PlatformHandle& operator=(PlatformHandle&& other) {
+    type_ = other.type_;
+    other.type_ = Type::kNone;
+
+    fd_ = std::move(other.fd_);
+
+    return *this;
+  }
+
+  // Takes ownership of |handle|'s underlying platform handle and fills in
+  // |mojo_handle| with a representation of it. The caller assumes ownership of
+  // the platform handle.
+  static void ToMojoPlatformHandle(PlatformHandle handle,
+                                   MojoPlatformHandle* mojo_handle);
+
+  // Closes the underlying platform handle.
+  // Assumes ownership of the platform handle described by |handle|, and returns
+  // it as a new PlatformHandle.
+  static PlatformHandle FromMojoPlatformHandle(
+      const MojoPlatformHandle* handle);
+
+  bool is_valid() const { return is_valid_fd(); }
+  bool is_valid_fd() const { return fd_.is_valid(); }
+  bool is_fd() const { return type_ == Type::kFd; }
+  const base::ScopedFD& GetFD() const { return fd_; }
+  base::ScopedFD TakeFD() {
+    return std::move(fd_);
+  }
+
+  int ReleaseFD() WARN_UNUSED_RESULT {
+    return fd_.release();
+  }
+
+private:
+  Type type_;
+  base::ScopedFD fd_;
+};
+
 #if defined(OS_POSIX)
 const MojoPlatformHandleType kPlatformFileHandleType =
     MOJO_PLATFORM_HANDLE_TYPE_FILE_DESCRIPTOR;
@@ -58,6 +113,14 @@ ScopedHandle WrapPlatformFile(base::PlatformFile platform_file);
 MOJO_CPP_SYSTEM_EXPORT
 MojoResult UnwrapPlatformFile(ScopedHandle handle, base::PlatformFile* file);
 
+// Wraps a PlatformHandle from the C++ platform support library as a Mojo
+// handle.
+MOJO_CPP_SYSTEM_EXPORT ScopedHandle WrapPlatformHandle(PlatformHandle handle);
+
+// Unwraps a Mojo handle to a PlatformHandle object from the C++ platform
+// support library.
+MOJO_CPP_SYSTEM_EXPORT PlatformHandle UnwrapPlatformHandle(ScopedHandle handle);
+
 // Wraps a base::SharedMemoryHandle as a Mojo handle. Takes ownership of the
 // SharedMemoryHandle. Note that |read_only| is only an indicator of whether
 // |memory_handle| only supports read-only mapping. It does NOT have any
-- 
2.24.0.393.g34dc348eaf-goog

