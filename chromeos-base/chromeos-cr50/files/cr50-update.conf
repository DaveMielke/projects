# Copyright 2016 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# This script first determines if it needs to run at all: if the cr50 firmware
# image is not present in the local directory this must be happening on a
# board without a cr50 device, no need to do anything.
#
# If the firmware image is present, the script checks the number of previous
# runs saved in a state file. The file name is bound to the firmware image, if
# the firmware image changes, the name of the state file will also have to
# change.
#
# In most cases one firmware update run will be enough, but sometimes more
# than one step will be required (when updating from an old cr50 version or
# when rotating RW keys). The entire chromebook needs to be restarted between
# cr50 update runs, up to four update runs on a particular firmware image are
# allowed by this script.
#
# The usb_updater utility exit status indicates if more runs are required.
# Exit status of 0 means update has succeeded. Other exit statuses are
# processed by the follow up startup script cr50-result.conf.
#

description     "Chromium OS startup file for cr50 firmware updater"
author          "chromium-os-dev@chromium.org"

start on starting system-services

# Certain boards require transfer over /dev/tpm0 as opposed to usb. For those
# boards, when emerging chromeos-cr50 this line will be replaced with '="-s"'
env USB_UPDATER_DEFAULT_OPTIONS=

script

  logit() {
    logger -t ${UPSTART_JOB} "$*"
  }

  # Sleep if a delay between usb_updater accesses to the cr50 device is
  # necessary.
  access_delay() {
    local image_type="$1"

    if [ "${image_type}" = "old" ]; then
      sleep 6   # It needs at least 5 seconds.
    fi
  }

  CR50_IMAGE_BASE="/opt/google/cr50/firmware/cr50.bin"
  CROSSYSTEM="/usr/bin/crossystem"
  STATE_DIR="/var/cache"
  UPDATER="/usr/sbin/usb_updater"

  logit "Starting cr50 update"

  for f in "${CROSSYSTEM}" "${UPDATER}"; do
    if [ ! -f "${f}" ]; then
      logit "${f} not found, quitting."
      exit 4
    fi
  done

  if "${CROSSYSTEM}" "mainfw_act?recovery"; then
    logit "Not running in recovery mode"
    exit 0
  fi

  BOARD="$(grep CHROMEOS_RELEASE_BOARD /etc/lsb-release)"
  BOARD="${BOARD#*=}"
  VERSIONF="${STATE_DIR}/cr50-version"

  if [ -z "${BOARD}" ]; then
    logit "Could not determine board type"
    exit 4
  fi

  logit "running on ${BOARD}"

  # We need to keep a counter of boot attempts for the current state of the
  # cr50 images in /opt/google/cr50/firmware directory. Let's make sure we are
  # not running more than 3 times no matter what, and don't fail even if there
  # is no files in the directory.
  file_list="/dev/null"
  for f in ${CR50_IMAGE_BASE}*; do
    if [ -f "${f}" ]; then
      file_list="${file_list} ${f}"
    fi
  done

  # File to keep state of the update process.
  logit "hashing files ${file_list}"
  STATEF="${STATE_DIR}/cr50.$(cat ${file_list} | md5sum | cut -c-10).state"

  if [ ! -f "${STATEF}" ]; then
    # Must be a new image, get rid of the old state files.
    rm -f "${STATE_DIR}"/cr50.*.state
    echo "0" > "${STATEF}"
  else
    state="$(cat "${STATEF}")"
    case "${state}" in
    (3)
      logit " not running"
      exit 0
      ;;
    ([012])
      : $(( state += 1 ))
      echo "${state}" > "${STATEF}"
      ;;
    (*)
      logit "unexpected state ${state}"
      echo "0" > "${STATEF}"
      ;;
    esac
  fi

  # Now 'usb_updater -f' output is scanned to determine which kind of cr50
  # device is installed on this system. This is not completely
  # straightforward. A typical output looks as follows:
  #
  # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
  # target running protocol version 6
  # offsets: backup RO at 0x40000, backup RW at 0x4000
  # keyids: RO 0x3716ee6b, RW 0xb93d6539
  # Current versions:
  # RO 0.0.10
  # RW 0.0.9
  # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #
  # but older versions of cr50 firmware do not report the key IDs. So, the
  # following cases are possible:
  #
  # - the RW image is older than 0.0.11. In this case each subsequent
  #   invocation of usb_updater needs to be delayed by at least 5 seconds (to
  #   return the updater state machine on the device into the idle state).
  #
  # - the /^Keyid: / string is present in the output AND the RO key ID has bit
  #   D2 set. This indicates a prod signed cr50 device. If the string is not
  #   present, or the bit is not set - the cr50 is dev signed.


  # Let's always go over /dev/tpm0 here, it won't take long.
  output="$("${UPDATER}" -s -f)"

  logit "version retrieved"
  logit "${output}"

  # File to stash full output of usb_updater -f for feedback
  echo "${output}" > "${VERSIONF}"

  old="$(echo "${output}" | \
    awk '/^RW 0\.0\.[0-9]$/ || /^RW 0\.0\.10$/ {print "old"}')"
  if [ -n "${old}" ]; then
    # this is an old device
    logit "Detected legacy cr50 device"
  fi

  # Let's find out the if it is prod or dev signed.
  suffix="$(echo "${output}" | \
    awk '/^keyids: RO 0x[^ ]+[4567cdef], / {print "prod"}')"
  if [ -z "${suffix}" ]; then
    suffix="dev"
  fi

  logit "cr50 device using ${suffix} keys"

  cr50_image="${CR50_IMAGE_BASE}.${suffix}"

  if [ ! -f "${cr50_image}" ]; then
    logit "${cr50_image} not found"
    exit 4
  fi

  sync

  access_delay "${old}"

  usb_update_options="${USB_UPDATER_DEFAULT_OPTIONS}"

  # This makes sure that H1 does not reboot immediately after an update, but
  # waits for the AP to reset the system, and then reboots to pick up the new
  # image.
  usb_update_options="${usb_update_options} -u"

  logit "Will run ${UPDATER} ${usb_update_options} ${cr50_image}"
  "${UPDATER}" ${usb_update_options} "${cr50_image}"

  # Successful completion means cr50 is up to date, no more update attempts
  # are required for this firmware image.
  logit "cr50 is running updated firmware"
  echo "3" > "${STATEF}"
end script
