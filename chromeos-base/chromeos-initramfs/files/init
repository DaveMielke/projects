#!/bin/sh -x

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# /init script for use in factory install shim.  Requires busybox in
# /bin/busybox, and a symlink from /bin/sh -> busybox.

# USB card partition and mount point.
USB_DEVS="sdb3 sdc3 mmcblk1p3"
USB_MNT=/usb
REAL_USB_DEV=

STATEFUL_MNT=/stateful
STATE_DEV=

# Size of the root ramdisk.
TMPFS_SIZE=300M

on_error() {
  # Exit, thus causing a kernel panic. We don't want to do anything else (like
  # start a shell) because it would be trivially easy to get here (just unplug
  # the USB drive after the kernel starts but before the USB drives are probed
  # by the kernel) and starting a shell here would be a BIG security hole.
  exit 1
}

initial_mounts() {
  mkdir -p /var/lock
  mount -t proc -o nodev,noexec,nosuid none /proc
  mount -t sysfs -o nodev,noexec,nosuid none /sys
  if ! mount -t devtmpfs -o mode=0755 none /dev; then
    mount -t tmpfs -o mode=0755 none /dev
    mknod -m 0600 /dev/console c 5 1
    mknod -m 0600 /dev/tty1 c 4 1
    mknod /dev/null c 1 3
  fi
  mkdir /dev/pts
  mount -t devpts -o noexec,nosuid none /dev/pts || true
}

# Look for any USB device.
wait_for_root() {
  echo -n "Waiting for $USB_DEVS to appear"
  for try in $(seq 20); do
    echo -n "."
    for dev in $USB_DEVS; do
      if [ -b "/dev/${dev}" ]; then
        USB_DEV="/dev/${dev}"
        echo "Found $USB_DEV"
        return 0
      fi
    done
    sleep 1
  done
  echo "Failed waiting for root!"
  return 1
}

# Wait for dm-0 to come up.
wait_for_dm_control() {
  MAPPER_CONTROL=/dev/mapper/control
  echo -n "Waiting for $MAPPER_CONTROL to appear"
  for try in $(seq 20); do
    echo -n "."
    if [ -c "$MAPPER_CONTROL" ]; then
      return 0
    fi
    sleep 1
  done
  echo "Failed waiting for $MAPPER_CONTROL!"
  return 1
}

setup_dm_root() {
  echo -n "Extracting the device mapper configuration..."
  DMARG=$(cat /proc/cmdline | sed -e 's/.*dm="\([^"\]*\)".*/\1/g')
  DM_NAME=$(echo "$DMARG" | cut -f1 -d' ')
  # We override the reboot-to-recovery error behavior so that we can fail
  # gracefully on invalid rootfs.
  DM_TABLE="$(echo "$DMARG" | cut -f2 -d,) eio"
  if ! dmsetup create -r "$DM_NAME" --major 254 --minor 0 --table "$DM_TABLE"
  then
    echo "Failed to configure device mapper root"
    return 1
  fi
  USB_DEV="/dev/dm-0"
  if [ ! -b "$USB_DEV" ]; then
    mknod -m 0600 /dev/dm-0 b 254 0
  fi
  echo "Created device mapper root $DM_NAME."
  return 0
}

# Look for a device with our GPT ID.
wait_for_gpt_root() {
  echo -n "Looking for rootfs..."
  for try in $(seq 20); do
    echo -n "."
    newroot=$(/usr/sbin/chromeos-findrootfs)
    if [ -n "$newroot" ]; then
      USB_DEV="$newroot"
      echo "Found $USB_DEV"
      return 0
    fi
    sleep 1
  done
  echo "Failed waiting for kern_guid"
  return 1
}

mount_usb() {
  echo -n "Mounting usb"
  for try in $(seq 20); do
    echo -n "."
    if mount -n -o ro "$USB_DEV" "$USB_MNT"; then
      echo "ok"
      return 0
    fi
    sleep 1
  done
  echo "Failed to mount usb!"
  return 1
}

check_if_dm_root() {
  grep -q "root=/dev/dm-0" /proc/cmdline
}

check_if_factory_install() {
  if [ -e "${USB_MNT}/root/.factory_installer" ]; then
    echo "Detected factory install."
    return 0
  fi
  return 1
}

get_stateful_dev() {
  # Determine the STATE_DEV using rootdev on the target
  # to work seamlessly with dm-verity or normal devices.
  REAL_USB_DEV=$(rootdev -s "$USB_MNT")
  STATE_DEV=${REAL_USB_DEV%[0-9]*}1
  if [ ! -b "$STATE_DEV" ]; then
    echo "Failed to determine stateful device"
    return 1
  fi
  return 0
}

mount_tmpfs() {
  echo "Mounting tmpfs..."
  mount -n -t tmpfs tmpfs "$NEWROOT_MNT" -o "size=$TMPFS_SIZE"
  return $?
}

copy_contents() {
  echo "Copying usb->tmpfs..."
  (cd "${USB_MNT}" ; tar cf - . | (cd "${NEWROOT_MNT}" && tar xf  -))
  RES=$?
  echo "Copy returned with result $RES"
  return $RES
}

copy_lsb() {
  STATEFUL_LSB="dev_image/etc/lsb-factory"
  mkdir -p "${NEWROOT_MNT}/mnt/stateful_partition/dev_image/etc"
  mount -n -o ro -t ext3 "$STATE_DEV" "$STATEFUL_MNT"
  if [ -f "${STATEFUL_MNT}/${STATEFUL_LSB}" ]; then
    echo "Found ${STATEFUL_MNT}/${STATEFUL_LSB}"
    cp -a "${STATEFUL_MNT}/${STATEFUL_LSB}" \
        "${NEWROOT_MNT}/mnt/stateful_partition/${STATEFUL_LSB}"
  fi
  umount "$STATEFUL_MNT"
  rmdir "$STATEFUL_MNT"
}

move_mounts() {
  echo "Moving sys. proc, dev to $NEWROOT_MNT"
  mount -n -o move /sys "$NEWROOT_MNT/sys"
  mount -n -o move /proc "$NEWROOT_MNT/proc"
  mount -n -o move /dev "$NEWROOT_MNT/dev"
  echo "Done."
  return 0
}

unmount_usb() {
  echo "Unmounting $USB_MNT"
  umount "$USB_MNT"
  echo
  echo "$USB_DEV can now be safely removed"
  echo
  return 0
}

main() {
  # Set up basic mounts, console.
  initial_mounts

  # Send any output to where we can see it.
  exec &> /dev/tty1
  echo "Starting initramfs"

  # If we were booted with a dm-verity rootfs, then
  # we can just wait for it to come up.
  if check_if_dm_root; then
    wait_for_dm_control || on_error
    setup_dm_root || on_error
  # Has the BIOS told us the partition ID?
  elif check_for_gptid; then
    wait_for_gpt_root || on_error
  else
    # Just wait for any rootfs.
    # TODO(nsanders): add kern_guid into legacy cmdline?
    wait_for_root || on_error
  fi

  mount_usb || on_error
  get_stateful_dev || on_error

  # Check if we want to run from RAM, in the factory.
  if check_if_factory_install; then
    # Copy rootfs contents to tmpfs, then unmount USB device.
    NEWROOT_MNT=/newroot
    mount_tmpfs || on_error
    copy_contents || on_error
    copy_lsb || on_error
    # USB device is unmounted, we can remove it now.
    unmount_usb || on_error
  else
    NEWROOT_MNT="$USB_MNT"
  fi

  move_mounts || on_error
  # Chroot into newroot, erase the contents of the old /, and exec real init.
  echo "About to switch root"
  exec switch_root -c /dev/console "$NEWROOT_MNT" /sbin/init

  # This should not really happen.
  echo "Failed to switch root"

  # Fail here.
  on_error
}


main

# Should never reach here.
exit 1
