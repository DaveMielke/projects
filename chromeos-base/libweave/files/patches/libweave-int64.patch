diff --git a/src/backoff_entry.cc b/src/backoff_entry.cc
index 6b99d79..7efc33b 100644
--- a/src/backoff_entry.cc
+++ b/src/backoff_entry.cc
@@ -74,7 +74,7 @@ bool BackoffEntry::CanDiscard() const {
 
   base::TimeTicks now = ImplGetTimeNow();
 
-  int64 unused_since_ms =
+  int64_t unused_since_ms =
       (now - exponential_backoff_release_time_).InMilliseconds();
 
   // Release time is further than now, we are managing it.
@@ -152,7 +152,7 @@ base::TimeTicks BackoffEntry::CalculateReleaseTime() const {
 
   // Decide between maximum release time and calculated release time, accounting
   // for overflow with both.
-  int64 release_time_us =
+  int64_t release_time_us =
       std::min(calculated_release_time_us.ValueOrDefault(kMaxTime),
                maximum_release_time_us.ValueOrDefault(kMaxTime));
 
diff --git a/src/backoff_entry.h b/src/backoff_entry.h
index 2df0d8a..6e998ec 100644
--- a/src/backoff_entry.h
+++ b/src/backoff_entry.h
@@ -38,11 +38,11 @@ class BackoffEntry {
 
     // Maximum amount of time we are willing to delay our request, -1
     // for no maximum.
-    int64 maximum_backoff_ms;
+    int64_t maximum_backoff_ms;
 
     // Time to keep an entry from being discarded even when it
     // has no significant state, -1 to never discard.
-    int64 entry_lifetime_ms;
+    int64_t entry_lifetime_ms;
 
     // If true, we always use a delay of initial_delay_ms, even before
     // we've seen num_errors_to_ignore errors.  Otherwise, initial_delay_ms
diff --git a/third_party/chromium/crypto/p224.cc b/third_party/chromium/crypto/p224.cc
index 81bce3a..ce3b7ee 100644
--- a/third_party/chromium/crypto/p224.cc
+++ b/third_party/chromium/crypto/p224.cc
@@ -11,17 +11,14 @@
 
 #include <string.h>
 
-namespace crypto {
-namespace p224 {
-
 namespace {
 
-inline uint32 ByteSwap(uint32 x) {
+inline uint32_t ByteSwap(uint32_t x) {
   return ((x & 0x000000fful) << 24) | ((x & 0x0000ff00ul) << 8) |
          ((x & 0x00ff0000ul) >> 8) | ((x & 0xff000000ul) >> 24);
 }
 
-inline uint32 HostToNet32(uint32 x) {
+inline uint32_t HostToNet32(uint32_t x) {
 #if defined(ARCH_CPU_LITTLE_ENDIAN)
   return ByteSwap(x);
 #else
@@ -29,7 +26,7 @@ inline uint32 HostToNet32(uint32 x) {
 #endif
 }
 
-inline uint32 NetToHost32(uint32 x) {
+inline uint32_t NetToHost32(uint32_t x) {
 #if defined(ARCH_CPU_LITTLE_ENDIAN)
   return ByteSwap(x);
 #else
@@ -42,13 +39,15 @@ inline uint32 NetToHost32(uint32 x) {
 // The field that we're dealing with is ℤ/pℤ where p = 2**224 - 2**96 + 1.
 //
 // Field elements are represented by a FieldElement, which is a typedef to an
-// array of 8 uint32's. The value of a FieldElement, a, is:
+// array of 8 uint32_t's. The value of a FieldElement, a, is:
 //   a[0] + 2**28·a[1] + 2**56·a[1] + ... + 2**196·a[7]
 //
 // Using 28-bit limbs means that there's only 4 bits of headroom, which is less
 // than we would really like. But it has the useful feature that we hit 2**224
 // exactly, making the reflections during a reduce much nicer.
 
+using crypto::p224::FieldElement;
+
 // kP is the P224 prime.
 const FieldElement kP = {
   1, 0, 0, 268431360,
@@ -58,12 +57,12 @@ const FieldElement kP = {
 void Contract(FieldElement* inout);
 
 // IsZero returns 0xffffffff if a == 0 mod p and 0 otherwise.
-uint32 IsZero(const FieldElement& a) {
+uint32_t IsZero(const FieldElement& a) {
   FieldElement minimal;
   memcpy(&minimal, &a, sizeof(minimal));
   Contract(&minimal);
 
-  uint32 is_zero = 0, is_p = 0;
+  uint32_t is_zero = 0, is_p = 0;
   for (unsigned i = 0; i < 8; i++) {
     is_zero |= minimal[i];
     is_p |= minimal[i] - kP[i];
@@ -85,7 +84,7 @@ uint32 IsZero(const FieldElement& a) {
   // For is_zero and is_p, the LSB is 0 iff all the bits are zero.
   is_zero &= is_p & 1;
   is_zero = (~is_zero) << 31;
-  is_zero = static_cast<int32>(is_zero) >> 31;
+  is_zero = static_cast<int32_t>(is_zero) >> 31;
   return is_zero;
 }
 
@@ -98,9 +97,9 @@ void Add(FieldElement* out, const FieldElement& a, const FieldElement& b) {
   }
 }
 
-static const uint32 kTwo31p3 = (1u << 31) + (1u << 3);
-static const uint32 kTwo31m3 = (1u << 31) - (1u << 3);
-static const uint32 kTwo31m15m3 = (1u << 31) - (1u << 15) - (1u << 3);
+static const uint32_t kTwo31p3 = (1u << 31) + (1u << 3);
+static const uint32_t kTwo31m3 = (1u << 31) - (1u << 3);
+static const uint32_t kTwo31m15m3 = (1u << 31) - (1u << 15) - (1u << 3);
 // kZero31ModP is 0 mod p where bit 31 is set in all limbs so that we can
 // subtract smaller amounts without underflow. See the section "Subtraction" in
 // [1] for why.
@@ -120,22 +119,22 @@ void Subtract(FieldElement* out, const FieldElement& a, const FieldElement& b) {
   }
 }
 
-static const uint64 kTwo63p35 = (1ull<<63) + (1ull<<35);
-static const uint64 kTwo63m35 = (1ull<<63) - (1ull<<35);
-static const uint64 kTwo63m35m19 = (1ull<<63) - (1ull<<35) - (1ull<<19);
+static const uint64_t kTwo63p35 = (1ull << 63) + (1ull << 35);
+static const uint64_t kTwo63m35 = (1ull << 63) - (1ull << 35);
+static const uint64_t kTwo63m35m19 = (1ull << 63) - (1ull << 35) - (1ull << 19);
 // kZero63ModP is 0 mod p where bit 63 is set in all limbs. See the section
 // "Subtraction" in [1] for why.
-static const uint64 kZero63ModP[8] = {
-  kTwo63p35, kTwo63m35, kTwo63m35, kTwo63m35,
-  kTwo63m35m19, kTwo63m35, kTwo63m35, kTwo63m35,
+static const uint64_t kZero63ModP[8] = {
+    kTwo63p35,    kTwo63m35, kTwo63m35, kTwo63m35,
+    kTwo63m35m19, kTwo63m35, kTwo63m35, kTwo63m35,
 };
 
-static const uint32 kBottom28Bits = 0xfffffff;
+static const uint32_t kBottom28Bits = 0xfffffff;
 
 // LargeFieldElement also represents an element of the field. The limbs are
 // still spaced 28-bits apart and in little-endian order. So the limbs are at
 // 0, 28, 56, ..., 392 bits, each 64-bits wide.
-typedef uint64 LargeFieldElement[15];
+typedef uint64_t LargeFieldElement[15];
 
 // ReduceLarge converts a LargeFieldElement to a FieldElement.
 //
@@ -170,21 +169,21 @@ void ReduceLarge(FieldElement* out, LargeFieldElement* inptr) {
   // 32-bit operations.
   for (int i = 1; i < 8; i++) {
     in[i+1] += in[i] >> 28;
-    (*out)[i] = static_cast<uint32>(in[i] & kBottom28Bits);
+    (*out)[i] = static_cast<uint32_t>(in[i] & kBottom28Bits);
   }
   // Eliminate the term at 2*224 that we introduced while keeping the same
   // value mod p.
   in[0] -= in[8];  // reflection off the "+1" term of p.
-  (*out)[3] += static_cast<uint32>(in[8] & 0xffff) << 12;  // "-2**96" term
-  (*out)[4] += static_cast<uint32>(in[8] >> 16);  // rest of "-2**96" term
+  (*out)[3] += static_cast<uint32_t>(in[8] & 0xffff) << 12;  // "-2**96" term
+  (*out)[4] += static_cast<uint32_t>(in[8] >> 16);  // rest of "-2**96" term
   // in[0] < 2**64
   // out[3] < 2**29
   // out[4] < 2**29
   // out[1,2,5..7] < 2**28
 
-  (*out)[0] = static_cast<uint32>(in[0] & kBottom28Bits);
-  (*out)[1] += static_cast<uint32>((in[0] >> 28) & kBottom28Bits);
-  (*out)[2] += static_cast<uint32>(in[0] >> 56);
+  (*out)[0] = static_cast<uint32_t>(in[0] & kBottom28Bits);
+  (*out)[1] += static_cast<uint32_t>((in[0] >> 28) & kBottom28Bits);
+  (*out)[2] += static_cast<uint32_t>(in[0] >> 56);
   // out[0] < 2**28
   // out[1..4] < 2**29
   // out[5..7] < 2**28
@@ -206,7 +205,7 @@ void Mul(FieldElement* out, const FieldElement& a, const FieldElement& b) {
 
   for (int i = 0; i < 8; i++) {
     for (int j = 0; j < 8; j++) {
-      tmp[i+j] += static_cast<uint64>(a[i]) * static_cast<uint64>(b[j]);
+      tmp[i + j] += static_cast<uint64_t>(a[i]) * static_cast<uint64_t>(b[j]);
     }
   }
 
@@ -223,7 +222,7 @@ void Square(FieldElement* out, const FieldElement& a) {
 
   for (int i = 0; i < 8; i++) {
     for (int j = 0; j <= i; j++) {
-      uint64 r = static_cast<uint64>(a[i]) * static_cast<uint64>(a[j]);
+      uint64_t r = static_cast<uint64_t>(a[i]) * static_cast<uint64_t>(a[j]);
       if (i == j) {
         tmp[i+j] += r;
       } else {
@@ -246,16 +245,16 @@ void Reduce(FieldElement* in_out) {
     a[i+1] += a[i] >> 28;
     a[i] &= kBottom28Bits;
   }
-  uint32 top = a[7] >> 28;
+  uint32_t top = a[7] >> 28;
   a[7] &= kBottom28Bits;
 
   // top < 2**4
   // Constant-time: mask = (top != 0) ? 0xffffffff : 0
-  uint32 mask = top;
+  uint32_t mask = top;
   mask |= mask >> 2;
   mask |= mask >> 1;
   mask <<= 31;
-  mask = static_cast<uint32>(static_cast<int32>(mask) >> 31);
+  mask = static_cast<uint32_t>(static_cast<int32_t>(mask) >> 31);
 
   // Eliminate top while maintaining the same value mod p.
   a[0] -= top;
@@ -332,7 +331,7 @@ void Contract(FieldElement* inout) {
     out[i+1] += out[i] >> 28;
     out[i] &= kBottom28Bits;
   }
-  uint32 top = out[7] >> 28;
+  uint32_t top = out[7] >> 28;
   out[7] &= kBottom28Bits;
 
   // Eliminate top while maintaining the same value mod p.
@@ -343,7 +342,7 @@ void Contract(FieldElement* inout) {
   // out[0] negative then we know that out[3] is sufficiently positive
   // because we just added to it.
   for (int i = 0; i < 3; i++) {
-    uint32 mask = static_cast<uint32>(static_cast<int32>(out[i]) >> 31);
+    uint32_t mask = static_cast<uint32_t>(static_cast<int32_t>(out[i]) >> 31);
     out[i] += (1 << 28) & mask;
     out[i+1] -= 1 & mask;
   }
@@ -376,7 +375,7 @@ void Contract(FieldElement* inout) {
   // As before, if we made out[0] negative then we know that out[3] is
   // sufficiently positive.
   for (int i = 0; i < 3; i++) {
-    uint32 mask = static_cast<uint32>(static_cast<int32>(out[i]) >> 31);
+    uint32_t mask = static_cast<uint32_t>(static_cast<int32_t>(out[i]) >> 31);
     out[i] += (1 << 28) & mask;
     out[i+1] -= 1 & mask;
   }
@@ -388,7 +387,7 @@ void Contract(FieldElement* inout) {
   // equal to bottom28Bits if the whole value is >= p. If top_4_all_ones
   // ends up with any zero bits in the bottom 28 bits, then this wasn't
   // true.
-  uint32 top_4_all_ones = 0xffffffffu;
+  uint32_t top_4_all_ones = 0xffffffffu;
   for (int i = 4; i < 8; i++) {
     top_4_all_ones &= out[i];
   }
@@ -400,37 +399,39 @@ void Contract(FieldElement* inout) {
   top_4_all_ones &= top_4_all_ones >> 2;
   top_4_all_ones &= top_4_all_ones >> 1;
   top_4_all_ones =
-      static_cast<uint32>(static_cast<int32>(top_4_all_ones << 31) >> 31);
+      static_cast<uint32_t>(static_cast<int32_t>(top_4_all_ones << 31) >> 31);
 
   // Now we test whether the bottom three limbs are non-zero.
-  uint32 bottom_3_non_zero = out[0] | out[1] | out[2];
+  uint32_t bottom_3_non_zero = out[0] | out[1] | out[2];
   bottom_3_non_zero |= bottom_3_non_zero >> 16;
   bottom_3_non_zero |= bottom_3_non_zero >> 8;
   bottom_3_non_zero |= bottom_3_non_zero >> 4;
   bottom_3_non_zero |= bottom_3_non_zero >> 2;
   bottom_3_non_zero |= bottom_3_non_zero >> 1;
   bottom_3_non_zero =
-      static_cast<uint32>(static_cast<int32>(bottom_3_non_zero) >> 31);
+      static_cast<uint32_t>(static_cast<int32_t>(bottom_3_non_zero) >> 31);
 
   // Everything depends on the value of out[3].
   //    If it's > 0xffff000 and top_4_all_ones != 0 then the whole value is >= p
   //    If it's = 0xffff000 and top_4_all_ones != 0 and bottom_3_non_zero != 0,
   //      then the whole value is >= p
   //    If it's < 0xffff000, then the whole value is < p
-  uint32 n = out[3] - 0xffff000;
-  uint32 out_3_equal = n;
+  uint32_t n = out[3] - 0xffff000;
+  uint32_t out_3_equal = n;
   out_3_equal |= out_3_equal >> 16;
   out_3_equal |= out_3_equal >> 8;
   out_3_equal |= out_3_equal >> 4;
   out_3_equal |= out_3_equal >> 2;
   out_3_equal |= out_3_equal >> 1;
   out_3_equal =
-      ~static_cast<uint32>(static_cast<int32>(out_3_equal << 31) >> 31);
+      ~static_cast<uint32_t>(static_cast<int32_t>(out_3_equal << 31) >> 31);
 
   // If out[3] > 0xffff000 then n's MSB will be zero.
-  uint32 out_3_gt = ~static_cast<uint32>(static_cast<int32>(n << 31) >> 31);
+  uint32_t out_3_gt =
+      ~static_cast<uint32_t>(static_cast<int32_t>(n << 31) >> 31);
 
-  uint32 mask = top_4_all_ones & ((out_3_equal & bottom_3_non_zero) | out_3_gt);
+  uint32_t mask =
+      top_4_all_ones & ((out_3_equal & bottom_3_non_zero) | out_3_gt);
   out[0] -= 1 & mask;
   out[3] -= 0xffff000 & mask;
   out[4] -= 0xfffffff & mask;
@@ -445,13 +446,15 @@ void Contract(FieldElement* inout) {
 // These functions deal with group elements. The group is an elliptic curve
 // group with a = -3 defined in FIPS 186-3, section D.2.2.
 
+using crypto::p224::Point;
+
 // kB is parameter of the elliptic curve.
 const FieldElement kB = {
   55967668, 11768882, 265861671, 185302395,
   39211076, 180311059, 84673715, 188764328,
 };
 
-void CopyConditional(Point* out, const Point& a, uint32 mask);
+void CopyConditional(Point* out, const Point& a, uint32_t mask);
 void DoubleJacobian(Point* out, const Point& a);
 
 // AddJacobian computes *out = a+b where a != b.
@@ -461,8 +464,8 @@ void AddJacobian(Point *out,
   // See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl
   FieldElement z1z1, z2z2, u1, u2, s1, s2, h, i, j, r, v;
 
-  uint32 z1_is_zero = IsZero(a.z);
-  uint32 z2_is_zero = IsZero(b.z);
+  uint32_t z1_is_zero = IsZero(a.z);
+  uint32_t z2_is_zero = IsZero(b.z);
 
   // Z1Z1 = Z1²
   Square(&z1z1, a.z);
@@ -487,7 +490,7 @@ void AddJacobian(Point *out,
   // H = U2-U1
   Subtract(&h, u2, u1);
   Reduce(&h);
-  uint32 x_equal = IsZero(h);
+  uint32_t x_equal = IsZero(h);
 
   // I = (2*H)²
   for (int k = 0; k < 8; k++) {
@@ -501,7 +504,7 @@ void AddJacobian(Point *out,
   // r = 2*(S2-S1)
   Subtract(&r, s2, s1);
   Reduce(&r);
-  uint32 y_equal = IsZero(r);
+  uint32_t y_equal = IsZero(r);
 
   if (x_equal && y_equal && !z1_is_zero && !z2_is_zero) {
     // The two input points are the same therefore we must use the dedicated
@@ -608,9 +611,7 @@ void DoubleJacobian(Point* out, const Point& a) {
 
 // CopyConditional sets *out=a if mask is 0xffffffff. mask must be either 0 of
 // 0xffffffff.
-void CopyConditional(Point* out,
-                     const Point& a,
-                     uint32 mask) {
+void CopyConditional(Point* out, const Point& a, uint32_t mask) {
   for (int i = 0; i < 8; i++) {
     out->x[i] ^= mask & (a.x[i] ^ out->x[i]);
     out->y[i] ^= mask & (a.y[i] ^ out->y[i]);
@@ -620,15 +621,17 @@ void CopyConditional(Point* out,
 
 // ScalarMult calculates *out = a*scalar where scalar is a big-endian number of
 // length scalar_len and != 0.
-void ScalarMult(Point* out, const Point& a,
-                const uint8* scalar, size_t scalar_len) {
+void ScalarMult(Point* out,
+                const Point& a,
+                const uint8_t* scalar,
+                size_t scalar_len) {
   memset(out, 0, sizeof(*out));
   Point tmp;
 
   for (size_t i = 0; i < scalar_len; i++) {
     for (unsigned int bit_num = 0; bit_num < 8; bit_num++) {
       DoubleJacobian(out, *out);
-      uint32 bit = static_cast<uint32>(static_cast<int32>(
+      uint32_t bit = static_cast<uint32_t>(static_cast<int32_t>(
           (((scalar[i] >> (7 - bit_num)) & 1) << 31) >> 31));
       AddJacobian(&tmp, a, *out);
       CopyConditional(out, tmp, bit);
@@ -638,7 +641,7 @@ void ScalarMult(Point* out, const Point& a,
 
 // Get224Bits reads 7 words from in and scatters their contents in
 // little-endian form into 8 words at out, 28 bits per output word.
-void Get224Bits(uint32* out, const uint32* in) {
+void Get224Bits(uint32_t* out, const uint32_t* in) {
   out[0] = NetToHost32(in[6]) & kBottom28Bits;
   out[1] = ((NetToHost32(in[5]) << 4) |
             (NetToHost32(in[6]) >> 28)) & kBottom28Bits;
@@ -658,7 +661,7 @@ void Get224Bits(uint32* out, const uint32* in) {
 // Put224Bits performs the inverse operation to Get224Bits: taking 28 bits from
 // each of 8 input words and writing them in big-endian order to 7 words at
 // out.
-void Put224Bits(uint32* out, const uint32* in) {
+void Put224Bits(uint32_t* out, const uint32_t* in) {
   out[6] = HostToNet32((in[0] >> 0) | (in[1] << 28));
   out[5] = HostToNet32((in[1] >> 4) | (in[2] << 24));
   out[4] = HostToNet32((in[2] >> 8) | (in[3] << 20));
@@ -670,10 +673,14 @@ void Put224Bits(uint32* out, const uint32* in) {
 
 }  // anonymous namespace
 
-bool Point::SetFromString(const std::string& in) {
+namespace crypto {
+
+namespace p224 {
+
+bool Point::SetFromString(const base::StringPiece& in) {
   if (in.size() != 2*28)
     return false;
-  const uint32* inwords = reinterpret_cast<const uint32*>(in.data());
+  const uint32_t* inwords = reinterpret_cast<const uint32_t*>(in.data());
   Get224Bits(x, inwords);
   Get224Bits(y, inwords + 7);
   memset(&z, 0, sizeof(z));
@@ -696,7 +703,7 @@ bool Point::SetFromString(const std::string& in) {
   Subtract(&rhs, rhs, three_x);
   Reduce(&rhs);
 
-  Add(&rhs, rhs, kB);
+  ::Add(&rhs, rhs, kB);
   Contract(&rhs);
   return memcmp(&lhs, &rhs, sizeof(lhs)) == 0;
 }
@@ -719,27 +726,27 @@ std::string Point::ToString() const {
   Contract(&xx);
   Contract(&yy);
 
-  uint32 outwords[14];
+  uint32_t outwords[14];
   Put224Bits(outwords, xx);
   Put224Bits(outwords + 7, yy);
   return std::string(reinterpret_cast<const char*>(outwords), sizeof(outwords));
 }
 
-void ScalarMult(const Point& in, const uint8* scalar, Point* out) {
-  ScalarMult(out, in, scalar, 28);
+void ScalarMult(const Point& in, const uint8_t* scalar, Point* out) {
+  ::ScalarMult(out, in, scalar, 28);
 }
 
 // kBasePoint is the base point (generator) of the elliptic curve group.
 static const Point kBasePoint = {
   {22813985, 52956513, 34677300, 203240812,
-    12143107, 133374265, 225162431, 191946955},
+   12143107, 133374265, 225162431, 191946955},
   {83918388, 223877528, 122119236, 123340192,
-    266784067, 263504429, 146143011, 198407736},
+   266784067, 263504429, 146143011, 198407736},
   {1, 0, 0, 0, 0, 0, 0, 0},
 };
 
-void ScalarBaseMult(const uint8* scalar, Point* out) {
-  ScalarMult(out, kBasePoint, scalar, 28);
+void ScalarBaseMult(const uint8_t* scalar, Point* out) {
+  ::ScalarMult(out, kBasePoint, scalar, 28);
 }
 
 void Add(const Point& a, const Point& b, Point* out) {
@@ -765,4 +772,5 @@ void Negate(const Point& in, Point* out) {
 }
 
 }  // namespace p224
+
 }  // namespace crypto
diff --git a/third_party/chromium/crypto/p224.h b/third_party/chromium/crypto/p224.h
index 7574389..e9976e6 100644
--- a/third_party/chromium/crypto/p224.h
+++ b/third_party/chromium/crypto/p224.h
@@ -5,9 +5,12 @@
 #ifndef LIBWEAVE_THIRD_PARTY_CHROMIUM_P224_H_
 #define LIBWEAVE_THIRD_PARTY_CHROMIUM_P224_H_
 
+#include <stddef.h>
+#include <stdint.h>
+
 #include <string>
 
-#include <base/basictypes.h>
+#include "base/strings/string_piece.h"
 
 namespace crypto {
 
@@ -17,14 +20,14 @@ namespace p224 {
 
 // An element of the field (ℤ/pℤ) is represented with 8, 28-bit limbs in
 // little endian order.
-typedef uint32 FieldElement[8];
+typedef uint32_t FieldElement[8];
 
 struct Point {
   // SetFromString the value of the point from the 56 byte, external
   // representation. The external point representation is an (x, y) pair of a
   // point on the curve. Each field element is represented as a big-endian
   // number < p.
-  bool SetFromString(const std::string& in);
+  bool SetFromString(const base::StringPiece& in);
 
   // ToString returns an external representation of the Point.
   std::string ToString() const;
@@ -39,11 +42,11 @@ static const size_t kScalarBytes = 28;
 
 // ScalarMult computes *out = in*scalar where scalar is a 28-byte, big-endian
 // number.
-void ScalarMult(const Point& in, const uint8* scalar, Point* out);
+void ScalarMult(const Point& in, const uint8_t* scalar, Point* out);
 
 // ScalarBaseMult computes *out = g*scalar where g is the base point of the
 // curve and scalar is a 28-byte, big-endian number.
-void ScalarBaseMult(const uint8* scalar, Point* out);
+void ScalarBaseMult(const uint8_t* scalar, Point* out);
 
 // Add computes *out = a+b.
 void Add(const Point& a, const Point& b, Point* out);
@@ -52,6 +55,7 @@ void Add(const Point& a, const Point& b, Point* out);
 void Negate(const Point& a, Point* out);
 
 }  // namespace p224
+
 }  // namespace crypto
 
 #endif  // LIBWEAVE_THIRD_PARTY_CHROMIUM_P224_H_
diff --git a/third_party/chromium/crypto/p224_spake.cc b/third_party/chromium/crypto/p224_spake.cc
index 6d82322..d55d2a7 100644
--- a/third_party/chromium/crypto/p224_spake.cc
+++ b/third_party/chromium/crypto/p224_spake.cc
@@ -14,8 +14,6 @@
 
 #include "third_party/chromium/crypto/p224.h"
 
-namespace crypto {
-
 namespace {
 
 // The following two points (M and N in the protocol) are verifiable random
@@ -79,19 +77,19 @@ namespace {
 //   return 0;
 // }
 
-const p224::Point kM = {
+const crypto::p224::Point kM = {
   {174237515, 77186811, 235213682, 33849492,
-    33188520, 48266885, 177021753, 81038478},
+   33188520, 48266885, 177021753, 81038478},
   {104523827, 245682244, 266509668, 236196369,
-    28372046, 145351378, 198520366, 113345994},
+   28372046, 145351378, 198520366, 113345994},
   {1, 0, 0, 0, 0, 0, 0, 0},
 };
 
-const p224::Point kN = {
+const crypto::p224::Point kN = {
   {136176322, 263523628, 251628795, 229292285,
-    5034302, 185981975, 171998428, 11653062},
+   5034302, 185981975, 171998428, 11653062},
   {197567436, 51226044, 60372156, 175772188,
-    42075930, 8083165, 160827401, 65097570},
+   42075930, 8083165, 160827401, 65097570},
   {1, 0, 0, 0, 0, 0, 0, 0},
 };
 
@@ -114,9 +112,12 @@ bool SecureMemEqual(const uint8_t* s1_ptr, const uint8_t* s2_ptr, size_t n) {
 
 }  // anonymous namespace
 
-P224EncryptedKeyExchange::P224EncryptedKeyExchange(PeerType peer_type,
-                                                   const std::string& password)
-    : state_(kStateInitial), is_server_(peer_type == kPeerTypeServer) {
+namespace crypto {
+
+P224EncryptedKeyExchange::P224EncryptedKeyExchange(
+    PeerType peer_type, const base::StringPiece& password)
+    : state_(kStateInitial),
+      is_server_(peer_type == kPeerTypeServer) {
   memset(&x_, 0, sizeof(x_));
   memset(&expected_authenticator_, 0, sizeof(expected_authenticator_));
 
@@ -163,7 +164,7 @@ const std::string& P224EncryptedKeyExchange::GetNextMessage() {
 }
 
 P224EncryptedKeyExchange::Result P224EncryptedKeyExchange::ProcessMessage(
-    const std::string& message) {
+    const base::StringPiece& message) {
   if (state_ == kStateRecvHash) {
     // This is the final state of the protocol: we are reading the peer's
     // authentication hash and checking that it matches the one that we expect.
@@ -210,23 +211,23 @@ P224EncryptedKeyExchange::Result P224EncryptedKeyExchange::ProcessMessage(
 
   std::string client_masked_dh, server_masked_dh;
   if (is_server_) {
-    client_masked_dh = message;
+    client_masked_dh = message.as_string();
     server_masked_dh = next_message_;
   } else {
     client_masked_dh = next_message_;
-    server_masked_dh = message;
+    server_masked_dh = message.as_string();
   }
 
   // Now we calculate the hashes that each side will use to prove to the other
   // that they derived the correct value for K.
-  uint8 client_hash[kSHA256Length], server_hash[kSHA256Length];
+  uint8_t client_hash[kSHA256Length], server_hash[kSHA256Length];
   CalculateHash(kPeerTypeClient, client_masked_dh, server_masked_dh, key_,
                 client_hash);
   CalculateHash(kPeerTypeServer, client_masked_dh, server_masked_dh, key_,
                 server_hash);
 
-  const uint8* my_hash = is_server_ ? server_hash : client_hash;
-  const uint8* their_hash = is_server_ ? client_hash : server_hash;
+  const uint8_t* my_hash = is_server_ ? server_hash : client_hash;
+  const uint8_t* their_hash = is_server_ ? client_hash : server_hash;
 
   next_message_ =
       std::string(reinterpret_cast<const char*>(my_hash), kSHA256Length);
@@ -240,7 +241,7 @@ void P224EncryptedKeyExchange::CalculateHash(
     const std::string& client_masked_dh,
     const std::string& server_masked_dh,
     const std::string& k,
-    uint8* out_digest) {
+    uint8_t* out_digest) {
   std::string hash_contents;
 
   if (peer_type == kPeerTypeServer) {
diff --git a/third_party/chromium/crypto/p224_spake.h b/third_party/chromium/crypto/p224_spake.h
index dcfd0fe..122ea46 100644
--- a/third_party/chromium/crypto/p224_spake.h
+++ b/third_party/chromium/crypto/p224_spake.h
@@ -3,10 +3,12 @@
 // found in the LICENSE file.
 
 #ifndef LIBWEAVE_THIRD_PARTY_CHROMIUM_P224_SPAKE_H_
+#define LIBWEAVE_THIRD_PARTY_CHROMIUM_P224_SPAKE_H_
 
-#include <string>
+#include <stdint.h>
 
 #include <base/gtest_prod_util.h>
+#include <base/strings/string_piece.h>
 
 #include "third_party/chromium/crypto/p224.h"
 #include "third_party/chromium/crypto/sha2.h"
@@ -53,7 +55,8 @@ class P224EncryptedKeyExchange {
   // password: secret session password. Both parties to the
   //     authentication must pass the same value. For the case of a
   //     TLS connection, see RFC 5705.
-  P224EncryptedKeyExchange(PeerType peer_type, const std::string& password);
+  P224EncryptedKeyExchange(PeerType peer_type,
+                           const base::StringPiece& password);
 
   // GetNextMessage returns a byte string which must be passed to the other
   // party in the authentication.
@@ -61,7 +64,7 @@ class P224EncryptedKeyExchange {
 
   // ProcessMessage processes a message which must have been generated by a
   // call to GetNextMessage() by the other party.
-  Result ProcessMessage(const std::string& message);
+  Result ProcessMessage(const base::StringPiece& message);
 
   // In the event that ProcessMessage() returns kResultFailed, error will
   // return a human readable error message.
@@ -101,22 +104,21 @@ class P224EncryptedKeyExchange {
 
   // CalculateHash computes the verification hash for the given peer and writes
   // |kSHA256Length| bytes at |out_digest|.
-  void CalculateHash(
-      PeerType peer_type,
-      const std::string& client_masked_dh,
-      const std::string& server_masked_dh,
-      const std::string& k,
-      uint8* out_digest);
+  void CalculateHash(PeerType peer_type,
+                     const std::string& client_masked_dh,
+                     const std::string& server_masked_dh,
+                     const std::string& k,
+                     uint8_t* out_digest);
 
   // x_ is the secret Diffie-Hellman exponent (see paper referenced in .cc
   // file).
-  uint8 x_[p224::kScalarBytes];
-  // pw_ is SHA256(P(password), P(session))[:28] where P() prepends a uint32,
+  uint8_t x_[p224::kScalarBytes];
+  // pw_ is SHA256(P(password), P(session))[:28] where P() prepends a uint32_t,
   // big-endian length prefix (see paper referenced in .cc file).
-  uint8 pw_[p224::kScalarBytes];
+  uint8_t pw_[p224::kScalarBytes];
   // expected_authenticator_ is used to store the hash value expected from the
   // other party.
-  uint8 expected_authenticator_[kSHA256Length];
+  uint8_t expected_authenticator_[kSHA256Length];
 
   std::string key_;
 };
diff --git a/third_party/chromium/crypto/p224_spake_unittest.cc b/third_party/chromium/crypto/p224_spake_unittest.cc
index 9a9f9d2..373bb28 100644
--- a/third_party/chromium/crypto/p224_spake_unittest.cc
+++ b/third_party/chromium/crypto/p224_spake_unittest.cc
@@ -4,6 +4,9 @@
 
 #include "third_party/chromium/crypto/p224_spake.h"
 
+#include <stddef.h>
+#include <stdint.h>
+
 #include <string>
 
 #include <base/logging.h>
@@ -125,7 +128,7 @@ TEST(MutualAuth, Fuzz) {
     // We'll only be testing small values of i, but we don't want that to bias
     // the test coverage. So we disperse the value of i by multiplying by the
     // FNV, 32-bit prime, producing a poor-man's PRNG.
-    const uint32 rand = i * 16777619;
+    const uint32_t rand = i * 16777619;
 
     for (unsigned round = 0;; round++) {
       std::string client_message, server_message;
diff --git a/third_party/chromium/crypto/p224_unittest.cc b/third_party/chromium/crypto/p224_unittest.cc
index 0540dbb..331fc3c 100644
--- a/third_party/chromium/crypto/p224_unittest.cc
+++ b/third_party/chromium/crypto/p224_unittest.cc
@@ -4,9 +4,12 @@
 
 #include "third_party/chromium/crypto/p224.h"
 
+#include <stddef.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <string.h>
 
+#include "base/macros.h"
 #include <gtest/gtest.h>
 
 namespace crypto {
@@ -14,22 +17,20 @@ namespace crypto {
 using p224::Point;
 
 // kBasePointExternal is the P224 base point in external representation.
-static const uint8 kBasePointExternal[56] = {
-  0xb7, 0x0e, 0x0c, 0xbd, 0x6b, 0xb4, 0xbf, 0x7f,
-  0x32, 0x13, 0x90, 0xb9, 0x4a, 0x03, 0xc1, 0xd3,
-  0x56, 0xc2, 0x11, 0x22, 0x34, 0x32, 0x80, 0xd6,
-  0x11, 0x5c, 0x1d, 0x21, 0xbd, 0x37, 0x63, 0x88,
-  0xb5, 0xf7, 0x23, 0xfb, 0x4c, 0x22, 0xdf, 0xe6,
-  0xcd, 0x43, 0x75, 0xa0, 0x5a, 0x07, 0x47, 0x64,
-  0x44, 0xd5, 0x81, 0x99, 0x85, 0x00, 0x7e, 0x34,
+static const uint8_t kBasePointExternal[56] = {
+    0xb7, 0x0e, 0x0c, 0xbd, 0x6b, 0xb4, 0xbf, 0x7f, 0x32, 0x13, 0x90, 0xb9,
+    0x4a, 0x03, 0xc1, 0xd3, 0x56, 0xc2, 0x11, 0x22, 0x34, 0x32, 0x80, 0xd6,
+    0x11, 0x5c, 0x1d, 0x21, 0xbd, 0x37, 0x63, 0x88, 0xb5, 0xf7, 0x23, 0xfb,
+    0x4c, 0x22, 0xdf, 0xe6, 0xcd, 0x43, 0x75, 0xa0, 0x5a, 0x07, 0x47, 0x64,
+    0x44, 0xd5, 0x81, 0x99, 0x85, 0x00, 0x7e, 0x34,
 };
 
 // TestVector represents a test of scalar multiplication of the base point.
 // |scalar| is a big-endian scalar and |affine| is the external representation
 // of g*scalar.
 struct TestVector {
-  uint8 scalar[28];
-  uint8 affine[28*2];
+  uint8_t scalar[28];
+  uint8_t affine[28 * 2];
 };
 
 static const int kNumNISTTestVectors = 52;
@@ -770,15 +771,15 @@ static const TestVector kNISTTestVectors[kNumNISTTestVectors] = {
 TEST(P224, ExternalToInternalAndBack) {
   Point point;
 
-  EXPECT_TRUE(point.SetFromString(
-      std::string(reinterpret_cast<const char*>(kBasePointExternal),
-                  sizeof(kBasePointExternal))));
+  EXPECT_TRUE(point.SetFromString(base::StringPiece(
+      reinterpret_cast<const char *>(kBasePointExternal),
+      sizeof(kBasePointExternal))));
 
   const std::string external = point.ToString();
 
   ASSERT_EQ(external.size(), 56u);
-  EXPECT_EQ(0, memcmp(external.data(), kBasePointExternal,
-                      sizeof(kBasePointExternal)));
+  EXPECT_TRUE(memcmp(external.data(), kBasePointExternal,
+                     sizeof(kBasePointExternal)) == 0);
 }
 
 TEST(P224, ScalarBaseMult) {
@@ -788,22 +789,22 @@ TEST(P224, ScalarBaseMult) {
     p224::ScalarBaseMult(kNISTTestVectors[i].scalar, &point);
     const std::string external = point.ToString();
     ASSERT_EQ(external.size(), 56u);
-    EXPECT_EQ(0, memcmp(external.data(), kNISTTestVectors[i].affine,
-                        external.size()));
+    EXPECT_TRUE(memcmp(external.data(), kNISTTestVectors[i].affine,
+                       external.size()) == 0);
   }
 }
 
 TEST(P224, Addition) {
   Point a, b, minus_b, sum, a_again;
 
-  ASSERT_TRUE(a.SetFromString(std::string(
-      reinterpret_cast<const char*>(kNISTTestVectors[10].affine), 56)));
-  ASSERT_TRUE(b.SetFromString(std::string(
-      reinterpret_cast<const char*>(kNISTTestVectors[11].affine), 56)));
+  ASSERT_TRUE(a.SetFromString(base::StringPiece(
+      reinterpret_cast<const char *>(kNISTTestVectors[10].affine), 56)));
+  ASSERT_TRUE(b.SetFromString(base::StringPiece(
+      reinterpret_cast<const char *>(kNISTTestVectors[11].affine), 56)));
 
   p224::Negate(b, &minus_b);
   p224::Add(a, b, &sum);
-  EXPECT_NE(0, memcmp(&sum, &a, sizeof(sum)));
+  EXPECT_TRUE(memcmp(&sum, &a, sizeof(sum)) != 0);
   p224::Add(minus_b, sum, &a_again);
   EXPECT_TRUE(a_again.ToString() == a.ToString());
 }
@@ -814,8 +815,8 @@ TEST(P224, Infinity) {
 
   // Test that x^0 = ∞.
   Point a;
-  p224::ScalarBaseMult(reinterpret_cast<const uint8*>(zeros), &a);
-  EXPECT_EQ(0, memcmp(zeros, a.ToString().data(), sizeof(zeros)));
+  p224::ScalarBaseMult(reinterpret_cast<const uint8_t*>(zeros), &a);
+  EXPECT_TRUE(memcmp(zeros, a.ToString().data(), sizeof(zeros)) == 0);
 
   // We shouldn't allow ∞ to be imported.
   EXPECT_FALSE(a.SetFromString(std::string(zeros, sizeof(zeros))));
diff --git a/third_party/chromium/crypto/sha2_unittest.cc b/third_party/chromium/crypto/sha2_unittest.cc
index 0c30f45..42dffb5 100644
--- a/third_party/chromium/crypto/sha2_unittest.cc
+++ b/third_party/chromium/crypto/sha2_unittest.cc
@@ -4,7 +4,6 @@
 
 #include "third_party/chromium/crypto/sha2.h"
 
-#include <base/basictypes.h>
 #include <gtest/gtest.h>
 
 namespace weave {
@@ -21,12 +20,12 @@ TEST(Sha256Test, Test1) {
                       0xb4, 0x10, 0xff, 0x61,
                       0xf2, 0x00, 0x15, 0xad };
 
-  uint8 output1[crypto::kSHA256Length];
+  uint8_t output1[crypto::kSHA256Length];
   crypto::SHA256HashString(input1, output1, sizeof(output1));
   for (size_t i = 0; i < crypto::kSHA256Length; i++)
     EXPECT_EQ(expected1[i], static_cast<int>(output1[i]));
 
-  uint8 output_truncated1[4];  // 4 bytes == 32 bits
+  uint8_t output_truncated1[4];  // 4 bytes == 32 bits
   crypto::SHA256HashString(input1,
                            output_truncated1, sizeof(output_truncated1));
   for (size_t i = 0; i < sizeof(output_truncated1); i++)
@@ -49,7 +48,7 @@ TEST(Sha256Test, Test1_String) {
   std::string output1 = crypto::SHA256HashString(input1);
   ASSERT_EQ(crypto::kSHA256Length, output1.size());
   for (size_t i = 0; i < crypto::kSHA256Length; i++)
-    EXPECT_EQ(expected1[i], static_cast<uint8>(output1[i]));
+    EXPECT_EQ(expected1[i], static_cast<uint8_t>(output1[i]));
 }
 
 TEST(Sha256Test, Test2) {
@@ -65,12 +64,12 @@ TEST(Sha256Test, Test2) {
                       0xf6, 0xec, 0xed, 0xd4,
                       0x19, 0xdb, 0x06, 0xc1 };
 
-  uint8 output2[crypto::kSHA256Length];
+  uint8_t output2[crypto::kSHA256Length];
   crypto::SHA256HashString(input2, output2, sizeof(output2));
   for (size_t i = 0; i < crypto::kSHA256Length; i++)
     EXPECT_EQ(expected2[i], static_cast<int>(output2[i]));
 
-  uint8 output_truncated2[6];
+  uint8_t output_truncated2[6];
   crypto::SHA256HashString(input2,
                            output_truncated2, sizeof(output_truncated2));
   for (size_t i = 0; i < sizeof(output_truncated2); i++)
@@ -89,12 +88,12 @@ TEST(Sha256Test, Test3) {
                       0x04, 0x6d, 0x39, 0xcc,
                       0xc7, 0x11, 0x2c, 0xd0 };
 
-  uint8 output3[crypto::kSHA256Length];
+  uint8_t output3[crypto::kSHA256Length];
   crypto::SHA256HashString(input3, output3, sizeof(output3));
   for (size_t i = 0; i < crypto::kSHA256Length; i++)
     EXPECT_EQ(expected3[i], static_cast<int>(output3[i]));
 
-  uint8 output_truncated3[12];
+  uint8_t output_truncated3[12];
   crypto::SHA256HashString(input3,
                            output_truncated3, sizeof(output_truncated3));
   for (size_t i = 0; i < sizeof(output_truncated3); i++)
